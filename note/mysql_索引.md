### 1.什么是索引
- 官方定义: 一种帮助 MySQL数据库 提高查询效率的数据结构
- 索引的优点: 
  - 大大加快数据查询速度
- 索引的缺点: 
  - 1、维护索引需要耗费数据库资源
  - 2、索引需要占用磁盘空间
  - 3、当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响
### 2.索引分类
- **主键索引**  
  - 主键：唯一标识一条记录，不能有重复的，不允许为空
  - 索引：该字段没有重复值，但可以有一个空值
  - 设定为主键后数据库会自动建立索引，innoDB 为聚簇索引
- **唯一索引**
  - 索引列的值必须唯一，但允许有空值
- **单值索引** 单值索引 普通索引
  - 即一个索引只包含单个列，一个表可以有多个单列索引 
- **联合索引**  复合索引)
  - 即一个索引包含多个列 
- **Full Text 全文索引** 
  - My5.7版本之前 只能用在MYISAM引擎上
  - 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR、 TEXT类型列上创建。
  - MYSQL只有MYISAM存储引擎支持全文索引 



对于**联合索引**：

联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那建议这种情况下使用联合索引。

```markdown
【场景】：在学生管理系统里面需要去查某个学生的电话号码。
建立索引一定是这样的：create index phoneQuick on student_info(school, grade, class, phone);

【场景】：在学生管理系统里面需要去查某个学生的student_id。
建立索引一定是这样的：create index phoneQuick on student_info(school, grade, class, student_id);
```

### 3.索引的基本操作

### 3.1 主键索引

> 建表的时候自动创建，不需要手动创建

```sql
-- 建表 主键自动创建主键索引 
create table t_user(
    id varchar(20) primary key,
    name varchar(20)
); 

-- 查看索引 
show index from t_user;
```

<img alt="image" src="https://img-blog.csdnimg.cn/img_convert/17976888b7e6adf9c7bf1ab3b299b81e.png">

#### 3.2 单列索引

(普通索引|单值索引) 

```sql
--建表时创建 
create table t_user(
    id varchar(20) primary key,
    name varchar(20), key(name)  -- '注意:随表一起建立的索引索引名同列名一致'
);


--建表后创建 
create index [index_name] on [table_name]([field]);
create index nameindex on t_user(name);

--删除索引 
drop index 索引名 on 表名;
drop index nameindex on t_user;
```

<img alt="image" src="https://img-blog.csdnimg.cn/img_convert/7998587146756815276c97671b568e0d.png">

```
show index from t_user;
```

![image-20221221230841818](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202212212326397.png?tximg)

#### 3.3 唯一索引 

```sql
--建表时创建 
create table t_user(
    id varchar(20) primary key,
    name varchar(20), unique(name)  -- 唯一索引
);

--建表后创建 
create unique index nameindex on t_user(name);
```

<img alt="image" src="https://img-blog.csdnimg.cn/img_convert/66b299ddf2a027a6b7958d1f9420f2c2.png">

#### 3.4 复合索引_常用

```sql
---建表时创建 
create table t_user(
    id varchar(20) primary key,
    name varchar(20),
    age int,
    key(name,age)  -- 联合索引
);

--建表后创建 
create index nameageindex on t_user(name,age);
```

<img alt="image" src="https://img-blog.csdnimg.cn/img_convert/c16855c15ca0be73d3cb11b8196c5165.png">

**最左前缀原则**，左包含原则

联合索引（a_b_c）等价于（a，a_b，a_b_c）三个索引



### 4.索引的底层原理

1.思考 

```sql
---建表 
create table t_emp(
    id int primary key, -- 主键索引
    name varchar(20),
    age int
);

--插入数据 
insert into t_emp values(5,'d',22); 
insert into t_emp values(6,'d',22); 
insert into t_emp values(7,'e',21); 
insert into t_emp values(1,'a',23); 
insert into t_emp values(2,'b',26); 
insert into t_emp values(3,'c',27); 
insert into t_emp values(4,'a',32); 
insert into t_emp values(8,'f',53); 
insert into t_emp values(9,'v',13);

--查询 
select * from t_emp;
```

<img alt="image" src="https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202212212326727.png?tximg">



#### 4.1 思考：乱序插入

> why：没有按顺序插入，为什么查询时却是有顺序呢？？

**原因**：mysql底层为主键自动创建索引,一定创建索引会进行排序

> why：那又为什么要排序呢？？？

因为排序之后在查询就相对比较快了 如查询 id=3的我只需要按照顺序找到3就行啦(如果没有排序大海捞针,全靠运气😸!)



> 为了进一步提高效率mysql索引又进行了优化

mysql底层真正存储是这样的：**按页管理数据**

- 基于页的形式进行管理索引
- 如 查询id=4的 直接先比较页 先去页目录中找,再去 数据目录中找

![image-20221221233104288](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202212212331491.png?tximg)





#### 4.2 什么是B+树
- 参考资料: 
<img alt="image" src="https://img-blog.csdnimg.cn/img_convert/0feb1be2306fe4083089d930d0e555c4.png">

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点(即一个页)能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，**降低B+Tree的高度**。

**B+Tree相对于B-Tree有几点不同：**

1. 非叶子节点只存储键值信息
   - 因为叶子节点大小有限，只有16KB，只用来存放key就能够放得下更多的索引值
   - 进而降低了树的高度
2. 所有叶子节点之间都有一个链指针
   - 便于顺序查询
3. 数据记录都存放在叶子节点中

**特点：**

1. InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=1K个键值(因为是估值，为方便计算，这里的K取值为〖10〗^3)。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
   - 取决于实际计算的多少，例如创建的是：int+char(8)+char(4)+int = 20，那么算出来的值就大于10亿条记录。所以说**一个表的字段太多就会造成一定的性能问题。**
   - 最底下的每页存不了那么多的数据，就会出现性能问题。
2. 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。
   - InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1-3次磁盘I/O操作。
   - 一般用到两层B+Tree就能满足300*10^3 = 30w 大概能满足30-45万数据量的快速查询，因为根节点常驻内存，仅需一次磁盘IO即可找到对应的数据。



#### 4.3 聚簇索引和非聚簇索引

> 聚簇索引就是直接把数据存到叶子节点上，顺着树就能找到数据的实际位置，少了一次查找。
>
> - ”聚“，就是把 [行数据] 和 [主键值 ] 聚合在一起了
>
> 非聚簇就是存数据指针，根据指针再去找一遍数据实际位置

-  聚簇索引： 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 
-  非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置



 `注意`:在innodb中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。

- 辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找。 （因为CRUD，所以存的是主键值）

![](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202212220003844.png?tximg)

**InnoDB**

- InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。(重点在于通过其他键需要建立辅助索引)
- **聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一且非空的索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键(类似oracle中的RowId)**来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。

**MYISAM**

- MyISAM使用的是非聚簇索引，**非聚簇索引的两棵B+树看上去没什么不同**，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于**索引树是独立的，通过辅助键检索无需访问主键的索引树**。
- 偏向于查询，但是不支持事务

![](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202212220021777.png?tximg)

##### 4.3.1 聚簇索引的优势
-  问题: 每次使用辅助索引检索都要经过两次B+树查找，看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？**聚簇索引的优势**在哪？ 
   -  由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中(缓存器)，再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。
   -  辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要**分裂变化**；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。
   -  另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。 
      -  MYISAM：CRUD的时候需要维护多个索引表
##### 4.3.2 聚簇索引的细节

> 注意点：

- 当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出现新增加记录的uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。
- **建议使用int类型的自增**
  - 方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。
  - 主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到IO操作读取到的数据量。
- 为什么主键通常**建议使用自增id**？
  - 聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。
  - 如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。
- bigint相对int，哪个更好？
  - 互联网业务可能会用到bigint作为主键
  - 一般业务推荐自增主键使用int unsigned类型，上限为42亿，这个预留量已经是非常的充足了，很多业务根本用不到这么大的表



### 5. 无法利用索引情况

-  查询语句中使用LIKE关键字 
   -  在查询语句中使用 LIKE 关键字进行查询时，如果匹配字符串的第一个字符为“%”，索引不会被使用。如果“%”不是在第一个位置，索引就会被使用。
-  查询语句中使用多列索引 
   -  多列索引是在表的多个字段上创建一个索引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。
   -  【例子】给你一张菜单，你不按着川菜粤菜湘菜往下查，直接就找有几种米饭的做法，这肯定用不上我给的索引了。得再建立一个索引了。
-  查询语句中使用OR关键字 
   -  查询语句只有OR关键字时，如果OR前后的两个条件的列都是索引，那么查询中将使用索引。如果OR前后有一个条件的列不是索引，那么查询中将不使用索引。 



### 6. explain

> 官方文档：https://dev.mysql.com/doc/refman/5.7/en/explain-output.html

判断是否使用索引

![image-20230202104822978](C:/Doc/typora_pic/image-20230202104822978.png)



| 字段     |      |                                                              |
| -------- | ---- | ------------------------------------------------------------ |
| id       |      |                                                              |
| type     |      | [link](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types) |
| key      |      |                                                              |
| key_len  |      | 越小越好                                                     |
| ref      |      |                                                              |
| filtered |      |                                                              |

首先我们要了解mysql查询优化器的执行效率，大约有10个，重点几个主要就是const，ref，range ，index，all。Const效率是最块的，成本可以忽略不计，主要通过主键或者唯一值查询的sql。还有比const更快的system，这种时候必须是mysql优化器内部精确计算查询成本，所以system不适用于innoDB，只适用于myISAM。Ref代表用的是索引b+tree查询的时候，比如用连接查询的时候，连接查询的条件是索引唯一值，这时候还分为eq-ref，er-ef是当被驱动表查询的是主键或者唯一二级索引的时候，这时候就是显示eq-ref。当连接表的条件是普通索引查询的时候，这时候显示就是ref，range顾名思义就是索引区间查询的时候，index代表查询覆盖索引的时候，all就是放弃索引全盘扫描了。

首先我们明白Semi-join使用条件在where或者on后面，必须in布尔组成，而且必须是and连接。

第一个参数是id，理论上几个select就有几个id，但当mysql优化器优化成内连接的时候，这时候只有一个id。

第二个参数是select type，这里有simple，只要不包含子查询或者union都算是simple，当有union的时候，最左边查询显示select type是primary，右边则是union类型，union还有union result类型，当union去重的时候，会创建临时表用来去重，这时候就显示union result。以及还有相关子查询union和不相关子查询。还有from后面连接select的派生查询，derived。当吧子查询物化后，子查询在与外部链接，这时候就是物化查询。

Possible key是可能用到的索引，在计算成本的时候，会根据使用全部查询还是索引查询效率更高，当回表的成本太高，会使用全表查询，所以possible key不是越多越好，而key就是实际查询使用到的索引，key_len代表长度，可以根据当前表的字符集来计算出索引长度，比如varchar100，utf8 是字符集1~3，则是100*3。

Ref这列，当查询的type是上面 的const，ref，index其中之一的时候，显示的是const，当使用函数的时候，显示的usering condition。

Rows就代表查询了多少行才获取到数据，当all的时候代表要查询所有的行数。

Filtered过滤有两种情况，一种是单表查询，当有索引和非索引查询，这里如果显示10，则代表过滤完索引之后，百分之10的数据满足非索引条件查询。当union联合查询的时候，这种是表示驱动表的扇出值，被驱动表满足百分之10的数据，和rows组合可以计算出扇出值。

Extra顾名思义，记录额外数据的地方，比如sql里面没有写表，会显示no table，当有函数max，min的时候也会显示，当覆盖索引的时候，显示useing index。


