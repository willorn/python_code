## 栈切换

我们说程序被加载到内存后，执行的代码是 _start，而该代码是嵌入到程序文件中的，那么该代码是由谁添加的呢？毫无疑问肯定是生成可执行文件时产生的，也就是在链接阶段产生的。

我们看到在描述中：ABI规定了初始参数通过栈来传递，由于栈是存储一个程序片段私有的数据，那么我最初由操作系统往内部放入值时特权级是 0，转由程序执行后是特权级是 3，那么这两段代码使用的是同一个栈嘛？推测以下也不可能是同一个，毕竟如果是同一个，我们就可以通过对栈指针进行移动来读取操作系统放入栈中的数据了。所以我们猜测其不是使用的同一栈，而是中途有栈的切换 => 怎么切换呢？我们知道指定一个内存地址需要通过 IP 地址指定虚拟地址 + 段寄存器中存储的下标到 GDT中找到段对应的基址 才得到一个地址，所以我们可以在特权级切换时改变段寄存器中的下标就能实现栈的切换

The processor switches to a new stack to execute the called procedure. Each privilege level has its own stack. The segment selector and stack pointer for the privilege level 3 stack are stored in the SS and ESP registers, respectively, and are automatically saved when a call to a more privileged level occurs. The segment selectors and stack pointers for the privilege level 2, 1, and 0 stacks are stored in a system segment called the task state segment (TSS).

## 二进制运算

与运算：二进制截断

或运算：二进制组合

异或运算：无进位加法



## 参数传递规范

![img](https://cdn.nlark.com/yuque/0/2022/png/2641989/1654052172614-c1ebe5c7-4940-4079-a0ed-04eb9c68971b.png)

### 函数指针

```c
    void   (*init) (void);
//  返回值  指针名  参数值
```



_glibc_likely(boolean表达式) => 表示该括号内的值通常为真，告诉编译器和CPU分支预测提前加载





## setjmp、longjmp原理

由于 CPU 执行代码通过与寄存器交互实现功能，寄存器中存储的内容就等同于当前程序执行的上下文





## 使用 JVM 来查看程序运行过程

首先找到 `libjvm.so` ，使用 `readelf` 查看程序头部表

libjvm.so 是 Java 的动态链接库，同时也包含了虚拟机