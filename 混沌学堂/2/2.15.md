看书通过知识树转换吸收，而不是一个字一个字的查看，只需要将书籍当作字典查看即可。

### csapp 7.6.3

如何来解析引用呢？

链接器维护三个集合 

1. E（execute）：可重定位目标文件集合，这个集合中的文件会被合并为一个可执行文件
2. U（undefine）：一个未解析的符号，即已经引用但是尚未定义的符号
3. D（definition）：已经定义的符号集合

从左到右依次读取命令行中输入的文件，对三个集合进行操作。当所有文件都操作完成后，如果 U 是空集合，那么就可以链接成功 （符号解析成功），否则则会报错。

 

### 32位机做相对寻址

在做完符号解析之后，需要将各个文件中的小节（`.section`）合并到一个文件中组成一个大段，这样程序中每条指令和数据在内存中就有唯一的地址了（之前每个小节都是 从0地址开始偏移，所以多个小文件中其实是一个地址对应多个文件中的多个地址的）。

合并之后呢，我们需要将代码段和数据段中的对符号的引用地址修正。

这时就需要借助重定位表了：

  ![img](D:/javaDoc/pic/1654497165664-9eed4c23-cdd7-4765-812f-f253b4b9103e.png)

1. offset：需要更正的地址位置偏移量，相对于该节的开始处
2. type：主要分为两类

1. 1. R 386 PC32：Relocate a reference that uses a 32-bit PC-relative address.（使用32位的PC相对位置偏移重定位一个引用）
   2. R 386 32：Relocate a reference that uses a 32-bit absolute address.（使用32位的绝对地址重定位一个引用）

1. symbol：symtab的下标，用于指定符号，通过中间层可以让 值的存储可以高度自定义，包括编码等一系列信息都可以通过在另一张表中进行实现
2. addend：对修改时做偏移调整



![img](D:/javaDoc/pic/1654498861600-c135a998-5542-4a5a-a78b-e1059d2c7790.png)

在偏移模式下的地址重定位地址的填写

### debug原理

debug看到程序的信息中有调试信息，我们试着推敲下 debug 功能是怎么实现的呢？

有一个源代码行号于机器码执行地址的对应关系，这样就能够通过该对应关系确定程序执行到那一行了。



那断点是怎么触发的 呢？怎么让代码停止在断点处的呢？

我们可以将执行的代码进行替换，或者穿插一些代码在源代码中，不过如果是穿插的话，就需要将后续的代码往后挪动，这就会导致很多地址变化，所以是不能够使用 插入代码的方式的，所以只能使用替换 <= 当前代码长度的代码才行。



`INT3` 《intel 开发手册》





### 打桩技术

Linux提供的一种机制，允许截获对共享库函数的调用，取而代之执行自己的代码，使用该机制可以实现追踪函数调用，也可以替换为自己实现的代码。

为`目标函数`实现一个`包装函数`，包装函数需要和目标函数有同样的原型，然后通过某种打桩机制欺骗系统调用包装函数。

打桩可以发生在编译时、链接时、**运行时（动态的）** 后续 pertools 使用相关原理

**编译时打桩：**

通过自定义包装函数，并定义 .h 头文件，在头文件中使用 `#define` 定义替换函数

![img](D:/javaDoc/pic/1654505441201-566ef113-98fc-49e3-81d6-5f252a2ecbd7.png)

**链接时打桩:**

通过在命令行输入命令实现函数调用的更改

![img](D:/javaDoc/pic/1654505530611-2dc8e4c7-cc78-4792-a34f-bba8ebfc06a5.png)



**运行时打桩：**

上述说的内容都是静态的，即在程序真正运行之前进行的，那肯定与之对应的有动态的替换呀。那动态的怎么替换呢？我们知道对共享库的调用是需要使用 GOT 和 PLT 来共同实现代码的跳转的，所以我们是否可以间接的改变 GOT 让其中存放的目标函数地址指向包装函数上呢？

实现这一功能的方式是一个重要的链接器的环境变量 —— `LD_PRELOAD` 

该环境变量用于设置为共享库路径名的列表（使用空格或分号分割），这样当加载和执行一个程序时，解析未定义的引用就会先从 `LD_PRELOAD` 中查找，基于这个机制，可以对共享库中的任何函数打桩。