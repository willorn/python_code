

# 第四章 C语言





## 2.1 缓存一致性、指令流水线、寄存器命名

之前我们将intel的历史从 8086、8088 到 I486 推理了一遍，接着继续查阅历史

### 奔腾处理器

> The introduction of the Intel Pentium processor added a second execution pipeline to achieve superscalar performance (two pipelines, known as u and v, together can execute two instructions per clock). The **on-chip first-level cache doubled**, with 8 KBytes devoted to code and another 8 KBytes devoted to data. The data cache **uses the MESI protocol to support more efficient write-back cache in addition to the write-through cache** previously used by the Intel486 processor. Branch prediction with an on-chip branch table was added to increase performance in looping constructs.
>
> In addition, the processor added: 
>
> • Extensions to make the virtual-8086 mode more efficient and allow for 4-MByte as well as 4-KByte pages 
>
> • Internal data paths of 128 and 256 bits add speed to internal data transfers
>
> • Burstable external data bus was increased to 64 bits 
>
> • An APIC to support systems with multiple processors 
>
> • A dual processor mode to support glueless two processor systems 
>
> A subsequent stepping of the Pentium family introduced Intel MMX technology (the Pentium Processor with MMX technology). Intel MMX technology uses the single-instruction, multiple-data (SIMD) execution model to perform parallel computations on packed integer data contained in 64-bit registers. See Section 2.2.7, “SIMD Instructions.”
>
> 译：
>
> 奔腾处理器增加第二个执行流水线，以实现更高的性能。并且在多核处理中每个核内增加一级缓存（分为 8 kb 的缓存code，和 8kb 的缓存data ---- 称为 I-Cache，D-Cache），数据缓存使用 MESI 协议 支持更高效的一种方式 write back 方式 来保证一致，而不是使用 之前的 write through。并且增加了 使用 核内分支表来实现分支预测 以提高循环结构的性能。
>
> 除此之外，还增加了：
>
> 1. 更高效的虚拟8086模式，允许使用 4kb 和 4mb 的分页大小
> 2. 外部数据总线达到 64 bit
> 3. 使用 APIC 支持系统的多处理器
> 4. dual processor 模型支持多核机制

通过上诉奔腾处理器的描述，我们发现在 I386 之后，其实都是在硬件上对 CPU 进行增强（比如：增加总线宽度，增加缓存……），但是我们是做软件的，没必要继续深入研究，所以我们了解了这样一个阶段历史，就可以进行针对性的学习，主要学习 I386 的实现，因为 I386 虽然小，但是功能是齐全的。



> 接下来我们要看到CPU是如何去操作数据的，操作数据就需要先保证数据的一致性，那么如何去保证呢？
> CPU有APIC、MESI协议、流水线……

### 名词：on-chip、APIC

在引入了多核处理器上，我们就可以在一个处理器上嵌入多个处理器核心，以达到高性能。嵌入的核心，就称之为 chip，而由多个处理器核心组成的处理器称为 node 或者 slot。 ------ 这种多核处理器的设计技术称之为 dural processor。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921385.png?tximg)



APIC：高性能处理器中断控制器，更加高效的 中断处理控制器

![image-20221019160323994](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921386.png?tximg)

### 一级缓存、MESI协议

引入了多核处理器，为了最大化每个核心的速度，为每个核心添加了 一级缓存（这就如同从外边看CPU一般，我中有你，你中有我），可以类比到我们的服务器中保留本地缓存（ConcurrentHashMap）一样，如下：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921387.jpeg?tximg)

我们说每当我们为了改善一个问题而加入一些东西，就会有新的问题的产生。这里我们为了更加提高效率增加了缓存，就会出现数据一致性的问题，如果每个核心处理完数据都只往一级缓存写，而不同步到 **各个核心共享的内存中**的话，就会出现数据的不一致问题，这是一个严重的业务问题。如果不解决，该设计就是错误的设计。

怎么解决？每次发生写事件时，将更改的数据同步到共享的内存中，这就是在 I486 使用的 `write through`**，**每次写都写两个地方（缓存、共享内存）。类比到分布式环境中，也是有通过双写来保证数据一致性的，不过我们始终要记住一句话：**任何上层的东西都可以用底层来推，只不过上层增加了一个 计算机网络，存在不稳定性**

那分布式环境中的不稳定性要怎么保证呢？`双写都成功返回`才算成功，否则返回失败。

可以发现这种方式下性能其实是有所下降的，因为每次写操作都要写两次，而且是同步的写。

就想怎么避免每次写都做两次写操作，我们可以写的时候只写缓存并返回，后续由某个控制器再进行刷入共享内存中。这就等同于先将数据写入`EhCache`， 直接返回，由`EhCache`中的某些操作将数据同步到MySQL中；

#### MESI wirte-back机制

那CPU是如何做的呢？当前处理器将缓存修改了会将其标记为无效状态，其他的处理器再读取的时候会先通知该处理器将内存写回缓存，然后才能加载。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921388.jpeg?tximg)

另一种方式是其他处理器加载时发现是无效状态，则会通知该处理器将数据写回并转发给需要加载该缓存的处理器。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921389.jpeg?tximg)

**这类比到分布式中，不就是异步处理嘛。中间的过程靠谁来处理呢？使用 MQ实现，那CPU又靠谁来实现呢？RingBus**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921391.jpeg?tximg)

那三级缓存情况下，怎么使用，对于当前Node而言，我们可以看作三级缓存就等同于内存，并不需要通过MESI来保证三级缓存的一致性，不过需要保证当三级缓存换出时，更改的部分必须刷入到内存中。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921392.png?tximg)

### 什么是流水线 

**指令执行可以分为 五个流水线过程：取指（IF：Instructions Fetch）、译码（ID：Instructions Decode）、执行（EXE）、访存（MEM）、写回（WB：Write Back）**。而对应的刚好有这五个单元的处理：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921393.png?tximg)

如果每一条指令执行都是占用整个过程的话，无疑会导致部分单元的空闲，（如：一条指令执行到 执行单元 时，如果非流水线执行的话，就会导致除执行单元在执行外，其余单元都是空闲的状态），可以类比到分布式环境中，如下：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921394.png?tximg)

假设系统中只有一条线程在执行，如果用户必须要从头请求完所有的服务后才得以返回的话，就会导致除当前执行的服务处于工作状态外，其余服务全是空闲or等待状态，无疑是对于资源利用率非常低。一般这种情况可以采用异步处理，通过添加一个 MQ，让每个服务处理完后生成消息发送到 MQ，各个服务订阅消息对其进行自己的业务逻辑处理：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921395.png?tximg)

那CPU中对指令的处理是不是也可以通过这种方式来实现指令的并行处理呢？肯定是可以的，只不过使用的不是MQ，而是锁存器：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921396.jpeg?tximg)

**中间添加了这么多的锁存器会造成什么影响呢？就比如我们添加了MQ进行异步处理，会造成处理延迟，不过也是有好处的，可以提高指令的并行以及吞吐量。**

### 后续历史

后续的发展都是围绕着硬件进行展开，我们其实无需进行深究......



### 寄存器

我们说，汇编无疑是去操作CPU的寄存器的，于是我们学习CPU的一些知识，由于要知其先后，所以我们需要看历史，随后我们需要看寄存器的一些基础知识，之前我们虽然推理了一些寄存器，但是并未与其名字等对应上，所以需要查看 intel 手册进行对应学习；

寄存器命名规则：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921397.jpeg?tximg)

除此之外，**由于intel是从16位开始发展的，所以一个** `w `**表示 2byte，**`l `**表示4 byte，**`q` **表示 8 byte**。word、l、q



**指令地址寄存器：IP**
**状态寄存器：EFLAGS**
**栈顶寄存器：ESP  （stack pointer）**
**栈底寄存器：EBP （bottom pointer）**



## 2.2 寄存器，汇编到C语言

### 寄存器的分类

**General-Purpose Registers**

> The 32-bit general-purpose registers EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP are provided for holding the following items: 
> • Operands for logical and arithmetic operations 
> • Operands for address calculations 
> • Memory pointers
>
> 32bit提供了EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP这些通用寄存器 支持存放以下东西:
> • 用于 逻辑运算 和 算术运算的 操作数
> • 用于 地址计算 的操作数
> • 内存指针



#### 推理ESI、EDI

想一个需求：我们想要将 内存中的 一个字符串 移动到另一个内存地址应该怎么做呢？

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921398.jpeg?tximg)

不管怎样，我们在移动时，这些信息肯定要是已知的：源串起始地址、目的地起始地址、串长度。

而在实模式下，定位一个地址需要 `虚拟地址 + 段基址` 才能确定，所以说保存这两个地址肯定都是需要使用两个段寄存器 和 两个虚拟地址的，`段寄存器`有 扩展段寄存器 和 DS、SS、CS 等，而现在已知表示虚拟地址的就是 EIP，且还是一个专用寄存器，所以需要两个表示`偏移地址的寄存器` ------ SI、DI

于是：**SI 表示源串的虚拟地址**，**DI 表示目的地的虚拟地址**。而 源串 的段基址就通过 DS 数据段寄存器来存储了，因为站在一个宏观的角度而言，所有内存中的所有内容都称为数据，目的地址的段基址就通过 ES 扩展段寄存器来存储了。

最后**字符串的长度**用什么来存储呢？可以随便用一个通用寄存器来存储，不过规定是使用 ECX （为何？C：counter）

**`通用寄存器`：除了用于自己的特有的用途外，还能随意用于存放其他的内容。**



#### 验证ESI、EDI

以上是推理，那么实际上是怎样呢？ 验证：

> 《intel 开发手册》 p75：
>
> Many instructions assign specific registers to hold operands. For example, string instructions use the contents of the ECX, ESI, and EDI registers as operands.
>
> 译：很多指令需要分配特殊的寄存器去保存操作数，例如：**字符串的指令 使用 ECX、ESI 和 EDI register 做为操作数。**
>
> 《intel 开发手册》 p76：
>
> ESI — Pointer to data in the segment pointed to by the DS register; source pointer for string operations 
>
> EDI — Pointer to data (or destination) in the segment pointed to by the ES register; destination pointer for string operations
>
> 译：
>
> **ESI：字符串操作的源指针，指向由 DS 寄存器指向的段中的数据指针；**
>
> **EDI：字符串操作的目的指针，指向由 ES 寄存器指向的段中的数据（或目的）指针；**



给定一个Linux中的内存迁移代码：

```plain
;注意以下是 intel 汇编语法
mov	ax,#BOOTSEG    		 ;将 #bootseg 地址移动到 ax
mov	ds,ax   			 ;将 ax 中的地址移动到 数据段寄存器,因为段寄存器中的值不能通过立即数传递,所以需要使用寄存器转结
mov	ax,#INITSEG   
mov	es,ax					;将 initseg 地址移动到 es 扩展段寄存器中
mov	cx,#256				   ;将 cx 寄存器 设置为 256
sub	si,si					;将 si 和 di 清零
sub	di,di
rep								;重复指令,直到cx为零
movsw							;每次移动一个字   2byte

; 总共移动 256次,每次2byte,总共就 2 * 256 = 512byte 
```



### 通用寄存器的规定用途:

• EAX — Accumulator for operands and results data
• EBX — Pointer to data in the DS segment
• ECX — Counter for string and loop operations
• EDX — I/O pointer
• ESI — Pointer to data in the segment pointed to by the DS register； source pointer for string operations
• EDI — Pointer to data (or destination) in the segment pointed to by the ES register； destination pointer for string operations
• ESP — Stack pointer (in the SS segment)
• EBP — Pointer to data on the stack (in the SS segment)



### 汇编语言 快速过基础

《汇编语言基于X86处理器》 ---- 汇编语言基础一整章

保留字没有大小写之分





## 2.3 C语言 抽象

至此 汇编已经讲完，开始进入高级语言，因为所有的高级语言最终都会生成 机器语言（可以等价为 汇编语言），所以我们在了解底层的汇编语言之后，上层的一切语言都是一样的。我们这里就以 C语言为代表推理高级语言，其余高级语言也是类似的。

**C语言是通过汇编推理出来的，因为 C语言是汇编的最纯粹抽象**



一个需求：指令段 A 调用指令段 B，需要指令段 B 能够修改指令段 A 的一个私有数据。

就如同我们在Java中想要修改不同方法中的对象数据一样，其实就是作为参数传递过去，不过对于普通数值类型的参数时，就需要将变量的地址进行传递，这样被修改后才能访问到修改后的值。



#### 设计一门语言

之前我们有讲过怎么样设计一门语言：将下层的复杂性屏蔽

```
指令段表示 抽象为     ------> 函数body
内存单元大小 抽象为   ------> 类型（byte、int、short....）、结构体、数组
    组合型的类型 抽象为      ------> 结构体
    相同类型的连续单元 抽象为 ------> 数组
    数据地址操作 抽象为      ------> 指针操作
```



**从简单的程序~程序的执行过程**

```c
#include <stdio.h>
 
int main()
{
    printf("Hello, World! \n");
    return 0;
}
```



### 系统调用~printf()

> 我们说应用程序运行需要经过操作系统的调度，而操作系统又是由C语言编写的一套程序，那么是不是就是一个悖论了呢？
>

其实并不是，对于任何一个程序而言，操作系统都是独立出来的，只有当涉及到一些硬件相关的操作，也就是涉及到其余特权级的调用时，才会通过操作系统来实现，也称之为**系统调用**：



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653278690575-959aaa8b-a913-4ab2-8ddf-e8367fa7f8f5.jpeg?tximg)



程序中 printf() 属于打印显示，那肯定涉及到硬件了，所以需要通过操作系统去完成



### 函数调用过程

![函数调用01.jpg](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653279572682-1f4c2077-5ef0-4abc-ab95-05ab39fbbe71.jpeg?tximg)

按照之前我们在推理栈帧的开辟时得出，为了能在从函数 B 返回函数 A 时能获得 A 的栈底地址，所以将栈底地址压入栈中，这样就可以通过 pop ESP 的操作将 EBP 的值恢复了。

但是我怎么实现 A 代码到 B 代码执行，后续又返回到 A 代码接着执行呢？很容易想到与保存栈底的方法来保存 EIP 也即 将指令地址寄存器压栈。

![函数调用02.jpg](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653280019105-c2712df1-ab14-464a-8b3d-5d5df53360be.jpeg?tximg)

详细一点就是：每次在调用其他的函数时，首先将当前函数调用i指令的下一条指令地址压入 栈中，然后将 EIP 指向跳转的函数的首地址，这样就可以实现 EIP 指令的正确指向。 

综上：call 指令负责了将 该函数段内的下一条指令压入栈中，并将 EIP 指向调用函数的首地址。在进入到新的函数时，会将 ebp 压入栈中，并将此时的 esp 地址给 ebp，随后正常执行指令。该函数最后将 ebp 的值恢复，并调用 ret 指令，ret 指令不难猜到是将 A EIP 弹出赋值给 EIP 寄存器。

#### 验证

##### call指令、ret指令完成的内容

> **《intel 开发手册》 p713** 
>
> **Near Call.** When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) on the stack (for use later as a **return-instruction pointer**). 
>
> near call （代码段内调用，同一个 CS 寄存器中的……），当执行一次 near call 时，处理器 将 EIP 寄存器的值（包含了 call 指令的偏移量）压入栈中，用于做返回指令的指针



> **《intel 开发手册》 p1747**
>
> **Near Return，** When executing a near return, the processor pops the **return instruction pointer** (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.
>
> near return (代码段内调用，CS 是同一个值)，当执行一个 near return，处理器从栈顶弹出 返回指令指针 赋值给 EIP 寄存器 ，然后再新指针处开始执行，CS 寄存器中的值是不会改变的。

如上，我们验证了 call指令 和 ret 指令的过程，但是 关于 EBP 的值是怎么被压入栈中的我们还不得而知，于是我们就可以通过对源代码进行汇编文件生成，然后查看汇编文件得到答案：

https://flowus.cn/willorn/share/70be1d19-74a3-49df-b819-ada4e4b7d89b【FlowUs 息流】

```shell
gcc -m32 -S hello.c  # 只编译生成汇编代码片段，且通过 32 位的模式生成
gcc -S -fno-asynchronous-unwind-tables  # 去除生成的 针对debug 使用的信息
```




### 如何传递参数：栈+寄存器

既然方法之间已经可以正常调用了，那么我想要在方法之间传递参数需要怎么实现呢？

> 在分析之前，我们需要知道参数可以分为两类：
>
> 1. `值`，只是将当前数据的值传递过去，其他函数对参数的修改不会对当前函数中的值造成影响
> 2. `地址`，将当前值所存储的地址传递过去，其他函数将会在该内存位置进行操作，会对当前函数造成影响
>     不管是属于哪一类，其实都是数据，关注的是怎么样让他们知道对方发送的参数呢？
>

我们可以借助于**栈的机制**，每次在call新的函数时，将需要传递的参数放到当前栈帧的栈顶部分，当进入到另一个函数时，就通过从栈顶向下依次读取参数

当然，也可以通过使用 **寄存器来存储**，既然 可以通过 寄存器来存储 `返回值`，那也可以使用寄存器来存储 `参数值`，不过有一个问题，寄存器的数量比较少，且比较昂贵，而且参数的数量是无法预知的，所以这并不是万全之策，因此需要结合 **栈 和 寄存器** 两种方式使用。



## 2.4 指针

首先将参数传递验证了，验证以及推理部分在上一篇笔记中已经完成！

### 数据的可见性

通过汇编代码，我们可以看到一个 `.global` 是指全局可访问，那我们是否可以让 某些变量 或者 函数 只能在某一个 `.c文件` 中可见呢？ 以此来达到 数据以及函数 的隔离。

通我们通过汇编代码发现，其中并没有 关于 data 的信息了，如果想要将代码进一步编译成可执行文件 通过 `gcc main.c` 我们发现并不能成功，原因是没有给出 data 数据的定义，而此时我们只需要将两个文件一同进行编译即可：`gcc main.c data.c` 

我们发现代码是可以编译通过的，这就说明 `data `确实是可以在外部文件中被访问的，这时候我们去掉 `data.S `文件中的 `.global` 标识，发现编译却不能通过了，所以 `.global` 是可以实现 函数 和 数据 的全局访问特性的。

**那么我们想要的让一个函数或者一个外部变量只能在一个**`.c文件` **中被访问怎么办呢？提供一个关键字嘛，这个关键字就是** `static`



### 指针

**一个需求**：在函数 A 中的一个变量，想要在调用函数 B 后，由 函数 B 将该值修改后返回，并且函数 B 对该值的修改需要对 函数 A 可见。

如果我们需要多个方法中共享一个数据的操作的话，就需要他们同时有该真实数据的内存地址，所以就需要进行内存地址的传递。

![指针引入.jpg](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921399.jpeg?tximg)

**首先我们需要传递数据的地址，就需要拿到数据的地址，在汇编语言层面，是通过**`lea`指令获取到数据的地址，如：`lea -10(%ESP)`，**而为了可读性和方便，C语言 中将该取地址操作抽象为了**`&`**，类似：**`&a`**标识获取a变量的地址。**

**既然我们拿到了内存地址，那需要用什么去表示当前值是一个内存地址值呢？-----> 在汇编层面呢，是使用了**`()`**来表示括号内的值是内存地址，通过**`(内存地址)`**获取其中的内容，例如：**`mov -8(%EPB) %EAX`**，同样为了方便对**`()`**抽象，成为**`*`**，类似：**`void *p`

**而需要一种类型来接受这个值，也就是指针，但是我们需要知道所指的这块儿内存中存放的数据的宽度，所以就需要借助原有类型来数据宽度，将表示宽度的类型放到** `*` **之前，表示宽度，如：**`int *P`**表示指向一块内存地址，且该内存地址中的数据宽度为 int 的宽度，也就是4字节。**



#### 如何实现的lea指令？？？

**为何这里实现 (*p)++ 是通过 `leal 1(%eax),%edx `?**

通过该行代码的后续操作，可见此次往 edx 存放的内容是最终的运算结果 ----- （`(*p)++`后的结果 2），但是已知`lea`指令是获取地址的行为呀，

猜想1 ： 难道 lea 操作数 等价于 mov 指令？

验证：

1. 更改汇编代码

```plain
incr:
        pushq   %rbp
        movq    %rsp, %rbp
        movq    %rdi, -8(%rbp)
        movq    -8(%rbp), %rax
        movl    (%rax), %eax
        // 更改这个位置
        movl    1(%rax), %edx
        movq    -8(%rbp), %rax
        movl    %edx, (%rax)
        popq    %rbp
        ret
```

1. 编译成功，但是执行报错 ----- 段错误



猜想2：既然我无法解决 leal 指令的问题，那么这个`1(%rax)`是怎么计算的呢？因为 `()`是解引用，也即括号内的值是一个地址，但是此处的 rax 中装入的已经是一个数了，为何要解引用呢，难道  `立即数(数)`表示 这个数 + 立即数 的结果？

验证：

1. 更改汇编代码如下

```plain
incr:
        pushq   %rbp
        movq    %rsp, %rbp
        movq    %rdi, -8(%rbp)
        movq    -8(%rbp), %rax
        movl    (%rax), %eax
        // 更改这个位置
        leal    2, %edx
        movq    -8(%rbp), %rax
        movl    %edx, (%rax)
        popq    %rbp
        ret
```

1. 编译成功，且得到输出结果 2

所以目前可以认为 `leal num,reg`可以将该数存入寄存器中，且`imm(num)`可以表示 num + imm



论据：

 intel 手册中只谈了 lea 指令将地址加载的作用，并不涉及到 lea 一个数

**最终得知这是一个技巧**



### 数组

我们说`int arr[]` 这样一个数组，arr 这个变量表示了 数组其实地址值，那么和指针不就是类似的嘛

假设现在我们有一个数组：

```c
int arr[] = {1，2，3}
```

现在我们想要将 `arr[0] = 10`，那么汇编代码应该怎么写呢？

猜一下：

`mov 9,(arr)` 注意这里的arr是个地 址值

验证：

```plain
        .file   "arr.c"
        .text
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        movl    $1, -16(%rbp)
        movl    $2, -12(%rbp)
        movl    $3, -8(%rbp)
        movl    $9, -16(%rbp)
        popq    %rbp
        ret
```

我们可以看见其实是在  rbp 的基础上 进行定位 数组元素的，其实和指针也相同，通过 `()`来定位元素！



## 2.5 指针的应用



### 指针的应用

上节课我们推理出数组和指针其实是一样的，下层汇编都是通过`()`操作的，都是表示一个地址，而数组只不过是在地址的基础上加上了 索引 来定位各个元素。

```c
#include <stdio.h>

int main(){
    int arr[] = {1,2,3};
	int a=arr[0];
    int b=arr[1];
    int c=arr[2];
}
```



```c
#include <stdio.h>

int main(){
    int arr[] = {1,2,3};
    int *p = &arr[0];
    int a = *P;
    int b = *(p + 1);
    int c = *(p + 2);
}
```

综上，我们发现通过指针其实是可以实现数组的，或者说指针和数组是一种实现方式，只不过数组在使用上更加方便 ----> 所以我们可以理解为  **数组是指针的语法糖**。



### 指针数组

指针数组是什么呢？顾名思异就是一个数组，只不过其中的元素都是指针类型，存放着一个个的地址。[指向首地址]



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921400.jpeg?tximg)

**结论是KV，key是地址，value是值。	**取值就是

这样的话，我们就相当于先基于数组通过 地址获取到指针数组中的指针，然后再通过对获取到的地址进行解引用（汇编通过加`()`，C 语言通过加`*`）拿到数据值。这个过程经过了两个地址的解析，其实就有点类似 **二级指针了，二级指针就是**` **P`**，也就相当于需要做两次解地址操作才能拿到存放的值。**

二级指针的含义。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921401.jpeg?tximg)



> what's the diff of `chat name[4]` and `char *name` ？？
>

### 结构体

结构体其实就是一个整合的数据集，其中可以包含多种类型的数据，如下面的这个结构体

```c
struct Student{
    int age;
    char name[4];
}

int main() {
    struct Student stu = {
        13,"aaa"
    };
    printf("%s", stu.name);
}
```

如果有这样一个结构体，那么在内存中是怎样去存放数据的呢？

**猜想一下：如果是在方法中的话，就会先开辟栈空间，开辟多少靠计算，类似上述代码就是：2 + 4 = 6 字节，但是需要进行内存对齐（cpu规定），所以就应该是开辟 16字节空间**

**那在内存中是怎样去定位不同的内容的呢？很容易想到通过偏移量来定位，比如我想要得到 id 信息，就需要拿到该结构的初始地址，然后偏移到对应的位置即可。**

如果是靠偏移量去做，那不就和数组一样了？只不过是内部数据的类型不统一而已，那我们是否可以拿到一个指针指向初始地址，然后 ++ 遍历获取值呢？其实这是不行的，虽然他类似于数组，但是本质上来说，这并不是数组。（当然如果真的这样操作了，**由于C语言没有进行越界检查**，还是可以执行成功的，只是结果不会是想见的那样）



用一下代码来看看：

```c
#include <stdio.h>

struct Student{
    char name[10];
    int age;
}

int main(){
    struct Student stu = {"steven", 10};
    printf("%s",stu.name);
}
```

通过编译得到如下汇编代码

```c
        .file   "structPointer.c"
        .section        .rodata
main:
        pushq   %rbp
        movq    %rsp, %rbp
        
        // 开辟 16 字节栈空间
        subq    $16, %rsp
        // 填充 char name[] 数组
        movabsq $121382057112691, %rax
        movq    %rax, -16(%rbp)
            // 这里做了填充
        movw    $0, -8(%rbp)
        // 填充 age 属性
        movl    $10, -4(%rbp)
            
            // 属于 printf 函数的东西
        leaq    -16(%rbp), %rax
        movq    %rax, %rsi
        movl    $.LC0, %edi
        movl    $0, %eax
        call    printf
        leave
        ret
```

通过上面的代码，其实我们的猜想已经得以验证。

这里的`movabsq $121382057112691, %rax`代码是用于存放 `stevn`字符串的，那 `steven`为什么表示为 `$121382057112691`，我们就想，这是怎样存放的呢？为什么会是这么一大坨呢？以及指令 `movabsq` 又是什么？

为了简单，将代码改为：

```c
#include <stdio.h>

struct Student{
    char name[10];
    int age;
};

int main(){
    struct Student stu = {"aa", 10};
    printf("%s\n",stu.name);
    printf("%c\n",stu.name[1]);
} 
// 最后输出屏幕  
- aa
- a
```

通过编译得到如下汇编代码

```c
        .file   "demo.c"
        .section        .rodata
.LC0:
        .string "%c\n"
        .text
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        
        subq    $16, %rsp
        movq    $24929, -16(%rbp)
        movw    $0, -8(%rbp)
        movl    $10, -4(%rbp)
        
        leaq    -16(%rbp), %rax
        movq    %rax, %rdi
        call    puts
        
        // 这里是 name[1]，因为 [0] 是 rbp - 16
        movzbl  -15(%rbp), %eax
        movsbl  %al, %eax
        movl    %eax, %esi
        
        
        movl    $.LC0, %edi
        
        
        
        movl    $0, %eax
        call    printf
        leave
        ret
```



先查查指令:

【1】`movzbl` => movz byte to l   使用 0 扩展

Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute

译：即将 操作数 上的内容 放到目标对象上，其实就是将 位数较少的内容放入到位数更多的寄存器中时，空缺部分使用 0 填充



【2】`movsbl` => movs byte to l 

Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The size of the converted value depends on the operand-size attribute.

译：将源操作数中的值放入到 目标寄存器中，并将值进行扩展到 16 or 32 位，转换后的大小依赖于 操作数size 的属性



【3】`movabsq` ：新增指令，用于将一个 64位的值放入到 64位寄存器中



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921402.png?tximg)

可见，在操作 name[1] 时，先将 内存中 `rbp - 15` 的值放入到 EAX 中，再将 AL 单独拿出，进行输出，逆推一下，AL就是存放的 “a”，也就是 `rbp - 15` 位置存放的其实就是“a”。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302030921403.png?tximg)

从上往下分配，每个 byte 对应放入一个 byte 位

**猜测每个byte放入的是 一个 ascii 码，所以最初我们放入的**`$121382057112691`**就是字符串的 ASCII 码拼接的**



验证：只放入一个 字符 ”a“，如果放入的值是 97 那么就证明了我们的猜想

```c
#include <stdio.h>

struct Student{
    char name[10];
    int age;
};

int main(){
    struct Student stu = {"a", 10};
} 
```

编译后得到汇编代码如下：

```asm
        .text
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        movq    $97, -16(%rbp)
        movw    $0, -8(%rbp)
        movl    $10, -4(%rbp)
        popq    %rbp
        ret
```

我们看到其中确实是 填充的 97，所以是 ASCII 码填充的。

如果一个串超过 8 byte，或者计算机的位数，就会分多次进行放入（这里验证信息就不放入了）



### char *

上面的是使用 char[] 数组来表示 字符串的，其实使用 指针也是可以表示字符串的

代码如下：

```c
#include <stdio.h>

struct Student{
    char *name;
    int age;
};

int main(){
    struct Student stu = {"abcdef", 10};
    printf("%s\n", stu.name);
} 
```

编译后得到汇编代码如下：

```c
        .file   "demo.c"
        .section        .rodata
.LC0:
        .string "abcdef"
        .text
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        subq    $16, %rsp
        movq    $.LC0, -16(%rbp)
        movl    $10, -8(%rbp)
        movq    -16(%rbp), %rax
        movq    %rax, %rdi
        call    puts
        leave
        ret
```

我们发现，字符串数据居然跑到 `.rodata` 中了，而对应的数据中只是存放了该数据的地址，所以**当我们使用 char \* 做类型的话，字符串就会 保存在 rodata 中**



**现在我们已经将 C 语言的核心之一 指针解决了，于是我们现在应该去了解不同文件之间的整合过程，以及生成的执行文件的格式**



### Redis 源码

target：练习 C 语言

#### Redis入口

```c
int main(int argc, char **argv) {
    // .... 
    if (argc >= 2) {
         // .....
        if (strcmp(argv[1], "-v") == 0 ||
            strcmp(argv[1], "--version") == 0) version();
       // ....
}
```

**argc   argv**

因为我们在命令行中输入的参数是不确定的，就类似于Java 中通过命令行传参数一样，在 C 语言中同样也是有这种操作的，通过 argc 记录参数的数量，然后使用一个二级指针 argv 来指向参数的首地址

我们想呀，参数是不确定，都是字符串，而且可能有多个，所以是需要使用一个数组来保存，而且参数分布的位置也是不确定的，那么数组中的存放的内容就应该是地址信息， 由此使用二级指针来存放

![img](C:/Doc/typora_pic/202210191807646.jpeg)

此外，我们看见在源码中，访问argv中的数据值时，是通过二维数组来访问的，argv[][] 相当于 俩个 ()，正好解两次引用，所以也正好印证了之前所言 -----  数组是指针的语法糖 



#### 动态伸缩字符串

```c
typedef char *sds;
struct sdshdr {
    unsigned int len;
    unsigned int free;
    char buf[];
};

static inline size_t sdslen(const sds s) {
    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
    return sh->len;
}
```





**typedef**

这里的`typedef`相当于定义别名，这里的意思是，之后的 `char * `以后就可以直接用 `sds `替代了 

**void \*** 

`void *`表示这个指针是没有实际类型，之后可以进行任何类型的强转，所以说 `void *`称之为**万能指针**

![image.png](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653622292268-f5786f1d-7bfa-467e-8b8d-9b28c6c97b13.png?tximg)

我们看这个结构体中，**buf是一个没有声明长度的数组，这是 无长度类型数组，是一个扩展点。** 

sdslen 该方法用于获取字符串的长度，这里是一个取巧点，我们已知 sds 也就是 buf 的指针，想要获取到

sds结构体的起始地址

![image.png](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653624653538-51c91dd2-8395-4605-aef5-e2eff71f53b8.png?tximg)

已知 sds 指针，想要得到结构体的初始地址，起始只需要是使用 sds的地址 减去 sdshdr 结构体的大小即可。注意这里的 sizeof(struct sdshdr) 其实是没有算入 buf 的，由于buf是变长数组，所以最初未分配时，buf 并不占用空间，所以 sizeof() 计算出的数其实只是 len  和 free 的大小，此时指针的值 减去这个值正好可以得到 其实地址

除此外，内核中也有类似的操作：

```c
container_of(ptr, type, member) (
    {                      
        const typeof( ((type *)0)->member ) *__mptr = (ptr);    
        (type *)( (char *)__mptr - offsetof(type,member) );
    }
)

offsetof(t, m)	((size_t) (&((t *)0)->m))
```









## 2.6 **C sizeof、strlen应用设计**



复习指针



C语言的一切操作都是操作内存，所以我们在研究 C语言底层时，需要从内存角度 和 intel 开发手册 入手

### sizeof

**在编译为汇编代码的过程中就计算好了**。

```c
#include <stdio.h>

int main(){
    int a = 1;
    printf("%d\n", sizeof(a++));
    printf("%d\n", a);
}
```



编译运行后输出：

```shell
[root@origin demo]# ./a.out
4
1
```



所以我们可以猜测，sizeof 并没有运行，而是直接在编译的过程中，由编译器直接计算并替换掉了，于是我们可以看汇编代码得到答案

```c
        // 关键代码
        movl    $4, %esi
        movl    $.LC0, %edi
        movl    $0, %eax
        call    printf
```



从上面的汇编代码可以看出，sizeof 是按立即数给到汇编代码中的。所以是在编译过程中就计算好了



### 手写一个 sizeof

比如我们为了获取 int 类型的 sizeof 值，我们可以像如下的操作一样

```c
int main(){
    int a = 0;
    // 由于我的是 64bit 机器， 所以使用 long 来存放地址
    long begin = &a;
    long end = (&a) + 1;
    // 两者相减就可以得到正确的 sizeof 值
    int size = end - begin;
}
```

注意上面的代码中，我们由于是使用的 64位机，所以选择了 long 类型来存储地址值，那如果是32位呢？是不是又得改代码，于是 我们将有关位数的信息提取出来作为一个参数，将 long 替换掉，这样就有了 可移植性。 —— `size_t`



### 求任意类型的 sizeof

此处以整型为例

```c
int main(){
    int size = (((int *) 0 ) + 1);
    return size;
}
```

注意：这里先将 0 地址转为 int 类型的指针，然后 + 1 表示加一个 int 类型的大小，自然得到的 偏移量就是 所求类型的 sizeof。

### 可变长数组的分配

可变长数组如果分配了长度那么就会存在该变量，否则变量不仅没有分配空间，而且会是无效参数



size_t

32位机 long = int

### strlen

都是编译器直接算出的

```c
#include <stdio.h>

int main(){
    printf("%d\n", sizeof("hello"));  // 输出  6
    printf("%d\n", strlen("hello"));  // 输出  5
}
```

为何 sizeof 会比 strlen 多 1 呢？

我们想一下一个字符串在内存中是怎么存放的呢？肯定是连续挨着存放的，那么计算机怎么知道你这个字符串结束了呢？所以需要在字符串末尾放入一个 标识符 `\0`

论证：

```c
#include <stdio.h>
#include <string.h>
struct sdshdr {
    char *name;
};

int main(){
    struct sdshdr s = {"steven"};
    char *p = s.name;
    // 这两行 输出一样， 都为 0
    printf("%d\n",*(p + 6));
    printf("%d\n", '\0');
    
    printf("%d\n", sizeof("hello"));
    printf("%d\n", strlen("hello"));
}
```

并且在redis中，新创建一个字符串的代码都会在 末尾填充 ‘\0’

```c
sds sdsnewlen(const void *init, size_t initlen) {
    struct sdshdr *sh;

    if (init) {
        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
    } else {
        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
    }
    if (sh == NULL) return NULL;
    sh->len = initlen;
    sh->free = 0;
    if (initlen && init)
        memcpy(sh->buf, init, initlen);
    
    // 填充 ‘\0’
    sh->buf[initlen] = '\0';
    
    
    return (char*)sh->buf;
}
```



那么一切就说得通了，sizeof将 末尾的  ‘\0’ 算进长度中并结束，不过我们一想本来就应该加上，因为sizeof是表示该内容在内存中占用了多少 byte，那么多出来的结尾标识符其实也应该算入内存占用内。

而strlen则只是关心这个字符串本身的长度是多大了，所以不必加上 '\0' 。



**假如字符串中恶意添加了**`'\0'`**呢？**

```c
#include <stdio.h>
#include <string.h>

int main(){
    printf("%s\n","hel\0lo");    // 输出 hel
    printf("%d\n", sizeof("hel\0lo")); // 输出  7
    printf("%d\n", strlen("hel\0lo")); // 输出  3 
}

// 汇编代码
        .file   "demo.c"
        .section        .rodata
.LC0:
        .string "hel"
        .string "lo"
.LC1:
        .string "%d\n"
        .text
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        movl    $.LC0, %edi
        call    puts
        movl    $7, %esi
        movl    $.LC1, %edi
        movl    $0, %eax
        call    printf
        movl    $3, %esi
        movl    $.LC1, %edi
        movl    $0, %eax
        call    printf
        popq    %rbp
        ret
```



通过这个，实例可以可以看出 系统会认为 \0 是字符串结尾，于是在输出 以及 计算长度 的时候就会到 '\0' 结束掉，而 sizeof 仍旧不变.





### static 修饰局部变量

```c
#include <stdio.h>

int sum(){
    static int data = 1;
    return data;
}

int main(){
    sum();
    return 1;
}
```

编译后得到汇编代码如下

```c
        .file   "demo.c"
        .text
        .globl  sum
        .type   sum, @function
sum:
        pushq   %rbp
        movq    %rsp, %rbp
        // 分配空间
        movl    data.2178(%rip), %eax
        popq    %rbp
        ret
        .size   sum, .-sum
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        movl    $0, %eax
        call    sum
        movl    $1, %eax
        popq    %rbp
        ret
        .size   main, .-main
        
        // 对应
        .data
        .align 4
        .type   data.2178, @object
        .size   data.2178, 4
data.2178:
        .long   1
        .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
        .section        .note.GNU-stack,"",@progbits
```



可见，当使用 static 修饰局部变量时，局部变量会分配到 `.data`段中，所以当离开方法时，该变量时不会不清除的，且第二次进入也不会再次进行分配。



### GAS文档

我们需要验证之前的那些汇编代码的理解是否是正确的，就需要寻求论据，汇编语言是面向汇编器来编写的，所以想要研究汇编语言就去看汇编器文档是怎么规定的 ----- 《GAS》





## 2.7 程序执行过程



任何官方的手册、源码、书籍 都只是用来查字典的

![程序历程.jpg](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653652004409-24b1cf84-857e-42e9-bc4f-45b2efc56f63.jpeg?tximg)

### 返回值是复杂类型怎么返回

之前我们说返回值通过 eax 来进行保存，如果我们需要返回的内容是一个复杂的类型呢？比如结构体，字符串，数组...... 还是通过 eax 来返回嘛？其实是不可以的（在不开启优化的情况下），EAX 是无法表示复杂类型的。

可能会有疑问，我是否可以使用 RAX 来保存返回数据的内存地址呀，然后返回内存地址呢？其实不可的，你想一下我们的方法内的数据是分配在栈帧中的，如果我们返回的是栈帧中的地址的话，在离开方法返回时，ESP 会回退，那么返回的地址值就不可用了



观察一段代码

```c
#include <stdio.h>
struct student{
    int age;
    char *name;
    int id[10];
};

struct student func(){
    struct student s = {10,"steven",{1,2,3,4}};
    return s;
}

int main(){
    struct student stu = func();
    return 0;
};
```

经过编译得到汇编代码如下：

```c
        .file   "demo.c"
        .section        .rodata
.LC0:
        .string "steven"
        .text
        .globl  func
        .type   func, @function
func:
        pushq   %rbp
        movq    %rsp, %rbp
        
        // 将地址值存放好
        movq    %rdi, -72(%rbp)
        leaq    -64(%rbp), %rsi
        movl    $0, %eax
        movl    $7, %edx
        // 当前栈帧中存放 对象的 开辟的内存地址
        movq    %rsi, %rdi
        movq    %rdx, %rcx
        rep stosq
        movl    $10, -64(%rbp)
        movq    $.LC0, -56(%rbp)
        movl    $1, -48(%rbp)
        movl    $2, -44(%rbp)
        movl    $3, -40(%rbp)
        movl    $4, -36(%rbp)
            
        // 将 main 栈帧中开辟的内存的内存地址放入 rax
        movq    -72(%rbp), %rax
        
        // 开始搬云值
        movq    -64(%rbp), %rdx
        movq    %rdx, (%rax)
        // …… 相同操作
        movq    -56(%rbp), %rdx
        movq    %rdx, 8(%rax)
        movq    -48(%rbp), %rdx
        movq    %rdx, 16(%rax)
        movq    -40(%rbp), %rdx
        movq    %rdx, 24(%rax)
        movq    -32(%rbp), %rdx
        movq    %rdx, 32(%rax)
        movq    -24(%rbp), %rdx
        movq    %rdx, 40(%rax)
        movq    -16(%rbp), %rdx
        movq    %rdx, 48(%rax)
        movq    -72(%rbp), %rax
        popq    %rbp
        ret
        .size   func, .-func
        
        
        
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        subq    $64, %rsp
        
        // 将 开辟的用来存放返回值的内存地址通过放入 rax
        leaq    -64(%rbp), %rax
        // 将地址放入 rdi
        movq    %rax, %rdi
        movl    $0, %eax
        call    func
        movl    $0, %eax
        leave
        ret
```

我们将结构体中的元素放少，如下：

```c
#include <stdio.h>
struct student{
    int age;
    char *name;
};

struct student func(){
    struct student s = {10,"steven"};
    return s;
}

int main(){
    struct student stu = func();
    return 0;
};
```

汇编代码如下

```c
        .file   "demo.c"
        .section        .rodata
.LC0:
        .string "steven"
        .text
        .globl  func
        .type   func, @function
func:
        pushq   %rbp
        movq    %rsp, %rbp
        pushq   %rbx
        // 存放当前栈帧数据
        movl    $10, -24(%rbp)
        movq    $.LC0, -16(%rbp)
            
        // 将刚放入当前栈帧中的值 放入 rax， rdx
        movq    -24(%rbp), %rax
        movq    -16(%rbp), %rdx
        // 将 rax 和 rdx 转移到  rcx，rbx
        movq    %rax, %rcx
        movq    %rdx, %rbx
        // 再次转移到 eax
        movl    %ecx, %eax

        popq    %rbx
        
        popq    %rbp
        ret
        .size   func, .-func
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        subq    $16, %rsp
        movl    $0, %eax
        call    func
        // 取值放入寄存器
        movl    %eax, %ecx
        movq    %rdx, %rax
        // 将值 放入栈帧中对应位置
        movl    %ecx, -16(%rbp)
        movq    %rax, -8(%rbp)
        movl    $0, %eax
        leave
        ret
```

**后续通过验证得知，如果结构体中的内容可以通过两个寄存器组合表示，那么就会使用 寄存器来返回值，否则会使用 栈帧复制的方法**



当不知道从什么地方入手的时候，就从操作内存的角度来思考



### 函数库

回到最初的函数

```c
#include <stdio.h>

int main(){
    printf("%s", "hello world");
    return 1;
}
```

重新审视这段代码，将之前的知识串联起来，就是 main 函数 封装了汇编指令片段，以及调用的过程（栈帧开辟，回退，传参，返回结果处理）

**现在还有俩个问题：**

1. `#include` 是啥？
2. `printf` 是啥？



通过现有知识我们可以知道，printf 是在显示器上显示内容，而操作显示器属于是操作硬件，所以这需要操作系统来进行调用，调用就和调用方法一样，将 函数入参放入指定的寄存器 或 栈 中，然后跳转到代码执行

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1653708510735-342fca5e-79ea-44df-a054-ca687d75406f.jpeg)

在跳转执行的过程中，由于应用程序特权级在 3，而操作系统特权级在 0，所以在调用过程中肯定出现了特权级的切换



由于系统调用的约定较为复杂，且操作系统多种多样，所以为了能保证 C 语言具有可移植性，那么肯定有东西包装了系统调用的过程，提供接口给应用程序使用，所以C 语言提供了一个代码包，提供了这些封装了的代码。称之为 **库函数（运行时库）** (C run-time library)，在 Java 中叫 JRE，而 C 语言中 叫 CRT

由于同一个内容、接口可以有不同标准的实现，所以在 C 语言的 库函数有两个：

1.  ansi c 标准 ： Lib c
2.  gun c 标准 ： G Lib c



当然编写代码时我们可以不使用库函数的代码，自己编写，所以在应用程序执行中，有如下关系：

![运行时库.jpg](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1653709770855-5940fbda-e25b-4723-bee5-1cc014c1066e.jpeg?tximg)





### #include

相当于其他语言的 import，为何要导入呢？因为编译器需要知道有该内容，

```c
int main(){
    fun_c();
    return 0;
};
```

单独对这个代码进行 `gcc -c` 也是可以编译通过的

而对于以下代码：

```c
extern void fun_c(int a, int b);

int main(){
    fun_c(1,2,3,4);
    return 0;
};
```

`gcc -S`，直接报错：传递实参过多，所以 extern 可以让我们代码中关于函数的调用即对外部定义的内容的访问在编译期间进行检查。

但是我们在写代码过程中，不可能将这些定义信息全部放入到一个文件中，这样就很乱，所以我们将其抽出一个文件来存放这些定义信息，即 `.h 头文件`

然后通过 #include 导入。



# 第五章 ELF

## 2.8 静态链接



### 回顾

大佬提出标准，后面的来实现，并且扩充自己的功能。

在 上一节，我们说函数的声明放在头文件中，通过 `#include` 导入，里面都是一些 `extern`。

`include`其实是一个宏，在编译之前会对宏进行处理，所以说程序的历程中由多了一个流程，叫**预处理。**





#### typedef

**头文件内容**

**类型系统** typedef 定义别名



### extern补充 （宏处理）



```shell
gcc --h
用法：gcc [选项] 文件...
  ……
  -E                       仅作预处理，不进行编译、汇编和链接
  -S                       编译到汇编语言，不进行汇编和链接
  -c                       编译、汇编到目标代码，不进行链接
  -o <文件>                 输出到 <文件>
  ……

【例子】：
	C语言编译过程：预处理	编译	汇编	链接
	gcc -E demo.c -o demo.i
	gcc -S demo.i -o demo.s
	gcc -c demo.s -o demo.o
	gcc -c demo.o -o demo_elf
```

从gcc的命令行帮助中我们也可以看到，程序编译运行的几个阶段

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1653716423324-23efbc38-8ac5-4f89-bd05-4bf2e2e22561.jpeg)



而这一套历程都是属于 GNU 套件内的内容。除此之外，程序在每个阶段都是有理可依的，各个阶段都是有文档依据的。



### GAS文档

从前面的程序历程图我们可以看出，一个 .c 文件 在输入编译器后会产生一个 .s 的汇编文件，该汇编文件后续需要作为 汇编器的输入，所以说 **.s 的汇编文件是按照汇编器所定义的规则编写的，也就是说 汇编代码是面向 汇编器编写的**。那么我们需要研究这个汇编语言的格式就需要去查看 汇编器的文档了 —— 《GAS》

#### .section

> Use the .section directive to assemble the following code into a section named name. 
>
> This directive is only supported for targets that actually support arbitrarily named sections；
> on a.out targets, for example, it is not accepted, even with a standard a.out section name.
>
> 【译】.section 指令
> 使用 .section 指令 将其下面 代码放入一个 集合，这个集合叫做name。
> 这个 .section 指令 仅适用于支持随意命名的目标节。
> 例如，不接受 a.out 目标上的节，即使使用标准的 a.out 节名称。

https://sourceware.org/binutils/docs/as/Section.html

```she
If the optional argument is quoted, it is taken as flags to use for the section. Each flag is a single character. The following flags are recognized:
	bss section (uninitialized data)
	read-only section
	executable section
```

 

#### ELF

代码最终要变成二进制的 01 才能够在计算机上运行，所以程序经过编译得到的汇编代码还需要经过一次转换，按照 ISA指令集的约束 转换 为机器码。

而现目前我们了解到的`.i` , `.s`文件都是字符串文件，这种文件只要按照 ASSCI 或者指定的编码集放入磁盘即可，而我们要执行的文件是二进制的，只要是二进制文件就一定有格式。

**该文件是由 汇编器生成的，所以文件的格式跟汇编器有关，而汇编器又分为两大平台的 Unix 和 Windows，其中 windows 的文件为** `**.exe**`  **或者** `**.dll**`**，而 Unix 即是** `**.o**`**，**`**.so**`**，**`**.out**`**，而 GAS 使用 ELF 作为输出文件的格式**

怎么验证呢？

通过命令：`readelf -a` 查看文件信息即可，如果不是 elf 文件则会报错

```shell
readelf -a demo_elf
```

在 《GAS》文档中，



#### Output (Object) File

```shell
Every time you run `as `it produces an output file, which is your assembly language program translated into numbers. This file is the object file. Its default name is a.out, or b.out when `as `is configured for the Intel 80960. You can give it another name by using the -o option. Conventionally, object file names end with ‘.o’. The default name is used for historical reasons: older assemblers were capable of assembling self-contained programs directly into a runnable program. (For some formats, this isn’t currently possible, but it can be done for the a.out format.) 
```

每次通过 `as` 会产生一个文件，是一个通过汇编语言程序转换成的二进制文件。这称为目标文件。其默认名字是 `a.out`，或者`b.out`。当然也可以通过 `-o`重命名。因此，目标文件名字以 `.o`结尾。这个默认名字有一个历史原因，老的汇编器 可以将独立的程序直接组装到一个可运行的程序中。

The object file is meant for input to the linker ld. It contains assembled program 	code, information to help ld integrate the assembled program into a runnable file, and (optionally) symbolic information for the debugger.

目标文件是为了作为链接器的输入。他**包含了可以被组装的程序代码（机器码） 和 链接器 整合 程序代码到一个可执行文件的信息，以及 （可选的）针对调试器的符号信息** 

我们来看下面这个代码的编译流程：

```c
int main(){
    func(1,2,3,4);
    return 0;
};
```

我们对该代码执行 `gcc -c` 让其经历 预处理、编译、汇编 三个过程，执行通过！证明在这三个环节只是将 程序代码转换为 `.o`的二进制文件。





------

### 静态链接

我们在写代码时，不可能全部写到一个文件中，而是分布到不同的文件中，那不同文件中的函数需要相互调用怎么办呢？

我们调用函数时，都是通过 `call + 指令地址`来实现的。

```c
int main(){
    func(1,2,3,4);
    return 0;
};
```

我们将该代码进行编译：得到如下汇编代码

```shell
        .file   "demo.c"
        .text
        .globl  main
        .type   main, @function
main:
        pushq   %rbp
        movq    %rsp, %rbp
        movl    $4, %ecx
        movl    $3, %edx
        movl    $2, %esi
        movl    $1, %edi
        movl    $0, %eax
        // -------------------
        // -------------------
        call    func
        movl    $0, %eax
        popq    %rbp
        ret
```

我们发现这里的 `call` 指令只是放入了一个方法名 `func`，只是一个字符串，而并不是一个地址.

而我们要通过 `as`得到符合 ISA 指令集的二进制机器码，即 需要转换为` call 0x000000（地址值）` ==》 但是我们没有外部函数和数据的地址 ==》 那怎么办呢？我们只能先随意放一个值将位置给占住，如：`call 0x00000` 

但是最终还是需要将真实地址进行装上的，那怎么装呢？我们肯定要记录需要替换的位置地址，所以我们肯定需要一张表来记录需要做真实地址替换的位置，key --- value 

**我们称这种需要替换真实地址的 这些字符串 称为 符号，将符号对应的地址更改为正确的地址称之为 符号解析**

------

**验证：**

将其编译汇编为 .o 文件，然后我们可以通过 `objdump -d`命令来将文件反汇编得到如下：

```shell
[root@origin demo]# objdump -d demo.o

demo.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   b9 04 00 00 00          mov    $0x4,%ecx
   9:   ba 03 00 00 00          mov    $0x3,%edx
   e:   be 02 00 00 00          mov    $0x2,%esi
  13:   bf 01 00 00 00          mov    $0x1,%edi
  18:   b8 00 00 00 00          mov    $0x0,%eax
  1d:   e8 00 00 00 00          callq  22 <main+0x22>
  22:   b8 00 00 00 00          mov    $0x0,%eax
  27:   5d                      pop    %rbp
  28:   c3                      retq   
```

`  1d:   e8 00 00 00 00          callq  22 <main+0x22>` 通过这行代码我们可以看到这里是将call 的地址设置为了全 0。



我们找找是否有一个表，通过`readelf`命令的帮助中，我们看到有一个参数选项 `readelf -a`，输入看以下：

```shell
[root@origin demo]# readelf -a demo.o

// ..... 

重定位节 '.rela.text' 位于偏移量 0x1d8 含有 1 个条目：
  偏移量          信息           类型           符号值        符号名称 + 加数
00000000001e  000900000002 R_X86_64_PC32     0000000000000000 func - 4

// ..... 
Symbol table '.symtab' contains 10 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS demo.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     8: 0000000000000000    41 FUNC    GLOBAL DEFAULT    1 main
     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND func
```

从表项中，我们确实找到了一个 `func` 的条目，并且该条目的类型还是 范围 还是 `global` 的

#### 关于符号表的描述

An object file's symbol table holds information needed to locate and relocate a program's symbolic definitions and references. A symbol table index is a subscript into this array. Index 0 both designates the first entry in the table and serves as the undefined symbol index. The contents of the initial entry are specified later in this section.

译：一个对象文件的符号表保存了需要 定位 和 重定位 的 符号定义 以及 符号引用 的 信息。

索引 0 即指定了 表的第一项 以及 未定义的符号下标





------



**所以我们需要链接器，来将多个文件组装起来，为程序分配内存地址，以此来让程序能找到外部文件中定义的数据和函数的地址。 ———— 此过程叫 重定位**

**通过查找与** `rela.text` **中的条目匹配的地址，填入到程序中对应的地址处，即可达到程序的正常运行。 —— 此过程叫 符号解析**



所以链接器的作用就是：符号解析 + 重定位

![image-20230202151442457](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302021514378.png?tximg)



**验证：**

我们再定义一个 func.c 文件

```c
void func(int a, int b, int c, int d){
    int e = a + b + c + d;
}
```

然后执行命令 ： `gcc demo.c func.c` 编译 + 汇编 + 链接 都成功，生成一个 可以执行程序 `./a.out`

对文件 `a.out` 进行反汇编，得到如下信息：

```shell
[root@origin demo]# objdump -d a.out 

a.out：     文件格式 elf64-x86-64


Disassembly of section .init:

00000000004004ed <main>:
  4004ed:       55                      push   %rbp
  4004ee:       48 89 e5                mov    %rsp,%rbp
  4004f1:       b9 04 00 00 00          mov    $0x4,%ecx
  4004f6:       ba 03 00 00 00          mov    $0x3,%edx
  4004fb:       be 02 00 00 00          mov    $0x2,%esi
  400500:       bf 01 00 00 00          mov    $0x1,%edi
  400505:       b8 00 00 00 00          mov    $0x0,%eax
  40050a:       e8 07 00 00 00          callq  400516 <func>
  40050f:       b8 00 00 00 00          mov    $0x0,%eax
  400514:       5d                      pop    %rbp
  400515:       c3                      retq   

0000000000400516 <func>:
  400516:       55                      push   %rbp
  400517:       48 89 e5                mov    %rsp,%rbp
  40051a:       89 7d ec                mov    %edi,-0x14(%rbp)
  40051d:       89 75 e8                mov    %esi,-0x18(%rbp)
  400520:       89 55 e4                mov    %edx,-0x1c(%rbp)
  400523:       89 4d e0                mov    %ecx,-0x20(%rbp)
  400526:       8b 45 e8                mov    -0x18(%rbp),%eax
  400529:       8b 55 ec                mov    -0x14(%rbp),%edx
  40052c:       01 c2                   add    %eax,%edx
  40052e:       8b 45 e4                mov    -0x1c(%rbp),%eax
  400531:       01 c2                   add    %eax,%edx
  400533:       8b 45 e0                mov    -0x20(%rbp),%eax
  400536:       01 d0                   add    %edx,%eax
  400538:       89 45 fc                mov    %eax,-0x4(%rbp)
  40053b:       5d                      pop    %rbp
  40053c:       c3                      retq   
  40053d:       0f 1f 00                nopl   (%rax)
```

我们发现，两个函数被放入了同一个文件中，并且其地址也改变了，这就是 重定位，

并且其中调用的 call 指令的操作数，也变成了真实的地址，这就是 符号解析



如上过程就是 静态链接的过程，静态链接就是 GCC 将需要的目标文件拷贝到一个可执行文件中，并对符号进行解析，以及 内存重定位 的过程



## 2.9 静态链接与动态链接

### 静态链接补充

从C到编译，再到链接，每一个细节都清晰。从java来看，lombok注解annotationProcess在编译期间加上getset（这个就类似于C语言的预处理过程）、JVM就是做好了重定位和符号解析。

**C 语言的核心：指针、类型系统、静态链接 和 动态链接**



程序从编译到最后运行一共经历了以下几个步骤：预处理、编译、汇编、链接

在汇编阶段，由于输出一套符合 ISA 指令架构的二进制文件，但是又不知道程序中某些数据或者函数的地址，于是采用全零来占住指令的操作数，并将假地址转换为真实地址的操作交给下一个步骤来处理 （链接），为了让链接器知道哪些地方的地址需要替换，于是就采用一张可重定位表（`重定位节 '.rela.text'`）来记录需要重定位的符号。每个 `.o`文件为了方便其他文件进行查找，也需要创建一个符号表（`符号表 symtab`）包含用来定位和重定位程序中的符号。

这样在链接时，就会在将程序 `.o` 文件重定位后，更改符号表，将内存地址给更改成正确的地址，然后通过查找符号表项将 `rela` 可重定位的符号根据偏移把假地址替换为真实地址。



看节头部信息：

注意两个点：.symtab ， .strtab 	

分别表示什么？ 有什么好处？



**符号表有没有必要存在呢？**

肯定是需要存在的，除非外部文件不存在对该文件的依赖，否则就需要一个符号表来帮助定位符号，如果没有的话，就会导致链接失败！

验证：使用`strip`命令 可以去掉符号信息

去`.o`文件的符号表后，我们执行 `gcc` 命令时则会报错。



**静态链接的符号可以有几种**

通过观察，我们可以将符号分为两类：内部符号、外部符号

在当前文件外部的称为外部符号，在当前文件内部的称为 内部符号。



#### 优缺点

**优点**：静态链接是将所需的内容全部打包到一个文件中，这样的话程序执行时所需要的内容都在本地了，不需要进行其他链接操作，所以执行速度会比较快。（**代码冗余**）

**缺点**：代码冗余，静态链接库发生变化就需要将使用到这个静态链接库的所有程序都再编译一遍。



如果多个程序共同调用了一个文件中的代码呢？

这就需要对该文件拷贝两份到两个应用程序中，非常占用内存

![image-20230206001823825](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302060018885.png?tximg)

除此之外，如果共享库中的代码有更改，那么**所有链接该代码的程序都需要重新编译**。

于是就有了将共享库抽离出来，在内存中只存在一份，然后共同使用的需求，这就是后续发展出的动态链接



### 动态链接

#### 是什么？

![物理内存的映射](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302060021207.png?tximg)



#### 前提：虚拟地址

虚拟地址就是让每个程序都认为自己和 OS 占用了整个内存，真实地址通过 段选择子 + 虚拟地址 进行映射，这样就可以让应用程序之间互不干扰，也不用对内存进行划分，规定某一块放入什么，这样程序装入内存就更加灵活了，各个程序都可以有任意的排布。

基于虚拟地址，我们可以将共享库放一份到真实内存上，然后各个程序中保存一个对共享库的映射：

![物理内存的映射](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302052230236.png?tximg)

#### 关键

共享库可以将代码中的地址写死嘛？？即是否地址无关的？

假设说共享库中的地址写死了，比如共享库中有一个 `call fun`，如果地址写死的话，地址就是在真实内存中的实际地址，我们假设是在 `0x5454`，而在程序 B 中，映射到的地址却是在  `0x3456`，此时如果调用 `call fun` 的话，就会是`0x5454`这个写死的内存地址，但是对于程序 B的虚拟 内存而言，该地址上就不会是对应的fun 函数地址了。所以需要使用 相对地址来玩。

**所以在共享库中，应该是地址无关的，对于私有数据和函数使用内存偏移量来定位函数和数据，而对于共享数据和函数来说，则是通过 call plt 来实现**



### 如何生成动态链接库？

动态链接库文件后缀名 `.so`

通过如下命令生成一个动态链接库

```shell
gcc -shared -o libfunc.so func.c 
```



在进行程序文件编译时，也是需要指明链接的库的，不然即使是动态链接库链接器也无法知道需要链接谁！

```shell
gcc demo.c libfunc.so
```



这样便将程序编译好了，那是否可以直接运行呢？答案是不行的，因为动态链接库还没有装载到内存中，我们需要设置环境变量，让动态链接器能找到 需要的动态链接库，使用以下命令将当前路径加入到环境变量中。

```shell
export LD_LIBRARY_PATH=.:$LD_LIBARAY_PATH
```



### 如何从文件的调用跳转到库的函数里

#### 1、代码材料

```shell
[root@localhost demo0205]# vim test.c
[root@localhost demo0205]# vim libfunc.c 
[root@localhost demo0205]# ls
libfunc.c

[root@localhost demo0205]# cat libfunc.c 
```

`libfunc.c`

```c
int data = 0;

int sum3(int a, int b, int c){
    return sum2(a, b) + c + data;
}

int sum2(int a, int b){
    return a + b;
}
```

`test.c`

```c
#include<stdio.h>

void main() {
  int ret = sum3(1,2,3);
  printf("%d", ret);
  return;
}
```



#### 2、编译动态链接库

> 加上FIPC的作用是：可以連接所有的代码库，将全局符号弄到GOT、PLT中
>
> 地址有关代码：在静态链接的时候，将静态代码的地址直接加到代码中
>
> 地址无关代码：使用GOT和PLT做动态地址转换 

```shell
[root@localhost demo0205]# gcc -shared -o libfunc.so libfunc.c
/usr/bin/ld: /tmp/ccTfEhqS.o: relocation R_X86_64_PC32 against symbol `sum2' can not be used when making a shared object; recompile with -fPIC
/usr/bin/ld: 最后的链结失败: 错误的值
collect2: 错误：ld 返回 1

# 因为默认编写的代码编译成可执行代码时是使用的绝对地址定位的，所以不符合动态链接库的规则，而是需要添加参数 `-fPIC`让编译的程序库地址无关。

[root@localhost demo0205]# gcc -fPIC -shared -o libfunc.so libfunc.c
gcc: 错误：libfunc.so：没有那个文件或目录
[root@localhost demo0205]# export LD_LIBRARY_PATH=.:$LD_LIBARAY_PATH

[root@localhost demo0205]# gcc -fPIC -shared -o libfunc.so libfunc.c
[root@localhost demo0205]# gcc test.c
/tmp/ccLLGpb4.o：在函数‘main’中：
test.c:(.text+0x19)：对‘sum3’未定义的引用
collect2: 错误：ld 返回 1
[root@localhost demo0205]# gcc test.c libfunc.so
test.c: 在函数‘main’中:
test.c:3:3: 警告：隐式声明与内建函数‘printf’不兼容 [默认启用]
   printf("%d", ret);
   ^
[root@localhost demo0205]# vim test.c

[root@localhost demo0205]# gcc test.c libfunc.so
[root@localhost demo0205]# ./a.out
6[root@localhost demo0205]#
```



#### 3、验证结果

##### 查看地址信息

```shell
[root@localhost demo0205]# objdump -d a.out

a.out：     文件格式 elf64-x86-64

# 我们发现这里的 `call sum3`变成了 `call<sum3@plt>` 这里的 400520 地址处是如下 代码
0000000000400520 <sum3@plt>:
  400520:	ff 25 fa 0a 20 00    	jmpq   *0x200afa(%rip)        # 601020 <sum3>
  400526:	68 01 00 00 00       	pushq  $0x1
  40052b:	e9 d0 ff ff ff       	jmpq   400500 <.plt>

# 注意看，这里sum3又变成了 call plt 了
000000000040063d <main>:
  40063d:	55                   	push   %rbp
  40063e:	48 89 e5             	mov    %rsp,%rbp
  400641:	48 83 ec 10          	sub    $0x10,%rsp
  400645:	ba 03 00 00 00       	mov    $0x3,%edx
  40064a:	be 02 00 00 00       	mov    $0x2,%esi
  40064f:	bf 01 00 00 00       	mov    $0x1,%edi
  400654:	b8 00 00 00 00       	mov    $0x0,%eax
  400659:	e8 c2 fe ff ff       	callq  400520 <sum3@plt>
  40065e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  400661:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400664:	89 c6                	mov    %eax,%esi
  400666:	bf 10 07 40 00       	mov    $0x400710,%edi
  40066b:	b8 00 00 00 00       	mov    $0x0,%eax
  400670:	e8 9b fe ff ff       	callq  400510 <printf@plt>
  400675:	90                   	nop
  400676:	c9                   	leaveq 
  400677:	c3                   	retq   
  400678:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40067f:	00 
```

##### 查看节信息

###### 程序节信息：`a.out`

```shell
[root@localhost demo0205]# readelf -a a.out 
ELF 头：
  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类型:                              EXEC (可执行文件)
  入口点地址：              0x400550
  程序头起点：              64 (bytes into file)
  Start of section headers:          6472 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         9
  节头大小：         64 (字节)
  节头数量：         30
  字符串表索引节头： 29
  
# 程序的头部上，多了这么一句话：[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
# 请求程序链接器，这里我们可以猜测以下，当将该程序读取到内存中时，发现该行数据，会根据地址去加载链接器进行动态连接工作

程序头：
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
//...LOAD        0x0000000000000000 0x0000000000400000 0x0000000000400000

# 发现多了一个节，`.dynsym`动态链接符号，表示程序中需要动态链接的符号。

Symbol table '.dynsym' contains 10 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (2)
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND sum3
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 000000000060103c     0 NOTYPE  GLOBAL DEFAULT   24 _edata
     6: 0000000000601040     0 NOTYPE  GLOBAL DEFAULT   25 _end
     7: 000000000060103c     0 NOTYPE  GLOBAL DEFAULT   25 __bss_start
     8: 00000000004004e0     0 FUNC    GLOBAL DEFAULT   11 _init
     9: 00000000004006f4     0 FUNC    GLOBAL DEFAULT   14 _fini

```



###### 动态链接库节信息：`libfunc.so`

```shell
[root@localhost demo0205]# readelf -a libfunc.so
ELF 头：
  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类型:                              DYN (共享目标文件)
  入口点地址：              0x600
  程序头起点：              64 (bytes into file)
  Start of section headers:          6216 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         7
  节头大小：         64 (字节)
  节头数量：         27
  字符串表索引节头： 26

程序头：
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000007e4 0x00000000000007e4  R E    200000
// .....
```

我们发现该文件的类型为：DYN，动态链接共享目标文件

结合之前的节信息，我们可以推测 **ELF文件的类型可以分为三种：EXEC（可执行文件），DYN（共享目标文件），REL（可重定位文件）**



### ELF文件类型

ELF文件格式包括三种主要的类型：EXEC（可执行文件），DYN（共享库），REL（可重定位文件）

```pain
1.可执行文件(应用程序)可执行文件包含了代码和数据，是可以直接运行的程序。

2.可重定向文件(*.o)可重定向文件又称为目标文件，它包含了代码和数据(这些数据是和其他重定位文件和共享的object文件一起连接时使用的)。
    
    demo.o文件参与程序的连接(创建一个程序)和程序的执行(运行一个程序)，它提供了一个方便有效的方法来用并行的视角看待文件的内容，这些demo.o文件的活动可以反映出不同的需要。
	Linux下，我们可以用gcc -c编译源文件时可将其编译成demo.o格式。
	  -E                       仅作预处理，不进行编译、汇编和链接
      -S                       编译到汇编语言，不进行汇编和链接
      -c                       编译、汇编到目标代码，不进行链接

3.共享文件(*.so)也称为动态库文件，它包含了代码和数据(这些数据是在连接时候被连接器ld和运行时动态连接器使用的)。
	
	动态连接器可能称为ld.so.1，libc.so.1或者 ld-linux.so.1。我的CentOS6.0系统中该文件为：/lib/ld-2.12.so
```

一个ELF文件从连接器(Linker)的角度看，是一些节的集合，从程序加载器(Loader)的角度看，它是一些段(Segments)的集合。

ELF格式的程序和共享库具有相同的结构，只是段的集合和节的集合上有些不同。



## 2.10 GOT、PLT

### 静态链接与动态链接对比

> 研究问题：链接过程中的 有些私有数据怎么存放？

#### 准备数据

```go
vim libpp.c
gcc -fPIC -shared -o libpp.so libpp.c
```

```c
int global_data = 0;
static int interal_data = 22;
static int sum(int a, int b){
    return a + b;
}

int sum3(int a, int b, int c){
    sum2(a,b);
    return sum(a, b) + c + global_data + interal_data;
};

int sum2(int a, int b){
   return a - b + global_data + interal_data;
}
```

#### 对比私有与共有函数

将该代码编译为动态链接库 libshr.so，将其中的代码进行反编译：

```go
objdump -d libpp.so
```

```go
// 对于共享函数库中的共享函数的调用需要通过其余代码来定位共享代码来调用
00000000000005e0 <sum2@plt>:
 5e0:	ff 25 3a 0a 20 00    	jmpq   *0x200a3a(%rip)        # 201020 <sum2@@Base+0x2008d9>
 5e6:	68 01 00 00 00       	pushq  $0x1
 5eb:	e9 d0 ff ff ff       	jmpq   5c0 <.plt>

// 对于私有函数的调用是通过绝对地址进行调用的
00000000000006e5 <sum>:
 6e5:	55                   	push   %rbp
 6e6:	48 89 e5             	mov    %rsp,%rbp
 6e9:	89 7d fc             	mov    %edi,-0x4(%rbp)
 6ec:	89 75 f8             	mov    %esi,-0x8(%rbp)
 6ef:	8b 45 f8             	mov    -0x8(%rbp),%eax
 6f2:	8b 55 fc             	mov    -0x4(%rbp),%edx
 6f5:	01 d0                	add    %edx,%eax
 6f7:	5d                   	pop    %rbp
 6f8:	c3                   	retq   


00000000000006f9 <sum3>:
 6f9:	55                   	push   %rbp
 6fa:	48 89 e5             	mov    %rsp,%rbp
 6fd:	48 83 ec 10          	sub    $0x10,%rsp
 701:	89 7d fc             	mov    %edi,-0x4(%rbp)
 704:	89 75 f8             	mov    %esi,-0x8(%rbp)
 707:	89 55 f4             	mov    %edx,-0xc(%rbp)
 70a:	8b 55 f8             	mov    -0x8(%rbp),%edx
 70d:	8b 45 fc             	mov    -0x4(%rbp),%eax
 710:	89 d6                	mov    %edx,%esi
 712:	89 c7                	mov    %eax,%edi
 714:	b8 00 00 00 00       	mov    $0x0,%eax
// 这里调用了共享函数sum2(a, b)  这里为什么是plt呢？
// 
 719:	e8 c2 fe ff ff       	callq  5e0 <sum2@plt>
 71e:	8b 55 f8             	mov    -0x8(%rbp),%edx
 721:	8b 45 fc             	mov    -0x4(%rbp),%eax
 724:	89 d6                	mov    %edx,%esi
 726:	89 c7                	mov    %eax,%edi
// 这里调用了私有函数sum(a, b)
 728:	e8 b8 ff ff ff       	callq  6e5 <sum>
 72d:	8b 55 f4             	mov    -0xc(%rbp),%edx
 730:	01 c2                	add    %eax,%edx
 // 取 global_data（共享的数据变量）
 732:	48 8b 05 9f 08 20 00 	mov    0x20089f(%rip),%rax        # 200fd8 <global_data@@Base-0x60>
 739:	8b 00                	mov    (%rax),%eax
 73b:	01 c2                	add    %eax,%edx
 // 取 interal_data（寻址私有数据）
 73d:	8b 05 ed 08 20 00    	mov    0x2008ed(%rip),%eax        # 201030 <interal_data>
 743:	01 d0                	add    %edx,%eax
 745:	c9                   	leaveq 
 746:	c3                   	retq   

0000000000000747 <sum2>:
 747:	55                   	push   %rbp
 748:	48 89 e5             	mov    %rsp,%rbp
 74b:	89 7d fc             	mov    %edi,-0x4(%rbp)
 74e:	89 75 f8             	mov    %esi,-0x8(%rbp)
 751:	8b 45 f8             	mov    -0x8(%rbp),%eax
 754:	8b 55 fc             	mov    -0x4(%rbp),%edx
 757:	29 c2                	sub    %eax,%edx
 // 取 global_data（共享的数据变量）
 759:	48 8b 05 78 08 20 00 	mov    0x200878(%rip),%rax        # 200fd8 <global_data@@Base-0x60>
 760:	8b 00                	mov    (%rax),%eax
 762:	01 c2                	add    %eax,%edx
 // 取 interal_data（寻址私有数据）
 764:	8b 05 c6 08 20 00    	mov    0x2008c6(%rip),%eax        # 201030 <interal_data>
 76a:	01 d0                	add    %edx,%eax
 76c:	5d                   	pop    %rbp
 76d:	c3                   	retq   
```

#### 对比变量存储位置

```go
objdump -d libpp.so
```

```shell
Contents of section .got:
 200fd0 00000000 00000000 00000000 00000000  ................
 200fe0 00000000 00000000 00000000 00000000  ................
 200ff0 00000000 00000000 00000000 00000000  ................
Contents of section .got.plt:
 201000 100e2000 00000000 00000000 00000000  .. .............
 201010 00000000 00000000 d6050000 00000000  ................
 201020 e6050000 00000000 f6050000 00000000  ................
Contents of section .data:
 201030 16000000                             ....            
```

**验证了**：共享的数据变量 global_data在`section .got`，私有数据 interal_data在`section .data`中



### GOT PLT讲解

**什么叫PIC地址无关代码？**

不像静态链接库一样，所有的地址值都通过 重定位符号表 进行修正，而是通过 plt 和 got 和相对位移 来确定真实地址。静态访问时，通过偏移量进行访问



> PLT表为（Procedure Link Table），是程序链接表。 
>
> GOT表为（Global Offset Table），是一个存储外部库函数的表，全局偏移表。

借助动态链接器去完成获取函数。。。



通过刚才的分析，我们发现对于静态数据、函数的调用和静态链接时是一样的，都是通过地址直接获取到并执行，没有什么变化。但是对于共享的数据和函数则是通过 GOT 和 PLT 处理的。

GOT 和 PLT 都是 表，而表就是用来查询的

我们的程序代码 .text段 和 .rodata段 是不能写的，因为需要保护程序，而我们又要在代码中访问全局函数和数据，那想要获取到真实地址怎么办呢？ 我们需要在可写区域维护两张表，用于在链接后存储全局函数调用的地址，这样就可以通过访问对应的表项来实现地址无关了。



GOT节中有三行数据，我们对反汇编文件检查，发现表项中的有对应的三行数据所表示的范围中的值的访问，分别是：

```shell
// 1.
Disassembly of section .init:
00000000000005a0 <_init>:
 5a0:	48 83 ec 08          	sub    $0x8,%rsp
 5a4:	48 8b 05 35 0a 20 00 	mov    0x200a35(%rip),%rax        # 200fe0 <__gmon_start__>
// ......

// 2. 
Disassembly of section .text:
0000000000000600 <deregister_tm_clones>:
// ....
 61d:	48 8b 05 ac 09 20 00 	mov    0x2009ac(%rip),%rax        # 200fd0 <_ITM_deregisterTMCloneTable>
// ....


// 3.
00000000000006f9 <func>:
// ....
 732:	48 8b 05 9f 08 20 00 	mov    0x20089f(%rip),%rax        # 200fd8 <global_data@@Base-0x58>
```

这里got节虽然只有三行数据，但是每个数据的地址都是相隔16字节的，所以按理说应该不止包含三个项，从反编译的代码中也能找到对应中间位置的访问。

并且在对这些地址的访问时，都是先存入一个寄存器，然后通过 `（）`语法进行解引用，所以说，这个地址内部存放的信息实际上是 一个个物理内存地址。我们可以猜测对于共享变量的访问其实是访问的一张真实地址的映射表，每次进行链接时，将需要的数据的地址写到该映射表中，这样就可以通过该映射表实现访问了。





对于PLT：我们发现当调用一个共享函数时，会跳转到一个 <plt> 代码中执行

```shell
00000000000005d0 <f@plt>:
 5d0:	ff 25 42 0a 20 00    	jmpq   *0x200a42(%rip)        # 201018 <f@@Base+0x2008d1>
 5d6:	68 00 00 00 00       	pushq  $0x0
 5db:	e9 e0 ff ff ff       	jmpq   5c0 <.plt>
```

我们发现在 plt 代码中，会再次实现跳转 ---> `201018 <f@@Base+0x2008d1>`

我们通过 `readelf -a`指令发现该地址是指向了 `.plt`节中的偏移量

```shell
重定位节 '.rela.plt' 位于偏移量 0x558 含有 3 个条目：
  偏移量          信息           类型           符号值        符号名称 + 加数
000000201018  000700000007 R_X86_64_JUMP_SLO 0000000000000747 f + 0
000000201020  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __gmon_start__ + 0
000000201028  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0
```

当第一次跳转到该位置时发现没有值，就会回到 5d6 位置执行，然后执行 `jmpq   5c0 <.plt>`，我们发现所有的 plt 在最后一行都是跳转到 `5c0`

```shell
00000000000005c0 <.plt>:
 5c0:	ff 35 42 0a 20 00    	pushq  0x200a42(%rip)        # 201008 <_GLOBAL_OFFSET_TABLE_+0x8>
 5c6:	ff 25 44 0a 20 00    	jmpq   *0x200a44(%rip)        # 201010 <_GLOBAL_OFFSET_TABLE_+0x10>
 5cc:	0f 1f 40 00          	nopl   0x0(%rax)
```

而在 5c0 的代码中再一次发生跳转----- 这里是跳转到了动态链接器，动态链接器会将 真实的函数地址填在对应的表项中，这样下次在进行 jmp 到对应表项所存的地址值的函数 就是真实的函数地址了。而具体的表项下标是怎么确定的呢？ ----> 由于都是调用了同一个代码，而却有不同的函数需要定位，所以我们可以猜测表项下标是通过参数传递过来 ---> 回看到调用 `5c0`之前的代码，可以看到有一个压栈的代码：`pushq  $0x0`





![img](https://cdn.nlark.com/yuque/0/2022/gif/2641989/1653887348928-cc2280ad-1606-4248-a32f-f9a072f42534.gif)



### hello,world 在C语言中的全过程



#### 程序装载从头执行？

此部分略

#### 关于`printf`的调用?

当执行到 call printf 函数时，这里call 的时 plt 的代码，plt代码会跳转到 GOT对应表项的中的地址所指的函数，而第一次调用时，表项中填的值是 plt 中的下一行代码，然后会将 GOT 表中对应的下标压入栈中，作为接下来调用 动态链接器的参数（动态链接器的地址放在 GOT_0 表项中），动态链接器会将找到的真实函数地址填入到 GOT 对应的表项中，然后再次调用就会通过 GOT表拿到真实物理地址。



### 验证：gdb调试 C代码验证动态链接过程

1. GDB 调试工具验证
2. ELF 文档验证 

1. 1. ELF文件格式分析 中文版 P35
   2. ELF 英文全  P49



## 2.11 C语言程序执行过程

> 00:03:21 知识串联
> 00:18:21 ELF文档讲解
> 00:33:40 内存对齐⭐
> 01:06:30 程序在哪里执行第一行代码⭐
> 01:13:35 glibc源码验证
> 01:17:50 不同语言获取环境变量



### 串联：程序如何被CPU执行？

![程序如何被CPU执行？](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302111656734.png?tximg)



**ELF是什么？**

- 回顾一下ELF比较主要的3个文件：`.o`    `.so`  `.out`，还有两个表：GOT、PLT

- ELF文件格式包括三种主要的类型：EXEC（可执行文件），DYN（共享库），REL（可重定位文件）

- GOT 和 PLT 都是用来查询的表





## 2.12  程序执行过程补充验证

> 00:01:00 ELF规范手册验证程序执行流程
> 00:19:00 C语言主函数入参讲解
> 00:52:00 setjump/longjump原理
> 01:02:40 程序执行流程
> 01:08:40 java启动执行过程
> 01:14:50 libjvm.so
> 01:17:45 java 启动 debug验证



### 二进制位运算

与运算：二进制截断，遇0则0

或运算：二进制组合，遇1则1

异或运算：无进位加法

```go
1111 1001 & 0x0f = 0000 1001
1111 1001 | 0x0f = 0xff
1111 0000 ^ 0001 1100 = 1110 1100
1110 0000 ^ 0001 1100 = 0000 1100 
```



### setjmp、longjmp原理

由于 CPU 执行代码通过与寄存器交互实现功能，寄存器中存储的内容就等同于当前程序执行的上下文



## 2.13 ELF相关扫尾

> 00:04:45 知识回顾
> 00:21:30 链接库打包
> 00:41:00 C Primer Plus讲解









## 2.14 C Primer Plus 链接相关

> 00:07:40 C Primer Plus 链接相关讲解
> 00:34:40 java符号解析与重定位
> 00:55:50 bss未初始化数据段讲解
> 01:11:00 ELF与文件系统关联
> 01:22:30 C Primer Plus符号解析讲解











## 2.15 CSAPP ELF讲解

> 00:03:10 CSAPP链接相关讲解
> 00:20:00 CSAPP重定位讲解
> 00:38:55 CSAPP可执行目标文件讲解
> 00:42:45 gdb原理
> 00:51:00 gdb代码验证
> 00:58:25 CSAPP加载可执行目标文件
> 01:02:25 CSAPP动态链接库
> 01:06:35 CSAPP库打桩机制
> 01:11:40 Gperftools讲解
> 01:17:50 堆内存讲解













## 2.16 malloc 与 free讲解

> 00:11:05 知识回顾
> 00:14:15 shell原理
> 00:25:10 malloc 与 free函数讲解
> 00:38:20 库打桩机制链接应用
> 00:45:00 redis发展历史
> 00:49:00 redis 2.6 设计思想
> 01:15:30 redis 2.6 main函数zmalloc初览












