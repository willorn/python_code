## 知识串联

总结之前讲的内容，一个由C语言编写的程序在运行时的过程是：

1. 首先将程序代码 (.c文件) 进行预处理，将其中的宏定义进行替换
2. 然后将源文件编译为汇编代码 （.s）文件 
   1. 此过程中会将程序用不同的段来标明（代码段、数据段），外部变量和字符串会在数据段给定一个地址(“.LC0”)
   2. 将所有函数的调用都使用 符号名 填充
3. 通过汇编器将 .s 文件转换为 符合机器架构的 ISA 指令集程序
   1. 生成 .o文件，可重定位文件（elf：EXEC（可执行文件），DYN（共享库），REL（可重定位文件））
   2. 包含`ELFheader`、`符号表`、`字符串表`，用于静态链接的`重定位表`，动态链接的` PLT表`、`GOT表`
   3. 使用 特殊的地址值 给待解析的符号占位
4. 将程序链接为可执行文件	`.out`
   1. 静态链接，将多个文件链接到一个可执行文件中，使得各个代码段以及数据的地址是线性唯一的，不会出现地址冲突的情况。然后根据重定位后的地址，进行符号解析，即根据重定位表信息找到需要地址替换的位置 以及 替换为哪个符号的地址
   2. 动态链接：将公共的代码抽离编译为一个 `.so` 动态链接库，并为每一个虚拟地址空间（程序空间）的堆内存 mmap 一段空间来做 到真实函数库地址的映射。由于虚拟程序空间可以多个，他们都存放一份映射到真实地址中的动态链接库。然后便可实现共享。GOT--PLT
5. 将 a.out 文件加载到内存中：读取 ELF Header（包含了该程序的组织关系，即描述该文件结构的元数据信息） 从而找到 enter point，该地址指向程序的入口地址，除此之外还包含有Program header 的地址，通过该表中的条目进行解析
   1. INTERP：表明需要调用动态链接器，且通过该项给出了动态链接器的路径
   2. LOAD：进行内存装载，将可执行文件怎么装载到内存，装载到内存的哪个位置？
      1. 代码段 在 64bit 上的起始地址是 0x40000，即4MB的位置，因为需要保留零地址空间，且还需要考虑到分页大小，因为对零地址的操作是违规的，而 intel 规定的分页大小是 4kb - 4mb，所以选取最大的 4mb 来满足所有情况。
      2. 在 32bit 上的起始地址是  0x804800 是栈顶，这样栈溢出后自然就将指向了 0地址的空间，从而空指针异常让程序崩溃，而不是导致覆盖掉程序的数据
6. 从 enter point 得到程序的入口地址，_start 函数（是由编译器添加的）来处理参数信息（根据ABI规范实现），然后调用 _libc_start_main 之后调用 init 函数 进行初始化工作，调用gmon_start，之后返回 _start中，然后调用 main 函数
7. EIP 指向要执行的指令，拿到指令 经历流水线级  取指 -> 译码 -> 执行 -> 访存 -> 写回
8. 一些指令需要访问硬件，比如分配内存…… 而这些操作如果直接用代码操作是很不方便的，且是不可预知的，所以由操作系统的去操作和管理硬件内容，向上提供函数库(CRT)，让编程人员更加关注业务的实现，而不用更多关注底层



## OS 

分页和分段----



由于存在虚拟内存机制，所以每个程序都认为自己占有了所有的内存空间，这样程序之间分配内存就可以互不干扰。由此我们可以很方便的在内存中存放多个程序同时执行，那么如何让这些程序能够在**有限的硬件资源**上执行呢？这就是操作系统需要解决的问题之一。

### 如何执行？

硬件资源有哪些呢？先假定只有两个重要的：

1. CPU
2. 内存 

我们首要的是研究CPU的调度，所以先假定内存无限大，且程序已经在内存空间中建立虚拟内存映射，现在只需要CPU执行指令即可。假设有 A、B、C 三个程序需要执行，可以这样做：

1. 让三个程序挨着执行，执行完毕后才切换下一个程序，所有程序串行化
2. **分时复用CPU**，将CPU的执行时间进行切割为一段一段的，每一段执行一个程序，只要切割的时间足够小，人们就无法识别（如：切割为100ms一段，然后每 100ms执行一个程序，轮流着执行）

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1655781726689-16a7abd4-e304-45b6-b274-1d65ac46bf34.png?tximg)

我们可以发现 A程序在分时复用下的执行完成时间要晚于在串行模式下，所以说 **在分时复用模型下，程序执行的时延（程序执行完毕时间 - 程序开始执行时间）要高于串行执行中。但是其吞吐量（给定时间范围内，完成的任务数，如tps、qps）要大于串行模型**



### 进程

不管怎样，内存中是存在多个程序的，所以操作系统要怎样拿到这些程序呢？以及怎么获取程序的数据的呢？所以我们需要一些内容来描述程序的相关信息（如：有哪些段，分别在哪里）

除此之外，CPU内部分为 控制单元、逻辑运算单元、寄存器 三大部分，其中控制单元和逻辑运算单元都是伴随着一条指令的执行完毕而不再保留任何信息，所以控制单元和逻辑运算单元是可以随意复用的，但是寄存器文件就不同了，他保存着当前指令执行过程中需要的一系列信息，所以寄存器是不可以直接复用的，而是需要进行一系列的处理。怎么处理呢？我们想要做的就是希望当执行的程序切换回来时寄存器中任然时我之前的状态（称之为上下文信息），所以我们可以在发生切换的时候将寄存器中的值保存下来，切换回来时对寄存器中的值进行恢复即可。此过程称之为**上下文切换**

那么该内容放在什么地方呢？（注意在内存方面就分为四大块：代码段、数据段、堆、栈），其中只有 堆 和 栈 是动态分配的，而堆又是代码段共享的，其实压根用不上什么数据段共享，所以存放在栈中即可……

**ELF是静态的程序数据，程序需要在内存中执行，就需要有描述该程序的元数据，于是 程序在内存中的元数据信息 + ELF 中静态的程序数据 = 进程**



如上内容只是推理猜测，需要进行验证（验证方式有两种 源码、权威书籍）

在操作系统层面叫做 `PCB `（`process control block` 进程控制块），在 Linux 中采用了 `struct task_struct `来表示进程。一个属于抽象层，一个属于实现层。

```c
struct task_struct {
/* these are hardcoded - don't touch */
	long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
	long counter;
	long priority;
	long signal;
	struct sigaction sigaction[32];
	long blocked;	/* bitmap of masked signals */
/* various fields */
	int exit_code;
	unsigned long start_code,end_code,end_data,brk,start_stack;
	long pid,father,pgrp,session,leader;
	unsigned short uid,euid,suid;
	unsigned short gid,egid,sgid;
	long alarm;
	long utime,stime,cutime,cstime,start_time;
	unsigned short used_math;
/* file system info */
	int tty;		/* -1 if no tty, so it must be signed */
	unsigned short umask;
	struct m_inode * pwd;
	struct m_inode * root;
	struct m_inode * executable;
	unsigned long close_on_exec;
	struct file * filp[NR_OPEN];
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
	struct desc_struct ldt[3];
/* tss for this task */
	struct tss_struct tss;
};
```



### 总结

可执行文件通过 `exec` 的系统调用函数 加载到虚拟内存中，进程排布，生成 task_struct，将栈、堆、数据、代码的首地址保存在 task_struct 中