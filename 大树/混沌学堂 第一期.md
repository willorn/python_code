# 第一章 计算机组成

## 1.1 计算机的种子

> Q：
>
> 易经中的推理是什么？计算机体系中的逻辑推理又是什么？
>
> 计算机的seed是什么？是谁如何机缘巧合之下想出来这么巧妙的东西？又是在怎样的必然性和偶然性之下出现了？
>
> 计算机这东西里面是什么？结构是啥？
>
> 计算机的发展历程是什么？最开始的雏形？
>
> 在这个系列的最后，我们要清晰程序是如何被CPU调度执行的？

### 推理逻辑：

物有本末，事有终始，知其先后则近道矣

**修仙**：以仙气来修炼成长路线——《永生》

**游戏**：以新手教程和装备一步一步闯关，升级转职——《时空猎人》

**混沌**：先启蒙，先求道而后求术——《代码之道》



### 计算机历史

> 首先，一张图来看看CPU之下是什么？

![image-20230204101550971](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302041015375.png?tximg)

#### 图灵机模型

**一切缘起：图灵机（Turing machine）**

**seed**：需要一种能够帮助人工作的机器，给到输入能够做出对应的输出

**图灵机**：从0到1

【什么是图灵机】https://www.bilibili.com/video/BV1br4y1N762

> 因为这其实就是模拟人类大脑的运算思路而制定的，比如说当人类思考3+4的时候会以一种什么样的思路去思考呢？什么样的思考方法可以使得任意大小的两个数都可以以相同的方法被计算出来呢？从这里面可以看出来，当经过两群1中间的0的时候，读写头的模式被更新成q2，而再经过一个0的时候读写头的模式会被更新成q3从而保持不动，而从q1变到q2再变到q3这个过程需要的步数便是这个过程中1的数量，由此可以进行任意大小两个数的加法计算。而且我可以根据数据的不同来制定不同的代码表从而实现不同的功能。比如说如果两个数中间有两个0，比如说三个数相加比如说两个数相乘，理论来讲都可以利用这种方法来进行模拟。而且图灵在之后证明了所有可以用算法解决的事情，或者说叫做可计算内容都可以用图灵机进行计算，方法是证明了图灵机的运作模式和之前被证明可以定义可计算问题的方法等价。而图灵的这种方法并不需要进行随机应变，只需要按照一个既定的程序读取一段既定的代码，就可以把所有可计算问题全部计算出来。
>
> 所以说并不是因为这个方法本身有多巧妙，而是因为这个方法可以计算的内容就是现有定义下的所有可计算内容，因此才是一个划时代意义的东西。这就意味着，我们可以借助程序来计算所有可以计算的问题，而不用担心人脑计算中可能会出现的错误，前提是程序书写恰当。



#### 冯诺依曼体系

> 冯诺依曼(1946)是计算机科学的先驱，他的主要思想是建立一种用于计算的通用机器。他提出了冯诺依曼体系结构，这是现代计算机体系结构的基础。

**思想概述**：冯诺依曼认为计算机应该是一个通用设备，可以通过使用一种通用的机器语言来编程。这种语言允许程序员以一种简单的方式编写代码，然后让计算机翻译成内部语言，从而实现计算。这一思想在当今仍然被广泛使用，并且是计算机科学领域的基础。这一思想对计算机科学的发展产生了深远的影响。

**计算机组成**：他定义了冯诺依曼体系，冯诺依曼体系是一种计算机结构，由以下几个组成部分组成，通过组装这些组件，就能够实现计算机的通用性和可编程性，从而提高计算机的功能和效率。

1. CPU（中央处理器）：负责执行计算机程序。
2. 存储器（内存）：用于存储程序和数据。
3. 输入设备（例如键盘、鼠标）：用于向计算机输入数据。
4. 输出设备（例如显示器、打印机）：用于从计算机输出数据。
5. 系统总线：连接各个组件，传输数据和控制信号。

他提出了程序可移植性的概念：使用通用语言编写代码，这表示程序员可以在任何使用冯诺依曼体系的计算机上运行代码，而不必担心底层硬件的差异。这个通用语言就是机器代码01，因为它可以以01表示有无，再加上与人类的符号系统联系，我们就可以推理得出：通过最简单的01衍生出可以描述世间任何事物的语言。通过01，可以构建所有的信息。

冯诺依曼体系的概念十分重要，它提出了使用通用语言编写代码的方法，以便计算机能够识别和处理数据。这一思想为后来的信息处理技术奠定了基础，并对后来的信息学研究产生了深远的影响。例如，通过使用冯诺依曼体系，我们可以对信息进行编码、存储、处理、传输和解码，实现了信息的高效处理。

总之，冯诺依曼体系是计算机科学史上一个重要的里程碑，对于计算机的发展产生了深远的影响。



> 看完了冯诺依曼，我们知道了01就是通用语言，我们可以用1，0组成万物，表示所有信息。

而对这些最基本的信息原子，可以使用运算器、控制器、存储器、IO来完成工作。这些计算机的硬件我们现在都耳熟能详，而研究他们，最重要的核心还是运算单元：CPU。

#### 计算机体系

> **计算机体系**：指由计算机的硬件和软件组成的系统。

硬件是指计算机的物理部件，如中央处理器（CPU）、内存（RAM）、存储设备（硬盘或闪存）等。

软件是指运行在计算机上的程序，包括操作系统、应用软件等。计算机体系是完成各种任务的基础，如计算数学公式、存储和处理数据、连接网络等。



**研究内容**

研究计算机体系结构我们需要重点关注的几项：**低功耗、高性能和小单位**，因为它们是影响计算机系统性能和效率的重要因素。

- 低功耗：减少计算机系统功耗可以降低成本并延长使用寿命。

- 高性能：计算机系统能够快速处理大量数据，从而实现快速和准确的计算。

- 小单位：计算机系统的结构尽可能紧凑，从而使系统更容易携带和维护。

其他因素，例如：稳定性、可靠性、易用性、安全性、成本等。



#### 数字逻辑

数字逻辑是一门计算机科学领域的学科，主要研究如何使用数学方法和模型来设计、分析和理解计算机系统中的逻辑电路。它涵盖了计算机硬件和软件的数学模型，以及数学逻辑、代数、图论、概率论、信息理论等相关领域的知识。数字逻辑的目的是提供一种通用的方法来研究和设计数字电路，以提高计算机系统的效率和可靠性。

我们不需要关注那么多，我们只需要了解即可。基础概念：电压电流的高低电平、晶体管、逻辑门、锁存器。

**晶体管**：

很有意思，它可以利用半导体材料的特殊特性，将小电流转换为大电流。它通过控制电流流动，来改变输出电压。晶体管有三个端，分别是发射极（emitter）、基极（base）和收集极（collector）。通过对这三个端的控制，可以实现对电流的控制。晶体管可以执行电路中的开关和控制功能，如放大、切换、触发等。

**逻辑门**：

逻辑门是计算机中最基本的逻辑单元，用于执行简单的逻辑运算。它们以输入信号为基础，生成输出信号。逻辑门通常是用电学元器件（如晶体管）实现的。常见的逻辑门有：与门（AND gate）、或门（OR gate）、非门（NOT gate）、异或门（XOR gate）等。每个逻辑门都有一组定义其逻辑关系的规则，并对输入信号进行简单的逻辑运算，从而产生输出信号。

逻辑门的原理是基于电学，利用二极管和晶体管实现逻辑运算。逻辑门的操作是基于电学信号在其中传输和转换的过程，因此它们能够快速、稳定地处理信息。

**锁存器**：

锁存器（Flip-Flop）是一种存储单元，它可以存储二进制信息，通常是一位数据。

它通过控制电路实现数据存储，原理是通过两个输入信号（通常是控制信号）来控制其状态的转换，这些状态通常是 "1" 和 "0"，而这些数据是存储在内部的晶体管中的，当控制电路接通时，数据就被锁存下来，并可以在以后读取。

锁存器的状态可以用于控制计算机系统中的各种元件，例如寄存器、移位寄存器、多位寄存器等。





#### 计算机硬件

> CPU、存储（内存、硬盘）、外设（输入输出设备、电源）
>
> 冯诺依曼体系（定义了硬件） + 物理（电学）+ 数论（逻辑） = 计算机硬件

**硬件发展史**：

计算机硬件的发展历史可以追溯到 20 世纪初，当时的计算机通常由大型、繁琐的机械组件组成，如分别用于存储数据和指令的机械式磁铁和纸带。随着电子技术的发展，计算机硬件开始向数字方向发展，并逐渐由电子元器件取代机械元器件。

1940 年代，第一台用电子元器件组成的数字计算机诞生了，这是第一台真正意义上的电子计算机。随后，随着集成电路的出现，计算机硬件进一步小型化和简化，并逐渐普及到家庭和办公室。

1980 年代，个人计算机（PC）开始普及，并为计算机硬件的进一步发展提供了平台。随着微处理器技术的不断提高，计算机性能得到了显著提高，并为智能手机和平板电脑的诞生创造了条件。

现今，计算机硬件不断地演进和提高，新技术和元器件的不断涌现，如云计算、人工智能等，为计算机科学和技术的发展带来了新的机遇和挑战。







### **推荐资料**

> Tip：推荐看书，作者的话，前言（前提是翻译好才能看下去）

- 《计算机组成原理》
- 《模拟电⼦技术基础(第五版)》
- 《数字电子技术》





## 1.2 汇编语言出现

> 本节课讲了：数据**存哪里 + 怎么存**
>
> 为什么是二进制、RAM与ROM、计算机组成原理
>
> **攻乎异端，斯害也已**：但只要我们都向着正确的地方走，终会有一天大家都能汇聚在一起。
>
> 任何事物都有其发展的道，而每个人的道都不一样，但是道一直存在。每个人的道就是自己原本的宿命，圣人的宿命与小偷的宿命都是宿命，如果不能深刻认识自己，一直保持随波逐流，只能说命运永远都只是把握在别人的手中的。只有深刻认识自身，才能思变。突破困苦人生的掣肘。
>
> 任何纷繁复杂的事物都是由最简单的事物演化而来的，从根部到参天大树，都是不断演进不断前行生出来的。



### 计算机组成原理讲解

《计算机组成原理》前言

> 21世纪是科学和技术奇迹频出的时代。计算机已经做到了人们期望它做到的一切——甚至更多。生物工程解开了细胞的秘密，使科学家能够合成10年前无法想象的新药。纳米技术让人们有机会窥探微观世界，将计算机革命与原子工程结合在一起创造出的纳米机器人，也许有一天能够植入人体，修复人体内部的创伤。普适计算带来了手机、MP3播放器和数码相机，使人们彼此之间能够通过Internet保持联系。计算机是几乎所有现代技术的核心。本书将阐述计算机是如何工作的。
> 从20世纪50年代起大学就开始教授这门被称为计算的学科了。一开始，大型机主导了计算，这个学科包括对计算机本身、控制计算机的操作系统、语言和它们的编译器、数据库以及商业计算等的研究。此后，计算的发展呈指数增长，到现在已包含多个不同的领域，任何一所大学都不可能完全覆盖这些领域。人们不得不将注意力集中在计算的基本要素上。**这一学科的核心在于机器本身：计算机**。当然，作为一个理论概念，计算可以脱离计算机而独立存在。实际上，在20世纪三四十年代计算机革命开始之前，人们已经进行了相当多的关于计算机的科学理论基础的研究工作。然而，**计算在过去40年里的发展方式与微处理器的崛起紧密联系在一起**。如果人们无法拥有价格非常便宜的计算机，Internet也无法按照它已有的轨迹取得成功。
> 由于计算机本身对计算的发展及其发展方向产生了巨大影响，在计算的课程体系中包含一门有关计算机如何工作的课程是非常合理的。大学里计算机科学或计算机工程方向的培养方案中都会有这样一门课程。实际上，专业和课程的认证机构都将计算机体系结构作为一项核心要求。比如，计算机体系结构就是IEEE 计算机协会和ACM联合发布的计算学科课程体系的中心内容。
> 介绍计算机具体体现与实现的课程有各种各样的名字。有人将它们叫作硬件课，有人管它们叫作**计算机体系结构**，还有人把它们叫作**计算机组成（以及它们之间的各种组合）**。本书用计算机体系结构表示这门研究计算机设计方法和运行方式的课程。当然，我会解释为什么这门课程有那么多不同的名字，并会指出可以用不同的方式来看待计算机。
> 与计算机科学的所有领域一样，计算机体系结构也随着指令集设计、指令级并行（ILP）、Cache缓存技术、总线系统、猜测执行、多核计算等技术的发展而飞速进步。本书将讨论所有这些话题。
> 计算机体系结构是计算机科学的基石。例如，计算机性能在今天的重要性超过了以往任何时候，为了做出最佳选择，即便是那些购买个人电脑的用户也必须了解计算机系统的结构。
> 尽管绝大多数学生永远不会设计一台新的计算机，但今天的学生却需要比他们的前辈更全面地了解计算机。虽然学生们不必是合格的汇编语言程序员，但他们一定要理解总线、接口、Cache和指令系统是如何决定计算机系统的性能的。



#### 为什么是二进制？

从易经的思想可以看到，一为太极初始，二为阴阳，即男女雄雌，阴阳所生为三，就是后代，无数万物结合就构建出了万物。



电气特性限制科技发展，所以只能为二进制

计算机硬件、操作系统软件、语言、机器语言、编译器、数据库

理论基础-嵌入式开发（微处理器）

计算机组成-计算机体系结构（图灵机的实现）

1248原则

只有基础至上，在开始接触的时候基础足够牢固，以后接触到更多事物的时候才不会感觉到吃力。人往往在接触到一个事物之后就会不断探索，好奇心驱使着人们不停往下走，这就是学习动力的一种。

诸葛大力：不是我不懂，是我还没有学

CSAPP

布尔代数？离散数学：用哪里就看哪里



#### 信息的传递介质

人脑：电位差（编码，转换）

亿级流量，多级缓存（l1,l2,l3）MySQL、redis





#### 推理：如何操作硬件

**推理过程**：

##### 1、如何操控硬件?

<img src="https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302041649892.png?tximg" alt="image-20230204164942482" style="zoom: 80%;" />

写指令操作硬件需要依赖于具体的硬件和操作系统，下面是一些通用的步骤(注意：硬件的操作可能具有危险性，请确保在操作前了解相关警告和安全措施。)：

1. 了解操作系统支持的编程语言，例如 C、C++、Java、Python 等。
2. 了解硬件的接口和通信协议，如 I2C、SPI、UART 等。
3. 根据操作系统和语言的文档，写出控制硬件的代码。
4. 运行代码，测试硬件是否按预期工作。
5. 根据测试结果，不断调整代码，直到硬件能按预期工作为止。

从图中可以看到，写指令操作硬件的方式因硬件类型和操作系统而异。通常情况下，需要使用特定的编程语言（如 C，C++，Python）和相应的库（如 WinAPI，libusb，libSerial）来编写代码。



##### 2、代码是如何控制硬件的？

<img src="https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302042141738.png?tximg" alt="image-20230204165527923" style="zoom:67%;" />

因为CPU是控制器，所以控制计算机就是通过 01 组成的指令去控制CPU，而这些指令则是由硬件厂商规定，硬件厂商通常会提供一些接口（例如 USB、I2C、SPI 等），使 CPU 可以与硬件进行通信。通过写代码来使用这些接口，CPU 就可以控制硬件（BS模型）。

例如，通过向 GPU 发送命令，可以控制图形处理器进行图形渲染；通过向网卡发送命令，可以控制它接收和发送网络数据。所以 CPU 可以作为一个中心来控制其他硬件的工作。

但我们并不会直接写ISA指令，因为太复杂了。。。

影响代码的可读性，稳定性，，维护性也很差。可以预见编写ISA代码会有很大的困难，不利于开发。所以就有了 **汇编语言** 与 **汇编器**。

![image-20230204165932085](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302041659858.png?tximg)



##### 3、代码是存哪里？

程序代码通常存储在硬盘上，做持久化存储。当程序运行时，它的代码会被加载到计算机的内存（RAM）中，然后 CPU 会读取并执行这些指令。存储在硬盘上的代码可以通过文件管理器或命令行工具检索和编辑。

为什么这样设计？

1、假设不存在RAM，代码的执行只能通过磁盘进行交互。ROM是只读存储，而数据是需要存取，那么必然不能为程序开辟空间，则不能够实现这样的设计。

2、因为我们的代码文件是read only的，而数据是需要存取的，所以硬件条件较为苛刻的情况下，如微小型的设备，我们就可以使用 ROM 存储代码，只用少量的RAM 存储运行时需要更新更改的 数据即可（RAM比ROM成本高）

3、为什么不使用大缓存？成本问题

4、本质：CPU的处理速度 大幅度的超过了 磁盘 的IO速度，如果都从里面读写，就会导致CPU大部分时间处于等待中。所以我们给计算机增加了缓存，缓存是用于适配CPU的处理速度的，代码和数据加载到 RAM 中以便 CPU 可以快速访问和执行它们。于是我们就添加缓存 ，首先是RAM， 但是RAM还是很慢，在CPU 中嵌入 缓存（多级缓存技术）。



<img src="https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/202302042141739.png?tximg" alt="image-20230204172608669" style="zoom:67%;" />



**补充**：RAM与ROM

> RAM+ROM = 嵌入式、微型处理器
>
> 类比于：运算+代码 = 可用的程序

**RAM**随机存储器（random access memory）

是指随机存取存储器（random access memory，RAM）又称作“随机存储器”，是与CPU直接交换数据的内部存储器，也叫主存(内存)。

**ROM**只读存储器（Read-Only Memory）

以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失。



##### 4、推理得出：

过程：

1. 我们通过键盘，输入人类懂得的编程语言（C、Python、Java），经过特定的编译器进行编译后得到汇编语言
2. 汇编语言经过编译器转换为ISA指令集，指令集传输到CPU中
3. CPU对ISA指令进行解析，根据单个指令（ADD、MOV）对寄存器进行CRUD。
4. 控制硬件，得到反馈。



### **推荐资料**

- 《计算机组成原理》
- 《大话计算机》
- 《CSAPP》，这本书集大成



## 1.3 汇编到ISA

> **汇编世界的基本单元：8个字节**
>
> **汇编就是和ISA指令的一一对应**

### ISA指令集推理

> 本节讲了：
>
> CPU作为计算机的处理器，是用于控制和运算的
> 作为处理器的本身，自己有控制单元、运算单元、寄存单元（存储器）
>
> 操作CPU的语言叫做ISA指令，ISA指令让CPU执行各种操作
>
> ISA指令的由来是汇编语言，由汇编器生成



### 汇编语言的本质

汇编语言：操作CPU控制其他硬件控制输入输出



看了两本书的前言

1. 《计算机组成 与 汇编》
   为何汇编 会 扯到 计算机组成 ？？？？
   汇编语言是面向指令集的，而指令集又是计算机硬件厂商提供的，计算机的硬件是 计算机组成和计算机体系结构 共同研究的内容，所以 汇编 书籍中也存在一些章节是讲计算机组成、计算机体系结构的！
2. 《汇编语言 基于x86处理器》



有了汇编以后，我们可以更好的编写程序了，但是这样就够了嘛？很显然是不够的，因为还是不够贴近自然语言，所以高级语言就有了 ---> C、Python、Java、Go……



高级语言屏蔽了CPU的底层处理，更符合人类的思维习惯。



编码：将一个信息根据某种规则转变为另外一种信息





总结：

 CPU的内部结构由控制单元，运算单元，存储单元也就是寄存器这三个主要单元组成的。而CPU里面的缓存并不是它的主要的组成单元，因为缓存的速度跟CPU里面三个主要的单元速度是不匹配的。
我们单看CPU本身，CPU本身就有着很完整的内存结构，但是我们将CPU玩小了看，我们就可以看到CPU外面的世界。CPU在计算机里面只是充当着控制器以及运算器，存储功能主要放在内存rom和RAM中。CPU在外部只是小小的控制器和运算器。
这里再讲一下CPU充当控制器和运算器的工作原理。当CPU充当着控制器和运算器时，CPU拿到用户给到CPU的机器码，这个CPU机器码呢是isa指令集中的编码，CPU拿到这个指令集中的机器码之后，开始正式工作。这些指令进入到CPU中的控制单元，控制单元开始将寄存器中的数据加载出来，交给运算器去对数据进行操作运算，当操作运算完成了之后，控制器在将数据从寄存器中取出，再放置在寄存器中，然后再输出到外部内存（主存中）。
指令集就是一种编码规则，编码规范。
编码就是将一个信息通过某种特定的规则转换为另外一种信息，转换前后他们的本质上依然是信息。

### C语言出现推理



### 推荐资料

- 《汇编语言：基于x86处理器》
- 《计算机组成及汇编语言原理》





## 小结

**冯诺依曼到计算机的诞生**

图灵：计算机能够帮助人类解决问题

冯诺依曼：定义了计算机的组成，并决定了后续计算机体系的发展方向：体系结构-更优的体系

电路原理：如何组成基本电路

数字逻辑：硬件：晶体管-逻辑门-触发器-锁存器  抽象：电路逻辑

计算机硬件：CPU、内存、硬盘、外设



**计算机语言的发展过程**

计算机语言的发展历史可以追溯到计算机诞生之初。当时，计算机的程序是用机器语言编写的，机器语言是一种低级的语言，其中的指令是直接用二进制代码表示的。随着计算机硬件的发展，编写程序变得越来越困难，于是汇编语言应运而生。汇编语言是一种高级的语言，其中的指令是用符号和简短的字符代码表示的，是机器语言的一种抽象。

随着计算机科学的不断发展，高级语言如C、Java等逐渐普及，并成为计算机程序开发的主要语言，汇编语言逐渐被替代。但是，汇编语言仍然对于研究计算机体系结构和低级程序设计等领域具有重要的价值。







# 第二章 编译原理



## 1.4 步入抽象语言

汇编是啥？为什么需要汇编语言？

编译是什么过程？

编译原理又是啥？

### 汇编语言

虽然相比于机器语言，汇编语言对人类来说更具有易读性，但实际让广大码农编写是很困难的。
所以这时候我们需要将汇编语言抽象化，抽象为更加贴近为人类使用的语言。
其实汇编语言不太难，汇编语言其实只是机器码的一一映射而已，就类似于哈希表的kv。
汇编指令分为操作码和操作数。其中操作码是我要做的动作，比如说加减乘除。操作数就是1+1中的1，我们操作的对象。

接下来我们要探讨的第二个问题是什么是汇编。
汇编语言也有简单的常量定义系统，汇编主要是对内存进行操作的语言。
内存话，我们就要先考虑一下内存的大小，为什么基础的存储单元大小是八？而不是其他呢？因为布尔兹或者恰类型的值都是以八位作为最小的。如果说我们把这个基础单元，基础存储单元的大小定为16的话，那么我们存储一个布尔值或者一个类型的数字就需要传递，一个16位的大小，这样必然会造成浪费。所以我们采用八作为。基础存储单元的大小，这个基础存储单元的大小呢也必须得是小于寄存器的大小的。
内存主要分为sram，dram和rom。SRAM是有四五个晶体管组成一个寄存器，是造价最贵的。DRAM是由电容组成的造价比sram来说更便宜。Rom是最便宜的，它的材料可以是多样的。
所以我们知道汇编语言是一个什么东西了，汇编语言实际上就是一种规则。一种将用户的信息转化为机器语言信息的规则。
但是我们认为这种规则还不够完善，我们应该开发抽象出更高级的规则。让机器帮我们干更多的事，让机器可以更容易理解我们人类能理解的语言。

### 语言特性

所以我们就需要去构造一种高级语言，C语言就是我们所熟知的一种高级很纯粹的高级语言。

我们要定义一种语言，首先我们要去关注类型，数据类型是什么？第二个就是我们要去抽象操作，简化汇编语言中的add，MV等等指定。汇编指令第三点是我们要基于高级语言的特性，开发出更强大的功能。
于是我们将更高级的语言开发出来了，我们要对这种语言进行实现。实现就是用的是编译器，编译器，这最开始当然是由汇编语言写成的编译器。然后编译器加汇编器就是我们所熟知的即时编译器



C语言就是比较纯粹的汇编语言的抽象。

### 编译原理

编译就是将高级语言翻译成汇编语言或者是机器语言的过程。翻译是没有中间过程，而编译有中间过程。
例如java语言就是先把java程序编译为字节码，再将字写码翻译为机器语言。

#### 总结：

编译：翻译，将抽象的东西翻译为具体的汇编代码，最后再经过编译变为机器码。

汇编：将很多的ISA指令汇聚到一起，然后对这堆ISA指令进行统一抽象，汇编语言就是一串ISA指令集。







## 1.5 抽象语法树 graalvm llvm

本节课重点在**数据结构和算法**如何演变，由此二种最简单的元素（阴阳）生出万种程序

以及信息的转换过程，编译语言的前端到后端中**中间产物(IR)**的必要性

> 问一下：
> 编译的流程是什么？编译过程都有哪些状态？

### 编译原理推理

> 语言转换的过程

**人类**

人类翻译的过程：有许多单个的词语和语法加在一起就组成了source，我们把source解析出来的信息称为语义（中间产物），再将中间产物转换为输出信息，即是由多个单词和语法加在一起的句子。

**程序**

 无非是一种形式的信息转换为另外一种形式的信息。他们本质都是信息。但是这里需要注意一种信息能够包含万物，如果信息本质有缺陷的话，就会导致信息的遗漏



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651395599606-2081e86c-9fda-4492-b2d7-2c8065b87002.png?tximg)





#### 汇编结构：



C语言是汇编语言的抽象
阳即为多变即为动，阴即为少变即为静
有时间可以去看看《易经真的很容易》这一本书
六位老阴，九为老阳

算法是语言的底层，任何的上层语言都可以套用相同的算法
共有六个步骤，记忆，理解，应用，分析，评估，创造
学到做人做事的道理

### 抽象语法树AST推理



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651393970844-9b28cd4a-7170-4d61-bd9f-9f42cc5e4454.png?tximg)



从VM也能看出来类似的道理

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1656837563092-7b5834ba-6d0b-418f-ab3d-f95b1dc94d70.png?tximg)

### GraalVM与llvm

后端逻辑不变，让处于上层的按一定规则转换成 中间产物，即可实现对多种语言的支持

GraalVM 提供了能让多种语言在 VM 上运行的功能，从而实现 让其他语言共同享有 JVM 的 GC，跨平台、即时编译 等高级特性

邓俊辉 清华大学《数据结构（C++语言版）》

说了要在LLVM里面讲一下ebpf，直接带入到代码层面了。(看不懂)

最后在emit、code_section这里带过了一下



这节课最重要的难道不是数据结构和算法如何演变的么？而最后那个编译原理推导出前端，如何产生中间语言，后端如何解析中间语言给计算机运算，推导出jvm的编译原理。具体的实现明天的课老师会说……我看大家都讨论明天的课程了



## 1.6 深入到编译器：LLVM

> 为什么需要抽象语法树？
>
> LLVM-GCC前端/GCC前端-插件-》IR -》 LLVM后端 -》 机器语言(ISA)
>
> GCC到LLVM（GraalVM沾点边）
>
> 《LLVM编译器实战》流程



语言的编译器：
语言-【前端-中间产物-后端】-ISA



### LLVM vs GCC

LLVM本来是底层的虚拟机，没想到最后变成了这样的庞然大物。。。

#### LLVM的历史

故事过程：苹果想要搞 GCC 的人帮忙对 GCC 对于 **Object-C/Swift** 的编译做优化，但是被拒绝了。而此时，有一个群人正在 研究 LLVM 编译器，苹果抓住了这根稻草，聘请过来开发自己的编译器。最初只是做了编译器后端部分，前端部分还是使用的GCC的，编译器前端则是对GCC做了拓展，叫做LLVM-GCC。随着发展，LLVM的编译器前端也做好了，也就是最初的C-Lang。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1656840430061-09dad508-5032-4cdf-95c8-051734b98d89.png?tximg)





#### 比较

**GCC：**	1987年5月23日

- 并未根据模块儿化开发，所有的层级调用都在一起。
- 单一庞大的结构
- 所有的代码都是放入同一个包内，所以代码的及其难以阅读，以及维护。所以 很多程序员会对此开源的好奇心都难以维持。



**LLVM**：   2000年

- C++写的

- 模块化开发，解耦设计，前端后端以及中间产物都是分开的。
- 前后端所有的接口都支持热插拔。
- 一切组件均可单独使用，全部流程均可使用插件机制进行配置选择，全部模块化。



#### 启示

如果我们想要踏足的领域已经存在了一些产品，此时我们想要让我们的产品能够有竞争力，有优势，那就需要即能包含已经存在的产品的功能，并且还要在此基础上**有新的特性**（不然别人凭啥用你的？）

**所以我们在学习新的技术时，可以基于对现有技术的了解程度 + 新特性 来进行学习（技术工具是一条曲线）**

**由图：****一切语言的特性均以编译器来设计。**



所以，新推出的产品，包含功能是必定的，毕竟大家都是编译器，在此之上，完善上个产品的缺陷，所以将整个开发都坚持模块化开发。这样不论是可读性 还是维护性上都是完全优于 GCC 的，**由于模块化开发，一切模块均可热插拔,可以通过插件方式进行配置 -----> 可以高度定制化 -----> 开源后, 其余语言均可按照模块化的机制进行接入**



### EBPF 推理

**过滤器** ~ 贝克利包过滤器filter ~ Extend-BPF



#### OS与APP模型~类比

操作系统其实是一个程序，应用程序 和 操作系统 是分层级调用的，中间需要通过协议进行调用，完全可以类比到 客户端和服务端的程序。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651208045825-d7a53ba0-34cf-4aa9-b5b9-2e7aacbaa29a.jpeg?tximg)



我们先想这样一个需求，在网络请求过程中，客户端（浏览器）需要服务端的结果信息，但是需要过滤掉其中的一些部分（过滤的部分每个客户端有自己的需求）。

**分析：**

1. **如果我们在客户端进行过滤的话，也就是说所有的信息一并发出，由客户端选择丢弃还是接收，那么这就会导致浪费大量的网络IO，并且性能下降**
2. **那我们就得在服务端进行数据的过滤操作了。但是还是存在问题，浏览器客户端千千万，每个的规则都有可能不一样，这压根就没法做.....**
3. **所以我们需要客户端将自己的需求给发送到服务端，由服务端处理。**

**精简传过来的东西，只拿有用的。所以能不能使用一个通用的IR，中间语言来传递信息。**

**处理过程：**

**由于逻辑不是服务端所确定的，需要客户端来决定，所以判断逻辑的代码服务端是无法编写的，所以就需要客户端编写自己对于数据是否接收的逻辑**

**客户端则是灵活的，可以是浏览器，可以是 android 可以是 IOS，所选择的开发语言可能不同，所以我们需要一个东西来执行多种语言开发的判断逻辑语句，****一个东西对多个开发语言进行兼容****，这不就是我们说的 LLVM 嘛**

**也就是说，客户端传送自身开发语言 通过 LLVM 的前端编译器 生成的** **IR** **到服务端，服务端通过集成 LLVM 的后端编译器，就可以实现对不同语言进行解析执行了。**

也就成了这样：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651210785678-7c7bdfd2-5982-4605-a608-5d54ae974949.jpeg?tximg)

由此我们类比到操作系统中，上层应用程序需要操作系统帮忙处理IO（包括网卡 和 磁盘），读取数据，搬运到用户空间，假设应用程序也对要对所获取的数据进行过滤，那该如何做呢？

**分析：**

1. **首先我们想到的肯定是  OS：关我屁事，我直接全部发给你，爱要不要，前面也说过，这会因为锅多的IO导致性能的下降**
2. **应用程序肯定也不能直接控制 OS让他发什么不发什么，而OS自然也不知道上层应用程序需要什么不需要什么**
3. **所以需要 应用程序 和 操作系统 之间存在沟通**



#### EBPF是怎么做的

**处理过程：**

1. **应用程序根据自己的逻辑规则编写语句，通过 相应的 LLVM前端编译器****生成 IR 发送给操作系统**
2. **操作系统通过** **EBPF集成的 LLVM后端编译器 对IR 进行编译**
3. **数据到来时便会先 执行 EBPF 中对应的 判断语句，决定是否发出**



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651210590846-69a94730-0d9e-42eb-b6d5-00142e5f93a1.jpeg?tximg)



我们知道，想要在 Linux 中添加新的功能，Linus 是极小极小极小概率会让你进行添加的，更别说你想往内核代码中添加 一个虚拟机了。

假设你真的完成了这伟大的创举，那么我们不妨对该 VM 做更多的扩展空间，所以 EBPF  （扩展 BPF）就出现了，Extend BPF=》 EBPF=》 BPF。



最后，百度词条

BPF全称是「Berkeley Packet Filter」，翻译过来是「伯克利包过滤器」，顾名思义，它是在伯克利大学诞生的，1992年Steven McCanne和Van Jacobson写了一篇论文：《The BSD Packet Filter: A New Architecture for User-level Packet Capture》，第一次提出了BPF技术，在文中，**作者描述了他们如何在Unix内核实现网络数据包过滤，**这种新的技术比当时最先进的数据包过滤技术快20倍。



#### LLVM与EPB的关系

LLVM的中间语言

BPF VM 是基于 LLVM 来做的



### 语言特性

众所周知，每一个语言其实都有自己规定的一套标准，不然大家使用的都不一样，就乱套了。如果我们想要在现有的标准下进行扩展一些新特性是否可以呢？

编译器后端只需要得到一个IR即可，所以只要编译器的前端能够生成符合的IR即可。就好比我们使用的语法糖的存在，就是编译器前端部分负责转化成符合编译器后端的IR。所以只要编译器能够识别，代码就可以按照这个标准来写。

所以对于 C而言有` C标准：ANSI C `

而后又有 ` GCC：全名叫 GNU C Compiler`，是GNU计划诞生的C语言编译器

`ANSI C` 就是标准，而 `GNU C` 是对其的一个向下扩展

**所以，一个语言的特性，都是基于编译器来设计。**





### 《LLVM编译器实战》前言



LLVM是始于学校项目，开源的魅力。



【待补LLVM书籍内容】





**混沌视角：**

计算机理论中一个简洁明了的概念可能涉及多层级的实现细节，这些细节使得现实中的软件项目辩的复杂而无法让人们掌握，特别是其所有微妙之处。巧妙的抽象涉及能帮人类大脑掌握项目所有层面的关键：从高级的视图（抽象意义下程序实现和工作方式）到最底层级的细节。



GCC链接器：GCC太强大了

LLVM糅合了GCC

他们俩的关系就像是wps和office……



pipline、chanel

链接、重定位、ebpf





## 1.7 解释器与JIT

> **深入编译原理**
>
> 名词推理、知道（推理）
>
> 先有道，然后再去追求术
>
> 编译、即时编译器JIT、解释器的区别是什么？



### 抽象语法树AST详解



#### 雨露均沾学习法

强干弱枝

学术会很痛苦，苦一个月就好了

避免痛苦：每一个主干往下学习 3，4 个节点，别往深的学习，不然很痛苦，而且人脑记忆是有限的

枝繁叶茂之后，多个主干都学习了3~4个节点的时候，就会发现很多可以**共享的模块**



#### 编译~给机器人翻译

编译的过程：

- 首先我们是拿到**A语言的句子**，对他进行词法分析，得到词语和词性；
- 再对这些**词语和词性**进行语法分析，就可以得到这个句子的抽象语法树（AST）；
- 对**抽象语法树**进行语义分析就得到**中间产物**（IR：就是我们每个人对这个句子自己的理解）；
- 我们对自己的理解进行翻译(重新编码)就得到了**B语言的句子**



#### 编译器

编译器就是把语言编译为语言，编译器实现编译原理的前后端成一套
T即时编译器也实现了编译员里的前端和后端，不过他是在内存里面进行编译的，大概内容就是它可以将一些重复解释的代码进行编译。提前编译为机器码，保存在内存中。加快解释的速度
解释器就是用一门语言对其他语言进行解释执行逻辑

 

### 插曲：

最后就是讲了一下术：hotspot里面找Java调用方法

触发事件，开始编译

追求道就是大致知道里面有个什么东西，是谁触发这个替换的操作？这里面大概有几部流程？ 不要问这是什么？这是什么？


一上源码，全部懵逼！

没法看，还需要补充一些C++的东西

分支断层。资本、money



## 1.8 LLVM与BPF

汇编和编译的整体工具链

> 解释器？JIT
>
> GCC是什么
>
> BPF = LLVM + JIT内核网络包过滤器
>
> 编译器有哪些？
>
> LLVM和GraalVM想干啥？



### GCC历史



### 开始



https://zhuanlan.zhihu.com/p/70949843

#### 汇编器

*读汇编语言，转换为机器语言*

最开始计算机只能执行01代码，所以只能人工写01代码，为了节省时间，发明了汇编语言。

（能够把人们可以读懂的“菜谱”一样的输入转换成计算机可以读懂的版本）

人类写汇编代码，经过汇编器转换为机器语言（ISA）给CPU去控制计算机硬件，得到结果返回给用户。



#### 编译器

*读高级语言，转机器指令中间可以优化，处理好了的机器语言打包放那里。*

～编译就是翻译的意思，这是计算机世界的翻译官

把用高级语言写的程序转换成汇编语言，再使用汇编器把汇编语言转换成机器可读的程序。这种程序组合常常被称为“工具链”，因为一个程序的输出就直接成为另一个程序的输入。



#### 解释器

*读取脚本语言，立即执行。*

直接读取一个程序将其转换成计算机指令以立即执行。和编译器差不多，解释器读取程序并将它转换成一个中间形态。但和编译器不同的是，解释器直接执行程序的这个中间形态。解释型语言在每一次执行的时候都要经历这个过程；而编译程序只需要编译一次，之后计算机每次只需要执行编译好的机器指令就可以了。



#### 虚拟机VM：

*先将程序编译成一个中间形态，然后虚拟机再执行这个中间形态。*



### 升级了

JIT：

将字节码编译成可以由处理器运行的机器码（ISA），并且比javac更复杂，因为提供了代码优化



GCC

***what\****：*[*GNU*](https://baike.baidu.com/item/GNU/671972) *Compiler Collection，*[*GNU编译器*](https://baike.baidu.com/item/GNU编译器/10444865)*套件，是由GNU开发的编程语言译器。*

**why**：GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。（然而最后合并到Linux里面去了）

原始版本使用Pastel语言开发，第一个成熟的版本是用C开发，后来因为[LLVM](https://zh.m.wikipedia.org/wiki/LLVM)、[Clang](https://zh.m.wikipedia.org/wiki/Clang)的崛起，它更快地将开发语言转换为C++。

最开始支持C语言，后来逐渐支持更多的语言。GNU编译器套件包括C、[C++](https://baike.baidu.com/item/C%2B%2B/99272)、 [Objective-C](https://baike.baidu.com/item/Objective-C/8374012)、 [Fortran](https://baike.baidu.com/item/Fortran/674319)、[Java](https://baike.baidu.com/item/Java/85979)、[Ada](https://baike.baidu.com/item/Ada/5606819)和[Go](https://baike.baidu.com/item/Go/953521)语言前端，也包括了这些语言的库（如libstdc++，libgcj等。）





#### LLVM



#### Graalvm

- 高性能
- 云原生cloud native（简单理解：代码直接4
- 面向云端）
- 支持多语言，同一程序混合多门语言



k8s就是云原生？

Java只需要考虑代码逻辑CRUD，其他的都不需要考虑。（熔断限流都在一个地方考虑



为什么不给所有语言都先弄个前端，生成中间产物，只需要做个后端就可以处理中间产物（字节码）？

因为保留了原有语言的特性，eg：C语言保留了快速的特性；Java语言直接编译为机器码；



Java on Truffle





![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651633909818-2c7b392f-4b10-42b9-8fd1-f0ace9e78730.jpeg?tximg)





GCC：GNU compiler collection

设计最初就是为了C语言



BPF：

即时编译器 + LLVM





搜索：

GCC



#### LLVM和GraalVM想干啥？

hotspot虚拟机：包含模板解释器，还有JIT：C1、C2、Graal



LLVM：**一统编译器**

1. 源语言--LLVM-->目标平台代码。可插拔



GraalVM：**一统虚拟机，**虚拟机霸主

1. JS、python、ruby



官网https://www.graalvm.org/22.2/docs/introduction/



### 《LLVM实战》前言





**混沌视角：**

**计算机理论中一个简洁明了的概念可能涉及多层级的实现细节，这些细节使得现实中的软件项目辩的复杂而无法让人们掌握，特别是其所有微妙之处。巧妙的抽象涉及能帮人类大脑掌握项目所有层面的关键：从高级的视图（抽象意义下程序实现和工作方式）到最底层级的细节**

**从最纯粹的的意义上说，软件项目反应的是其创建者的观点，这些观点通过跨过多个组件对模块和数据表示及进行抽象来实现……**





## 1.9 寄存器推理

> **内存架构：堆栈、代码段、数据段**
>
> 代码内的**栈内存**维护与实现：维护栈顶栈底的方式
>
> 内存地址的**编码方式**（类似编写地图的方式，按照哪个比例来画地图，这里就是程序世界的地图索引方式），
>
> **内存架构**：内存里面是如何存放数据的？



### LLVM与Graalvm的作用

**内存架构怎么来的？**

首先我们讲到的是内存架构，说到内存肯定有分为公有内存和私有内存。指令操作的数据最终都会落地到内存，放在内存的哪里呢？我们就需要有内存的架构，那么我们就需要把内存按照功能分割为几个部分。

指令段里面的指令必定会有自己的数据，而这些数据是当前指令段执行完毕之后就要销毁的。又有一些数据是指令段之间所共享的数据。那么我们只需要按照功能将【内存存放数据的区域】切割开来就可以了。

**指令段**：一段代码指令

数据段私有的数据，再加上指令段所共享的数据就是一个指令段所拥有的数据。

然后我们就可以继续推理：指令段可能有多个，那么就代表着我可以同时call多个指令（call指令是计算机转移到调用的子程序）。那我们不能直接就call吧，要找到call谁是吧！

于是我们就需要一种数据结构来表示这种存储方式。
**堆内存**：私有内存就类似于栈，是多个指令流所私有的数据。
**栈内存**：共享内存就类似于堆，是多个指令流所共享的数据。

【状态寄存器】
状态寄存器的灵感来自于图灵机图灵机里面就有一个状态器用来表示我们这个程序下一步需要走到哪个位置。
告诉程序说我们这个程序到底要不要跳，跳到哪个地方？

### 栈内存开辟

#### 他们是怎么来的？

还有一个要说的就是我们这个汇编语言组成的程序肯定不能是一整块的，所以我们需要把这个汇编语言分成一段一段的，而这一段一段的呢我们就将它称之为代码段，也叫做指令段。

在这里我们可以将c语言分支出来，一条叫做程序，程序是有一组代码组成程序，也可以叫做由指令流组成的功能组件。
堆内存和栈内存：怎么来的？

由于数据结构中占的特性是后进先出，也是先进后出，这就意味着站顶的内存就是当前正在执行的代码段，而当站点弹栈后，当前暂定依旧是执行的当前代码段。

但此时我们又需要去考虑一个问题。当调用子函数的时候，需要开辟新的栈帧。（帧：一片空间里存放了一组数据。而在站的一片空间里存放了一组数据就叫做栈帧。）
如何开辟空间呢？这就需要引入数据结构里面占的定义和占的基本操作。不管是什么数据结构，我们都需要引入一片内存，但是我们的内存是分为连续和不连续的。
对于连续的内存，我们只需要直接移动栈顶指针就可以了。对于不连续的内存，也就是说我们的内存之间的连续性是依靠指针来实现的（类似链表～反向链表），这种情况我们同样是移动暂停指针来表示当前执行的指令就行。
到这里我们就可以推出我们的寄存器组，里面有状态寄存器，是用于跳转指令使用的。下一个就是我们的指令地址寄存器，用于保存当前执行的指令地址。现在我们推出了栈顶指令寄存器和我们的栈底指令寄存器。
在外面我们可以看到占地指针寄存器，它一直指向的都是当前占的最底下的位置，而站顶指针寄存器指向的一直都是当前所在的指令行。
根据大可大小可小的原则，我们可以猜测一下，在占内存的里面，它是这么做的，当我们需要辟一个新的战争时，我们先将上一个栈帧的栈底存放起来，然后再去开辟新的代码段的战争。
【栈帧】
每个指令流都有自己的栈帧，战争里存放当前指令流的操作的数据，当使用call指令转移指令流后，那么只需要保存上一个指令流的栈底地址即可。
栈顶指针可以随意的向上走向下走，当他向上走的时候，它是一直开辟着空间的，当他向下走的时候，一直是战的过程，战过程的他就会将上一个指令段的占地地址给弹出来。其实就是个大链表思想。

#### 栈顶和栈底指针结构

我们说，一个代码段通过调用call进入另一个代码段后，为了实现多个代码段有自己的私有数据区域，于是引入了栈内存，那栈内存在代码段调用时是如何开辟的呢？？

想想我们的数据结构中的栈，就是通过一个栈顶一个栈底记录栈的情况，通过栈顶++实现放入元素，栈顶--实现弹出元素，当 栈顶 == 栈底 代表栈空，所以，我们需要维护一个 栈顶 和 一个 栈底 的数据表示。

![image-20221018095238857](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/image-20221018095238857.png?tximg)



表示栈顶和栈底的数据存放在哪里呢？ ----> 频繁修改查询，存放在寄存器中，并且必须要有，所以要通过寄存器来保存，所以就有了 栈顶寄存器 和 栈底寄存器。

从栈底到栈顶这段区域中，保存了目前为止该代码段执行过程中需要的数据，我们称之为**栈帧。（单位：帧，该区域可以包含所需的元数据信息）**

此时，如果我们需要 call 代码段B时，此时怎么分配呢？只是移动栈顶指针？？？那就会造成两个代码段的内容 融合在了一起，所以这是不可以滴。我们就要想办法把两个代码段的栈帧隔开，并且不共用同一个栈底变量，那是不是我们每个栈帧都使用自己的栈底变量呢？？？ 这样做其实是多余的，我们可以复用该寄存器中的值，每次call时，重新赋值 栈底寄存器，让其指向栈顶寄存器中的值。如下图所示

![image-20221018095215009](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/image-20221018095215009.png?tximg)





#### 实现

这样的话，我原来的栈底值保存在哪里呢？既然寄存器中存不了，那只有放内存中了，放内存中的什么位置呢？一个巧妙的设计就有了，直接放在两个栈帧中间。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652161149460-f35601c2-00d0-420f-bc2c-a3979642f5ab.jpeg?tximg)

这样做就完美了，每次调用 call 跳转到另一个指令时，我们就将当前的栈底寄存器保存在栈内存中，同时移动此时的栈底和栈顶就得到了一个新的栈帧。当代码段B执行完毕后，为了能得到原来的栈底值，只需要将其弹出保存在 栈底寄存器中即可实现。



### 内存地址编码方式

需要总共32位地址才能表示每个地址，最基本的地址就是1个byte。
我们要对四 g 进行寻址，我们用阴阳来算，那么我们至少是需要32位阴阳来表示所有的地址位，以二进制编码的话，我们是需要32位表示所有的地址。，但是如果我们采用16进制编码呢？
一个16进制能表示4位二进制，一节更比4节强，所以呢，我们现在就只需要8位16进制数就可以表示原本32位二进制所能表示的信息。
这里再简单讲述一下，为什么要推出来是16进制的编码，首先我们需要表示4GB的容量，对4GB进行选址，我们就需要拿到。如果我们需要对4GB进行啊，选址对4GB，用我们的二进制来选址的话，我们就需要32位，总共需要32位地址才能够表示每个地址的排列组合啊，那么这个时候呢，如果说我们只是用32位的来表示，那么我们写每个地址都需要32位的字符，非常长很浪费空间，所以呢，我们在这里我们就推出了一个16进制的编码，16进制编码就包括0~9abcdef，哦我们用几位二进制可以表示16个数呢，我们只需要4位二进制就可以表示16个数，那么我们一个16进制就可以表示4位二进制数，也就是说我们16进制一节更比4节二进制更强。所以这里我们采用了16进制作为我们的编码。
那为什么我们不用八进制呢？因为八进制只能表示三位二进制数这个凑不到一个整也挺浪费空间的，那为什么不是30二位32进制编码呢？32进制编码它是用5位二进制来表示，同样会浪费很多空间，不够凑整。

0xffffffff比0x0000要大。
所以上面的叫高地址，下面的叫做低地址。（大端存储小端存储）
我们聊到了高地址和地地址，也就是H和L





**内存中的值我们通过什么方式进行定位呢？**

很容易想到我们为每个位置进行标明地址，这样通过一个特定的地址值就能找到所需的数据。

计算机是只认 2进制的，而最小寻址单位是 byte，所以对于 4GB 的内存而言，我们通过计算可以得知需要 32位二进制数 才能表示完。如果在编程过程中，每次我们定位一个地址时都写 32个 01 或者 查看 32个01，那肯定是个噩梦，于是我们需要对其进行编码，采用 16进制数来进行表示，这样 一个十六进制位就可以表示 4个二进制位，32位也只需要写 8 个字符，方便了很多。**所以 内存地址 采用 十六进制编码方式表示。**

**好处：**

- 为了对齐
- 采用16进制编码地址信息，为了避免表示二进制位数过多
- 便于找到程序，大家都知道自己的位置了。A联系B也会方便非常多，计算机世界就活起来了。

**为何不使用 10 进制，8 进制，32 进制呢？**

- 8 进制能表示的数太少了，同样的数减少的位数并不是很理想；
- 10 进制数，并不是 2 的幂，这就会导致一些位数无法化为定长的十进制数，一个十进制位 能表示几个二进制位？3个半吗？所以显然是不理想的；
- 32 进制，就太大了，编码也比较复杂。



既然有了地址表示，就有相对而言的大小问题，我们把地址值大的称为 **高地址（H）**，地址值小的称为 **低地址（L）**。高地址位和低地址位。



操作系统是软件吗？

然后画风一转我们就到了操作系统，操作系统它是基于C语言的程序，用来管理硬件的软件。操作系统呢它是分为两大阵营的，有 Windows，还有Unix。
【操作系统是一个软件吗？】
我们可以推理一下是C语言先出现呢还是操作系统先出现呢啊，首先我们可以看到汇编语言一定是先出现的汇编语言呢，而C语言呢，又需要编译器去编译成汇编语言啊，编译器呢，又是建立在操作系统之上的，所以说我们一定是有了操作系统才有了编译器，然后才有了C语言，可以由C语言转化为汇编语言。所以我们可以看到第1个操作系统必然是机器语言0101写出来的，第1个操作系统全都是010011全是机器代码。
然后在这里我们可以看到C语言是没有办法直接去操作硬件的，因为C语言它必须得经过编译器这一关，它编译器不让他去操作硬件，他就操作不了硬件，而汇编是可以操作硬件的，因为汇编可以看作是机器语言的一种抽象。
那到这里我们可以大胆的猜想一下，第1个操作系统它必然全都是由Isa指令来写的，而到之后的版本的都是，如果我们需要去操作硬件的话，我们这些代码是用汇编语言来写，如果不需要去操作硬件，我们就采用C语言来编写。

【其他APP能操作操作系统吗？】
所以得出操作系统也在内存，但与此同时其他的应用程序是必然不能去影响我们的操作系统的，因为我们操作系统在计算机里面是有高于一切的权限，他管理了一切，如果任由应用系统应用程序随便去搞。操作系统的内存那么整个计算机将会变得非常的不安全。
然后现在我们可以看到程序的内存里面究竟存放了哪些数据，主要有4种数据，第1个是堆内存，第2个是占内存，还有代码段内存，数据内存。
栈内存主要存放的是指令流私有的数据，这是动态分配的，堆内存主要存放的是指令流之间所共享的数据。这也是动态分配的。代码段内存顾名思义就是存放代码的内存。数据内存用于存放在编译时期就生成的静态数据，例如Java里面的public static final。
他们在操作系统里面是这样排列的，首先操作系统的最顶处是用来存放操作系统所专享的一片内存，接着往下就是一片空白的区域再往下，就是占内存占内存，是用来存放指令流所私有的数据，这是动态分配的，它和堆内存一样都是动态分配的，只不过都内存用来存放的是指令流所共享的数据，接着我们可以再往下看，看到数据内存数据内存里面存放的数据是在编译时期就生成的静态数据，再往下看就是代码，段内存代码段内存里面存放的就是一些代码。再往下是一个空白的地方，这里可以看作是一个内存中的无人区，通常初始化为一个无效值的时候，例如说我们指向null啊，都是用的这个区域的地址。纸箱钠那里最高应该是零差400000然后我们的占内存占定站定应该是7C00000，这都是历史原因。决定的当然，这个内存的结构大致分成这样，也是写死了的，具体什么原因有兴趣可以查一下。


### 内存架构

既然内存 分为了 堆内存和栈内存，那么他们在内存中是如何分布的呢？？

在这里我们要引入 操作系统，操作系统是控制硬件的一套程序，其特权是最大的，为了避免被其他应用程序访问和破坏，所以它有着特殊的地位。操作系统在内存中独占了 顶部 或者 底部。然后维护一个边界，其他应用程序不得访问以及更改。

除此之外，代码也是需要加载到内存中才能运行的，所以内存中还应该有一处是用来保存代码的  -----> **代码内存**；另外，一些在程序加载时，就会创建的变量（例如Java程序中的 static final）也是需要放入到内存中的，所以对应着也有一个单独的分区 -------> **数据内存** 

**数据内存 和 代码内存 都是程序加载时就确定的，所以称之为 静态内存**

**堆内存 和 栈内存 都是在程序运行过程中动态开辟的，所以称之为 动态内存**



约定一片内存作为OS专用的区域

**栈内存**：多个指令流私有的数据。动态数据
**堆内存**：多个指令流共享的数据。动态数据
**代码段内存**：存放执行的代码（程序指令流）
**数据内存**：存放数据（static final、）

规定上下界，堆栈内存统一一大块

初始化为无效值



最后他们的分配如下图所示：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652164980893-a99148e5-716b-4f1e-933b-9e367180727d.jpeg?tximg)

最下面放的是null值





## 1.10 指令集 总线

使用汇编推理C语言：汇编语言基础

> 将上一节课关于内存架构的内容串联起来，东西多了，需要串联起来，才能形成知识的基本脉络。
>
> 地址是什么？
>
> 通用寄存器，专用寄存器



寄存器的大小

一个寄存器可以表示多少个 byte 的数据呢？寄存器的位数与 CPU 的结构相关，也就是 CPU 的位数。



### 内存架构



#### CPU里面的寄存器

我们说，一个代码段通过调用`call`进入另一个代码段后，为了实现多个代码段有自己的私有数据区域，于是引入了栈内存，那栈内存在代码段调用时是如何开辟的呢？？
想想我们的数据结构中的栈，就是通过一个栈顶一个栈底记录栈的情况，通过栈顶++实现放入元素，栈顶--实现弹出元素，当 栈顶 == 栈底 代表栈空，所以，我们需要维护一个 `栈顶` 和 一个 `栈底` 的数据表示。
表示栈顶和栈底的数据存放在哪里呢？ ----> 频繁修改查询，存放在`寄存器`中，并且必须要有，所以要通过寄存器来保存，所以就有了 栈顶寄存器 和 栈底寄存器。

【当我们开辟空间的时候是怎么做的呢？】

![栈内存开辟单一.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1652160213198-50c748eb-f0e7-455a-b8b8-dddb2aef9b30.jpeg)

> `call过程`：首先代码段a的栈帧去开辟空间的时候，我们先把栈顶寄存器的位置向上移一位，然后给它指向的位置保存上栈底地址，然后栈顶寄存器再往上移。等到栈顶寄存器，执行完B的栈帧（也就是将代码段B的栈帧全部弹栈完毕）弹完了之后呢，就会到代码段B栈帧的下面一行，就正好是栈底寄存器的值（代码段A的栈底地址），我们栈顶寄存器就返回到他刚刚执行的地方。

从栈底到栈顶这段区域中，保存了目前为止该代码段执行过程中需要的数据，我们称之为**栈帧。（单位：帧，该区域可以包含所需的元数据信息）**

此时，如果我们需要 call 代码段B时，此时怎么分配呢？只是移动栈顶指针？？？那就会造成两个代码段的内容 融合在了一起，所以这是步可以滴。我们就要想办法把两个代码段的栈帧隔开，并且不共用同一个栈底变量，那是不是我们每个栈帧都使用自己的栈底变量呢？？？ 这样做其实是多余的，我们可以复用该寄存器中的值，每次call时，重新赋值 栈底寄存器，让其指向栈顶寄存器中的值。如下图所示

![栈帧分配--callb.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1652160803924-cbb748dd-8f7e-4355-89c8-6cdc7a1eac6f.jpeg)

这样的话，我原来的栈底值保存在哪里呢？既然寄存器中存不了，那只有放内存中了，放内存中的什么位置呢？一个巧妙的设计就有了，直接放在两个栈帧中间

![栈帧分配final.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1652161149460-f35601c2-00d0-420f-bc2c-a3979642f5ab.jpeg)

这样做就完美了，每次调用 call 跳转到另一个指令时，我们就将当前的栈底寄存器保存在栈内存中，同时移动此时的栈底和栈顶就得到了一个新的栈帧。当代码段B执行完毕后，为了能得到原来的栈底值，只需要将其弹出保存在 栈底寄存器中即可实现。





编码规则就是将16进制编码进行应用，然后将32位2进制转变为8位16进制。



【动态分配内存与静态分配内存】

内存空间里面

动态分配的，有栈内存和堆内存。

静态分配的，有数据内存和代码段内存。



动态分配的原因是栈内存，它是从高到低这样不断的开辟栈空间。而堆内存开辟空间与之相似，也是一个动态分配的过程，他们都是动态分配的。

下面说一下静态分配，静态分配里面包含了两个内存，一个是数据内存，另外一个是代码段内存。



代码段数据例子——**静态变量**：

代码段内存里面的一些静态变量是非常巧妙的，比如说我们有一个指令叫做`mov 1 a寄存器;`就是将我们的1这个数据放到我们的寄存器里面，那么我们可以看到1这个数据它本身就是存在于我们的指令流当中的，那么我们的指令流呢又是存在于代码段的内存里面的，所以我们就可以说1这个数据它是存在于这个代码段里面的，所以我们就可以说1这个数据是静态变量。



`？？？`静态分配的内存是编译时期开辟的空间吗？



#### 堆内存数据存放

堆内存～指令流之间共享的数据



【堆内存～指令流之间共享的数据】

堆内存中怎么实现共享数据？-> 汇编规则

我们说，堆内存是用来存放多个代码段共享的数据，那么怎么进行存储呢？肯定是由一个代码段来进行存储，另一个代码段进行读取或者更改。这些代码段都是通过内存地址进行操作的，所以存储时，会得到一个内存地址， 获取时，是拿到这个地址，然后进行读取，更改操作则是对该地址上的内容进行更改。所以说，重点是怎么让这些个代码段知道这个地址的存在。因为代码段共享的数据，可以通过传递 或者 定义成 实例变量就可以直接使用了，所以我们可以将这个地址呢存放在一个地方，让各个需要该数据的代码段直接操作即可。于是，我们将共数据的地址放在数据内存中。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652174421464-785ed80e-6168-4a3d-a7cf-773a6ac4c372.jpeg?tximg)



数据内存是在汇编代码中定义的，汇编语言面对的是 汇编器，所以汇编器规定了指令的规则：

1. 代码定义：`.text` 定义代码段
2. 数据定义：`.data` 定义数据段
3. 指令流：`英文名+:` 定义指令流名字



因为数据段是静态共享的，所以，我们通过在数据段定义一个数据，这样各个代码段就可以对该数据进行读取、修改了。



【能够寻址多少？】

2的16次方个byte，就是64KB嘛（2的6次方KB）

堆内存我们可以举例说是0x0000到0xffff，他所能够表示的地址总大小就是2的16次方个byte，而1位16进制等于4位二进制，内存地址就是给内存中的每一个字节编了一个号，这个号就叫做内存地址。*重点中的重点。*



为什么16位0101能指示出来这么多的信息？

例如我们有10位2进制，最多能够表示1024个数据，那么其实我们可用它来表示中国的所有市（截至2020年12月，中华人民共和国实际直接管辖全境共有684个市。）跟以上的道理相通，最小的基本单位是8bit，而这里所说的最小单位是一个城市。



在图的存储器中的地址里面@

地址是采用16进制编码，地址信息为了避免表示的二进制位数过多，所以我们引入了16进制编码对我们的地址进行编码，所以内存地址存在的高低之分，高地址和低地址。

使用16进制给内存中的每一个字节编了个号，那么这个编号就叫做内存地址。



所以共享内存大多数都是写在汇编代码里面的（静态），由一段指令流给他去分配内存，然后在数据内存里面给某个变量附上词，然后另外一段指令流执行的时候，它就到对应的共享区域的数据内存里面去取就行了。

当我们要面向汇编奇去写我们的代码的时候。首先规则就是代码，在汇编语言里面写成点text，也就是代码段文本定义了代码段数据用点，data表示它定义了数据段，也就是我们各个指令流之间所共享的数据，对于我们的方法调用指令流的相互调用，是使用英文加一个冒号，就是我们给不同的指令流片段之间定义的名字call。



a：或是 b：

在汇编语言里面会将这种看作是每个指令流的首地址。汇编器会将这些英文冒号变为指令流的起始内存地址。

然后我们回到寄存器组，

首先是状态寄存器：表示了里面的进位是否为0啊，还是其他，还有指令是否需要跳转呢？

指令地址寄存器：用于指向当前我要执行的汇编指令的地址，栈顶寄存器用来指向当前执行代码流的栈内存的顶部，栈底寄存器与之相反。



【专用寄存器和通用寄存器】

状态寄存器：专用寄存器只能用于它所表明的用途。（例如：指令地址，寄存器，栈顶寄存器，栈底寄存器……）

通用寄存器：可以用于它所表明的用途，并且它还可以随便用。



【图示CPU】

CPU里面其实就是一堆寄存器（有专用寄存器和通用寄存器），高速缓存，控制器，运算器。

我们操作CPU其实就是汇编语言里面操作CPU就是对里面的寄存器进行各种操作。

（超哥提了一嘴，这里面的高速缓存可以和sram连在一起）



我们可以画一个图，就是关于编译原理的图。首先通过汇编器将编译语言转化为ISA指令集（这其中就有一定的规则，这个规则就是.text定义代码段啊，.data定义数据段等待），我们可以看到汇编语言与ISA是强相关的。

根据汇编语言指令集架构，主要分为x86汇编以及arm的汇编，所以一旦我们需要研究这个汇编代码，我们是不是就得找到特定平台的ISA呢？



然后我们看到内存， 里面有分为操作系统，所专属的内存，还有栈内存堆内存等等。



其中栈内存里面存放的数据就是指令流动态分配的私有数据，那么我这里面的这个栈内存它是怎么分的？首先我们就有站底计算器，还有栈顶计算器，由于内存是连续的且有高低之分，我们的指令流里面又定义了加减操作，所以我们可以按照栈内存的增长方向来计算占顶寄存器的移动位置，就能够表示我们所分配的内存。

如果左边是高地址，右边是低地址，那么我们为栈内存开辟4个单位的空间就是栈顶寄存器，向右移4位，如果说执行完了那我们需要团战团战的话，那我们就是向左边移动4个单位。（主要看内存的增长方向是从低到高还是从高到低）

堆内存，是用来存放指令流动态分配的共享数据。

数据内存，是在汇编代码段的.data段定义的数据。

指定内存，存放指令而又由于指令中可以写入数据（比如说move 1，寄存器），所以这里也存在了数据，只不过这个数据它是嵌入在指令中。



指令内存里面存放了不同的指令片段，有指令片段一和指令片段2，如果说我们指定片段一里面的数据想要调用我们指定片段2的话，那我们就需要用call指令指定片段一里面的程序，它的栈帧是存放在栈内存里面的指定片段2也是在栈内存里面存放的。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659691182786-0ade7453-9f61-49f3-8021-6780ecac99a0.jpeg?tximg)





#### 什么是汇编小结

将上述以及以前讲的一部分内容放在一起来看，什么是汇编代码？它完成了一个什么事儿？



汇编语言，是通过汇编器转换为 ISA 指令集 从而来操作CPU的，从外看，我们知道 操作 控制器，来操作寄存器，所以可以理解为操作寄存器 

整个流程，汇编语言到 ISA 再到控制CPU硬件，CPU再直接控制计算机硬件......

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652175919531-019824cf-4d81-4dba-9faa-514feb29af36.jpeg?tximg)



根据编译原理，我们知道 汇编语言 与 汇编器强相关，而汇编器又与 ISA 指令集强相关，所以根据不同的 ISA 指令集，会有不同的汇编语言（如：基于 X86的，基于RAM 的）

- windows x64和x86最主要的区别：windows x64是指64位的操作系统，windows x86是指32位的操作系统。 32位系统最多只能发挥4G内存的效用，如果电脑安装了大于4G的内存，32位的操作系统是不能更好的利用大于4G的那部分内存的效用的，所以会造成资源浪费。
- 精简指令集（ARM）是复杂指令集（X86）的封装。

- - arm优势在于存放微码和解码器可以很小很简单，CPU架构精简，成本低效率高，缺点是功能少，对于开发者很苦逼；
  - X86一个指令的事你要自己想半天去实现。X86就相反，因为要有地方存放大量微码而且必须要庞大的解码器解码指令，所以核心大成本高效率低。

复杂指令集和精简指令集属于计算机考古学。如今界限很模糊了。
x86指令集1978年出来的时候，精简指令集论文都没有。
979年以帕特逊教授为首的一批科学家也开始在美国加州大学伯克莱分校开展RISC这一研究．80年代才真正开始发展。
但是，由于cisc用了那么久，操作系统，软件全是继续X86为代表的cisc，总不能重新编吧。
后来到了64位时代，intel准备放弃x86开发了一个ia64，和x86不兼容。结果amd把X86扩展到64位。而且比尔盖兹也懒得给intel重写操作系统。结果就黄了。
**现在**x86处理器会把x86指令转换为更像RISC的微指令再予执行，从而获得可与RISC比拟的超标量性能，而仍然保持向前兼容。所以INTEL的X86其实本质已经变成准RISC了。

**大小**

2的16次方个byte，就是64KB嘛（2的6次方KB）

堆内存我们可以举例说是0x0000到0xffff，他所能够表示的地址总大小就是2的16次方个byte，而1位16进制等于4位二进制，内存地址就是给内存中的每一个字节编了一个号，这个号就叫做内存地址。*重点中的重点。*



为什么16位0101能指示出来这么多的信息？

例如我们有10位2进制，最多能够表示1024个数据，那么其实我们可用它来表示中国的所有市（截至2020年12月，中华人民共和国实际直接管辖全境共有684个市。）跟以上的道理相通，最小的基本单位是8bit，而这里所说的最小单位是一个城市。



在图的存储器中的地址里面@

地址是采用16进制编码，地址信息为了避免表示的二进制位数过多，所以我们引入了16进制编码对我们的地址进行编码，所以内存地址存在的高低之分，高地址和低地址。

使用16进制给内存中的每一个字节编了个号，那么这个编号就叫做内存地址。



所以共享内存大多数都是写在汇编代码里面的（静态），由一段指令流给他去分配内存，然后在数据内存里面给某个变量附上词，然后另外一段指令流执行的时候，它就到对应的共享区域的数据内存里面去取就行了。

当我们要面向汇编奇去写我们的代码的时候。首先规则就是代码，在汇编语言里面写成点text，也就是代码段文本定义了代码段数据用点，data表示它定义了数据段，也就是我们各个指令流之间所共享的数据，对于我们的方法调用指令流的相互调用，是使用英文加一个冒号，就是我们给不同的指令流片段之间定义的名字call。



#### 简单的汇编指令

a：或是 b：

在汇编语言里面会将这种看作是每个指令流的首地址。汇编器会将这些英文冒号变为指令流的起始内存地址。

然后我们回到寄存器组，

首先是状态寄存器：表示了里面的进位是否为0啊，还是其他，还有指令是否需要跳转呢？

指令地址寄存器：用于指向当前我要执行的汇编指令的地址，栈顶寄存器用来指向当前执行代码流的栈内存的顶部，栈底寄存器与之相反。



【专用寄存器和通用寄存器】

状态寄存器：专用寄存器只能用于它所表明的用途。（例如：指令地址，寄存器，栈顶寄存器，栈底寄存器……）

通用寄存器：可以用于它所表明的用途，并且它还可以随便用。



【图示CPU】

CPU里面其实就是一堆寄存器（有专用寄存器和通用寄存器），高速缓存，控制器，运算器。

我们操作CPU其实就是汇编语言里面操作CPU就是对里面的寄存器进行各种操作。

（超哥提了一嘴，这里面的高速缓存可以和sram连在一起）



我们可以画一个图，就是关于编译原理的图。首先通过汇编器将编译语言转化为ISA指令集（这其中就有一定的规则，这个规则就是.text定义代码段啊，.data定义数据段等待），我们可以看到汇编语言与ISA是强相关的。

根据汇编语言指令集架构，主要分为x86汇编以及arm的汇编，所以一旦我们需要研究这个汇编代码，我们是不是就得找到特定平台的ISA呢？



然后我们看到内存， 里面有分为操作系统，所专属的内存，还有栈内存堆内存等等。



其中栈内存里面存放的数据就是指令流动态分配的私有数据，那么我这里面的这个栈内存它是怎么分的？首先我们就有站底计算器，还有栈顶计算器，由于内存是连续的且有高低之分，我们的指令流里面又定义了加减操作，所以我们可以按照栈内存的增长方向来计算占顶寄存器的移动位置，就能够表示我们所分配的内存。

如果左边是高地址，右边是低地址，那么我们为栈内存开辟4个单位的空间就是栈顶寄存器，向右移4位，如果说执行完了那我们需要团战团战的话，那我们就是向左边移动4个单位。（主要看内存的增长方向是从低到高还是从高到低）

堆内存，是用来存放指令流动态分配的共享数据。

数据内存，是在汇编代码段的.data段定义的数据。

指定内存，存放指令而又由于指令中可以写入数据（比如说move 1，寄存器），所以这里也存在了数据，只不过这个数据它是嵌入在指令中。

指令内存里面存放了不同的指令片段，有指令片段一和指令片段2，如果说我们指定片段一里面的数据想要调用我们指定片段2的话，那我们就需要用call指令指定片段一里面的程序，它的栈帧是存放在战略群里面的指定片段2也是在战略层里面存放的。



#### 指令架构的选择

我们要研究编译原理，就得选择一个指令架构，指令架构又是由 CPU 设定的，所以我们需要选择一个 CPU 开发厂商的进行学习

我们可以选择 **Intel的x86架构**，因为该平台为PC端的统治者而且为CISC统治者，所以我们选择该平台来研究。

确定了这一点，我们应该选择什么资料呢？没有疑问肯定是《intel 开发手册》



【补充一些关于看书的】

按照自己的需求去看懂章节，**第3章《汇编原理》**

我们翻开第3章，我们现在只是需要去验证一下我们所学到的理论到底正不正确。

我们可以看到一开始有一个main 和妹and positive。在微软msam里面就是move eax，5。eax=5   Invoke调用函数，输入参数。



【为什么要看英特尔的手册？】

有一句话叫做，物有本末，事有终始。知其先后，则近道矣。

每一个事情都有他原本的样子，每个事物都由他开始到发展到现在的历史流程，我们了解到整个事物发展的流程掌握了脉络，我们就离道更近了。

所以我们要研究英特尔，那么我们就要研究英特尔的历史。没有谁比英特尔的开发者更了解他们的平台，所以呢，我们应该直接去问开发者吗？不可能，所以我们应该看他们写的手册。



英特尔的手册分为4卷。第1卷讲的是基础架构（总），第2卷讲的是所有的指令及引用，包括a到Z（分）。第3卷讲了系统编程指南，我们应该怎么利用这些指令集去编程？第4卷是平台强相关的挂钩的东西。



引会图示。

英特尔平台的英特尔手册分为四卷，采用总分结构进行编写。



13用于详细观看

24是用来查阅



先看到英特尔的历史，然后看里面的东西是怎么用的。直白点说就是找到基础的寄存器， Basic program execution registers.



### 总线

#### 看intel手册的前提

讲完了上面关于寄存器英特尔CPU相关的东西，我们下面就来讲到总线，这是计算机组成原理的部分知识，正式学习 Intel 开发手册之前我们需要补充一下总线的知识。



计算机的各个部件之间需要进行消息传递，所以肯定需要有连线来实现。需要哪些线呢？想想各个部件之间需要传递些什么？

1. CPU 控制各个设备，控制什么？ 读 or 写？
2. 确定了操作之后，我们需要确定操作的具体内存位置
3. 确定了需要操作的位置后，还需要确定操作的数据，比如写操作，那写什么数据呢？





![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1656896760334-2c1312b7-fdc9-4f54-badd-aef0e314f1d1.png?tximg)



cpu和内存的通信

https://itigic.com/zh-CN/communication-between-cpu-and-ram-how-does-it-occur/





于是就有了：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652177135536-227bacf6-0aea-4d26-a38c-bec23bf3ebae.jpeg?tximg)

- 控制总线 CB
- 地址总线 AB：读写操作指明他的地址
- 数据总线 DB：传输数据



【那么这些总线的位数是多少呢？】

这三类总线的位数通常都是与我们CPU的位数是强相关的，以下我们就可以看到这些标准的排列组合有什么影响？

- CB的位数：控制总线的位数决定了控制的种类，可以控制一个东西。比如说它是有什么权限，没有什么权限，2的N次方种控制的种类。
- AB的位数：也就是地址总线的位数。它决定了可以控制多少个地址。比如说2的16次方个byte字节也就是64KB，说明他可以管理这么多这么大的地址。
- DB的位数：是一次传输信息（数据）的位数。





#### 看书验证

《计算机组成原理》

总线将计算机的两个或多个功能单元连接在一起，并允许他们相互交换数据，例如CPU与显卡之间的总线。总线还将计算机与外设连接在一起，例如打印机接入计算机的USB总线总线是计算机系统非常重要的组成部分。

书里面介绍了没有总线的情况，他们之间的连接是非常凌乱不堪的，而有了总线就可以一次连接所有单元。 

PCI设备就是没有总线加上有公共总线，南桥北桥。我们可以在北桥上面搭一个PCI设备，然后把这个PCI设备挂在总线上，那么其他的总线和他交互就可以了。（ PCI控制器）

 ESB，

总线根本没怎么介绍嘛。

《计算机组成与体系结构》

用于数据传输的总线称为数据总线，data bus数据总线传递是必须在计算机的不同位置之间移动的实际信息（0101二进制）。

计算机通过控制总线control bus只是哪个设备允许使用总线以及使用总线的目的，（例如是读还是写内存或者io设备）。控制总线也传递关于总线的请求，中断和时钟信号同步的响应信号。

地址总线用于指出数据读写的位置（比如内存）。

【图示计算机硬件～内存～计算机组成原理～总线】





### 补充一些修心的

我们研究一个新的东西，始终记住一句话

物有本末，事有终始，知其先后，则近道矣

所以我们应该先了解 intel 的历史，然后去 查看 寄存器相关知识

老黄要给我们修心了，讲论语了

论语里面有很多篇，唯一一篇就是要学的学而篇



学而时习之，不亦乐乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？

学了东西就要成为自己的习惯，而不是说我学了东西要去温习。别人不知自己也不要去怪罪别人。

君子务本，本立而道生。

到千乘之国，敬事而信节，用而爱人，使民以时。

不患人之不己知，患不知人也。



下期计划

我们开始第1轮会将一些浅尝即止的东西，把这个树给构造完毕。

开始第2轮的时候，从数字逻辑和冯诺依曼体系把树上面的东西全部都补全了。把树叶之间的关联都关联起来。

最后这个数会有AI人工智能，大数据web开发等等各样的东西。数据库中间件的开发，





## 1.11 存储

将上一节课的内容串联起来，东西多了，需要串联起来，才能形成脉络。



寄存器的大小

一个寄存器可以表示多少个 byte 的数据呢？寄存器的位数与 CPU 的结构相关，也就是 CPU 的位数。

### 堆内存数据存放



堆内存中怎么实现共享数据？-> 汇编规则

我们说，堆内存是用来存放多个代码段共享的数据，那么怎么进行存储呢？肯定是由一个代码段来进行存储，另一个代码段进行读取或者更改。这些代码段都是通过内存地址进行操作的，所以存储时，会得到一个内存地址， 获取时，是拿到这个地址，然后进行读取，更改操作则是对该地址上的内容进行更改。所以说，重点是怎么让这些个代码段知道这个地址的存在。因为代码段共享的数据，可以通过传递 或者 定义成 实例变量就可以直接使用了，所以我们可以将这个地址呢存放在一个地方，让各个需要该数据的代码段直接操作即可。于是，我们将共数据的地址放在数据内存中。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652174421464-785ed80e-6168-4a3d-a7cf-773a6ac4c372.jpeg?tximg)



数据内存是在汇编代码中定义的，汇编语言面对的是 汇编器，所以汇编器规定了指令的规则：

1. 代码定义：`.text` 定义代码段
2. 数据定义：`.data` 定义数据段
3. 指令流：`英文名+:` 定义指令流名字



因为数据段是静态共享的，所以，我们通过在数据段定义一个数据，这样各个代码段就可以对该数据进行读取、修改了。



### 小结



将上述以及以前讲的一部分内容放在一起来看，什么是汇编代码？它完成了一个什么事儿？



汇编语言，是通过汇编器转换为 ISA 指令集 从而来操作CPU的，从外看，我们知道 操作 控制器，来操作寄存器，所以可以理解为操作寄存器 

整个流程，汇编语言到 ISA 再到控制CPU......

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652175919531-019824cf-4d81-4dba-9faa-514feb29af36.jpeg?tximg)



根据编译原理，我们知道 汇编语言 与 汇编器强相关，而汇编器又与 ISA 指令集强相关，所以根据不同的 ISA 指令集，会有不同的汇编语言（如：基于 X86的，基于RAM 的）



我们要研究编译原理，就得选择一个指令架构，指令架构又是由 CPU 设定的，所以我们需要选择一个 CPU 开发厂商的进行学习，于是我们可以选择 Intel的，确定了这一点，我们应该选择什么资料呢？没有疑问肯定是《intel 开发手册》



我们研究一个新的东西，始终记住一句话

物有本末，事有终始，知其先后，则近道矣

所以我们应该先了解 intel 的历史，然后去 查看 寄存器相关知识





### 总线

在正式学习 Intel 开发手册之前我们需要补充一下总线的知识



计算机的各个部件之间需要进行消息传递，所以肯定需要有连线来实现。需要哪些线呢？想想各个部件之间需要传递些什么？

1. CPU 控制各个设备，控制什么？ 读 or 写？
2. 确定了操作之后，我们需要确定操作的具体内存位置
3. 确定了需要操作的位置后，还需要确定操作的数据，比如写操作，那写什么数据呢？



于是就有了：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652177135536-227bacf6-0aea-4d26-a38c-bec23bf3ebae.jpeg?tximg)



1. 控制总线 CB
2. 地址总线 AB
3. 数据总线 DB









# 第三章 intel CPU与汇编

## 1.12 从intel手册开始



简单讲了一下超前学习的同学学习应该多注重推理，不要太将注意力放在术上了

编码规则，步入intel

### 推理学习：

这个东西为什么存在，过程是什么？

这里的后半部分还需要复习一下

什么是指令片段指令片段就是一堆Isa指令以汇编的形式表示出来，但是我们不能把所有的ISO指令都放在一个地方，所以我们就有了不同的指令片段。而不同指令片段组合的过程就叫链接。



**学习之道**

1. 用自己已经知道的知识去推出你要学习的这个知识，以及它存在的意义（费曼学习原则）
2. 如果是你，你怎么设计
3. 它解决了什么问题？
4. 我们可以用来做什么？
5. ......



### Intel编码与AT&T编码

**两位大佬的出现**

定律：新东西的出现，各**大公司之间就要掐架，定标准**。都希望自己名垂青史

linus 喷 intel 感兴趣搜索：加入AVX-512只提升了特定场景下的性能，而带来的影响是其他基础功能更加受限，但是优势是在基准测试中得分更高，并且大部分用户会为得分买单。

国外贼他妈讨厌英特尔，对英特尔是又爱又恨，牙膏厂那就是又爱又恨。

google 搜索 intel 风格

汇编是对ISA的编码（抽象），编译是对汇编进行编译生成ISA指令（具象化）。

重要重要的一句话，**汇编代码就是对ISA指令的编码**。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659871760965-cfc78100-a891-4668-9ea4-1e0f6067ff1a.png?tximg)

**众望所归**

于是出现了两种编码风格：**intel**（最多人用，所以研究它） 和 **AT&T风格（业界常用，业界标准）**

- Intel是x86架构处理器的缔造者，老大哥Intel设计了一套汇编语言，作为x86指令的助记符；
- AT&T公司的前身是贝尔实验室，C语言和Unix系统的出生地。注重**汇编语言的语法跨平台性。**
- 研究英特尔的时候，我们就要看英特尔的编码；当我们研究行业标准的时候，我们就要看AT&T编码。

| **AT&T风格**                                    | **Intel风格**                                         |
| ----------------------------------------------- | ----------------------------------------------------- |
| 寄存器前加%                                     | 寄存器无需另加符号                                    |
| 立即数前加$                                     | 立即数无需另加符号                                    |
| 16进制立即数使用0x前缀                          | 16进制的立即数使用h后缀                               |
| 源操作数在前，目的操作数在后（从前往后读）      | 目的操作数在前，源操作数在后（从后往前读）            |
| 间接寻址使用小括号()                            | 间接寻址使用中括号[]                                  |
| 间接寻址完整格式：%sreg:disp(%base,index,scale) | 间接寻址完整格式：sreg:[basereg + index*scale + disp] |
| 操作位数：指令+l、w、b                          | 指令+ dword ptr、word ptr、byte ptr                   |

面向汇编器编程，具体哪个编码集



编码规则：知其先后则近道矣



### intel 手册 cpu历史

#### 8086与8088

IA-32存在两个 16 bit 的CPU --> 8086 和 8088

The IA-32 architecture（体系结构） family was preceded by 16-bit processors, the 8086 and 8088. **The 8086 has 16-bit registers and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to the 8086 except it has an 8-bit external data bus.**

The 8086/8088 introduced segmentation to the IA-32 architecture. With segmentation, a 16-bit segment register contains a pointer to a memory segment of up to 64 KBytes. Using four segment registers at a time, 8086/8088 processors are able to address up to 256 KBytes without switching between segments. The 20-bit addresses that can be formed **using a segment register and an additional 16-bit pointer** provide a **total address range of 1 MByte.**

**译：**

在 8086 和 8088 中都存在 16位寄存器，20位地址总线，只不过 8086 有 16位数据总线，而8088只有**8位数据总线**

在 8086 和 8088 中 引入了内存分段模型，当内存不进行分段时，我们使用一次使用 4 个段寄存器可以寻址 256KB，因为 16位的寄存器可以表示64kb，同时使用4个段寄存器-> 4 * 64kb = 256KB。

但是我们引入了分段概念后，就能够通过一个段寄存器指定目标地址所在段（间接获得基址），用基址 + 指令地址寄存器的值  从而得到 20 bit 地址，就可以寻址 1 MB 的内存空间了。



#### 段寄存器的出现

段寄存器 + 指令地址寄存器

= 段+偏移量进行寻址
= 基地址 + 偏移地址
= base + bis



段寄存器包含：

- 栈段寄存器（SS）
- 数据段寄存器（DS）
- 代码段寄存器（CS）
- 其他寄存器（other S）



#### 需求变更——16bit要改20bit

虽然总线数是越大越好，但是会有电磁干扰，限制了最大的总线数。

**为何地址总线不是 16 位而是 20 位呢？？？**

这其实是当时的生产原因，由于当时已经生产出了 1 mb 的存储器，寻址也就至少需要 20 bit 才能寻址完，所以采用了 20 位地址总线。

一个工程师灵机一动，出现了段寄存器。（参考intel 一个大佬写过的一个博客……）

但是存在一个问题呀，我指令地址寄存器只有 16位，怎么使用 20 位的地址总线呢？此时就有一个工程师想到了，将内存分段，分成每一段都能通过 16位表示，也就是 64KB，1 mb 的内存就被分为了 16段，然后再通过一个**段寄存器**来实现段的确定。

段寄存器，为了确定不同的内容，针对于 栈内存，数据内存，代码内存 有 栈段寄存器，数据段寄存器，代码段寄存器，其他段寄存器。



### 

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |

## 1.13 Intel历史、保护模式

我们可以往后面看，看到英特尔的历史各种内存分段啊保护模式，4个特权级，还有段界限检查，这些CPU的特性，再加上我们的汇编语言，还有我们的C语言我们就可以推出操作系统。操作系统，so easy。

**汇编都不学好，怎么推后面？**



**为何要讲 CPU**，我们知道 控制了CPU就相当于控制了整个计算机，而操作系统正是用于该功能。所以操作系统肯定是要面向于 CPU 提供的指令操作 进行编程，即 学习CPU 为学习 操作系统增加了很多便利。即操作系统面向 CPU 进行编程，CPU 厂商指导操作系统开发。CPU 为了满足各类操作系统的开发，同一个事情肯定提供了好多种不同的实现方案，具体实现由OS开发者来决定



### Intel历史补充

【寄存器组】

状态寄存器就是用来指向跳转的指令的，跟图灵机里面的状态机有一定的相似之处。

指令地址寄存器就是指向当前正在执行的指令地址。

栈顶寄存器和栈底寄存器共同开辟了栈空间。

再复习一下总线总线有控制总线地址总线，还有数据总线。

控制总线就是用来表示控制谁，控制读还是写。地质总线指明我要控制的设备的哪一个地址，数据总线就是传输数据用的。



**真男人就该直接开始干Intel手册！！！**

简单的英特尔64和IA32架构的历史

以下这些节将会给我们一个主要的结论，从IA32到英特尔的64架构，我们从英特尔的8086处理器开始，直到我们的最新英特尔核心2duo，核心2和英特尔，X1on处理器5300和7300系列。早在1978年，处理程序的代码就已经写好了，他们在最新的英特尔64和 IA 32架构家族程序里面依然被使用。



#### 发展历程

【16位处理器和段，1978年】

 IA32架构家族里面有两个16位的寄存器，分别是8086和8088。

8086有16位寄存器，16位数据总线，有20位地址总线可以提供给一兆的地址寻址空间。8088与8086很类似，除了他有8位数据总线。（ External  Eight bit data bus， External是外部的）

数据总线的升级，可以带来更快的并行效率，可以同一时间传输更多的数据。

内存分段：8086和8088引入了“段”到IA32架构。有了这个段，一个16位的段寄存器，甚至可以指向内存地址有64位之大。在同一时间使用4个段寄存器8086和8088的程序，可以去寻址256KB，而不需要在段之间切换。

使用段寄存器和另外的16位的point，可以形成一个20位的地址总线，可以应用到1MB的地址寻址。（指令地址寄存器提供16位段，寄存器提供4位，一共是20位作为地址总线的寻址范围，可以寻址到1mb的大小）

【是怎么做到的？】

将断寄存器的位，也就是16进制左一位它就等于二进制左移4位可以提供4位的 bit, 而左16进制左移移位之后呢，那剩下的地方就是给，剩下为0的地方就是给指令地址寄存器用来存放它的偏移地址。

绝对地址就是鸡地址加上偏移地址，我们放到这里的指令地址寄存器和段寄存器就可以看到。

基地址（段寄存器的高4位也就是哪一段的首地址）加偏移地址（指令地址寄存器中的16位数据）

就好像我们的 int数组一样，我们首先是冲通过unsex的累，拿到每个单元他的这个单元的大小也就是4个字节。我们再去拿到数组下标的index索引，再去乘以我们的数组大小就可以得到值（偏移地址）再加上intel的首地址（数组变量的首地址）。



为什么8086~8088有这些变化呢？有一个原因是内存商家说我这里已经生产出来1MB的内存了，而现在16位地址总线也就是2的16次方和bat，只能寻址到64KB的空间，对于一兆币来说太小了，所以我们需要让现在的CPU支持一MB也就是2的20次方个byte，那么我们就需要20位的指令地址寄存器以及20位的地址总线。

那么我们寻址并不能改变原来的指令地址寄存器，所以我们保证原来的指令，寄地址寄存器大小为16 bit而另外加一个段寄存器也是16位，但是这两个加起来段寄存器提供4位，也就是16，16×64KB=1mb。

然后我们需要去维护段寄存器，那么段寄存器下面有站段寄存器数据段寄存器代码，段寄存器还有一些共享段呢？共享段不存在就叫做通用段计算器。

SS

DS

CS

其他S



16位的指令地址寄存器加上16位的段寄存器，我们就可以共同寻找到1MB的空间。





**【英特尔286处理器，1982年】**

在英特尔286处理器中引入了保护模式到IA32架构。



保护模式。使用断继存器。

保护模式使用段选择子和 gdd表来表示。

描述符提供了24位的基础地质，并且可以寻址物理地址达到16兆B，他

提供了虚拟内存管理，在 Segment swapping 并且有很多保护的机器，这些都包括在里面，断线制检查，断接线检查，指读和指运行段选择4个特权级。



段界限检查

只读和只运行段选项

4个特权级

（虽然有24位的地址总线，但是他是假的32位）



**【英特尔386处理器，1985年】**

英特尔386处理器是第1个32位处理器，在a32架构家族里。引入了32位寄存器，用来持有操作数和寻址。英特尔386寄存器低32位还保留着上一代16位寄存器的一些特性，允许向后兼容。（直接拿32位的低16位操作指令）。

处理器也提供一个虚拟的8086模式，当执行8086和8088处理器的程序时，提供更好的性能。（虽然我现在是32位机，但是只要我切换到虚拟的8086模式，我的所有组件对8086模式都是完全兼容的）



此外英特尔386处理器也支持以下的特性：

一个可以支持4GB物理内存的32位地址总线

一个分段内存模式和平坦内存模式

以4KB作为基准页数的分页，他为虚拟内存管理提供了一个方法。

支持并行阶段



**【英特尔486处理器，1989年】**

英特尔486处理器增加了更多的并行处理能力，通过拓展英特尔386的处理器的指令解码和执行单元到5个流水线阶段。每个并行处理的阶段操作都提升了，5个指令在不同的执行阶段。



此外处理器增加了以下特性：

增加了一个8KB的片上一级缓存，它可以增加每个时钟周期可执行的指令。

引入了x87 FPU，浮点运算单元

省电和系统管理工具





我们通过了解英特尔8086，8088，i286，i386，i486的历史我们可以知道。

提供了保护模式：

断界线检查，可读和可执行的选项，4个特权级

真32位机：寄存器地址总线均为真正的32位，4GB的空间。

并行执行流水线（指令流水线）

 CPU一级缓存，浮点运算单元

提供了分段机制

电源保护机制和系统管理工具

虚拟的8086和8088模式

内存模型（栈段计算器，代码段寄存器，数据段寄存器，通用段寄存器）



#### 芯片发展总结

| **年份** | **芯片**  | **特性**                                             |
| -------- | --------- | ---------------------------------------------------- |
| 1987     | 8086\8088 | 16bit分段寄存器                                      |
| 1982     | I286      | 24bitIA-32架构保护模式（段界限、只读段、特权级）     |
| 1985     | I386      | 真·32bit（16+16）4KB分页并行操作                     |
| 1989     | I486      | 8KB一级缓存X87 FPU（浮点运算单元）指令流水线省电模式 |







### 保护模式：

我们应该怎么对运行在内存中的程序提供保护功能呢？

不能让CPU拥有太大的权限

操作系统要完成他的操作，那么他就必须得控制CPU，那我们控制CPU就等于控制了计算机。操作系统就是帮你去操作硬件的系统。【很重要很重要。】

因为CPU可以控制所有，而操作系统控制CPU，如果我们不对它进行保护，那么就等同于我们的应用程序可以去控制操作系统，进而控制CPU，控制了整台计算机。



同样的在我们秒杀里面做的这个虚拟地址也是一样的，我们一开始给用户一个虚拟地址，用户就通过这个虚拟地址去访问我们的后台，拿到我们真实的抢购地址，这个socket，然后再把这个socket返回给用户，也就是把我们真实的地址发给用户。这个虚拟地址转化为真实地址是由服务器来做的。（ IP过滤）



#### 进程隔离是怎么做的呢？

首先给操作系统分一块区域，这块区域是操作系统，独享其他的进程不可访问的。而分配给每个进程的都是虚拟内存，真实的内存是每个进程所不能够访问到的，我们将虚拟内存分配到真实内存里面。

采用哈希表（类似）将不同进程之间的地址进行隔离，每个进程虽然都拿到了0~3G的所有的内存，并且将自己的站段数据段代码段都分配好了，但是我们映射到真实内存的时候，它只占用了一小部分，其中是利用了哈希表将不同的进程之间的地址进行隔离。

那我们对于每一个进程里面的操作系统是怎么让他不去侵入的呢？我们是通过划分特权及划分了0123特权级逐步降低来完成权限的分割的。首先操作系统有着最高的特权级应用，能访问到的地方是最低特权级。（ Linux只用了0和3，所以别的不用考虑，只用两位二进制就能进行区分）



下面看到我们是如何设计32位的CPU。

首先在设计32位的CPU的时候，我们已经知道了内存的大小为4GB，而4GB等于32次方个 Byte，所以32位CPU需要32位指令地址寄存器，必须要32位地址总线，所以I386就是这么设计的。



我们根据以上的知识可以推理到程序，

它的特权及保存在哪里？

当然是保存在我们的代码段计算器。程序执行的时候，CPU执行的是代码，没有代码，那么我们怎么去修改数据呢？所以这个程序的特权级一定是放在代码段寄存器里面的。

第2个问题在访问的时候需要有一个特权级的校验，这个校验位放在哪里？

段的描述符里面，（我们可以将段描述符看作是一个表，这个表保存了段的元数据信息）段描述符表， Global described table register. Gdtr表，全局段寄存器描述表。

#### 【什么是实模式、保护模式？】

实在模式也就是实际模式，就是直接操作物理地址的模式，就是通过直接指令地址寄存器加上段寄存器等于真实物理地址。

保护模式protective model，段寄存器查表加指令地址寄存器等于真实物理地址。



我们可以看到英特尔开发手册里面就有了，在2.4.2的最后图2-6（找不到那个版本了）内存管理寄存器可以看到这个段描述计算器是怎么分配的。

分段分页还有很多东西，现在都还没讲。断选择者再加上一个偏移量，偏移量就是IP，这些东西都没讲。别着急哟，大哥们。

flat memory model（扁平化内存模型）：就是段选择子（Segment selector）加上一个数据段描述符的偏移量，就直接等于线性地址空间。（所有的访问信息）



#### 虚拟内存

真实地址，虚拟地址

真实内存， 虚拟内存

OS管理映射、过滤请求、地址隔离

#### 特权级

奴隶咋翻身

特权级 + 段寄存器

设计32位的CPU时候，已经知道了内存的大小为4GB



1、程序的 **特权级** 保存在哪里？程序执行时候，CPU执行的是代码，没有代码怎么可能修改数据————》代码段R

2、在访问的时候，需要有一个特权级的校验，这个校验位放在哪里？**段的描述符**里面。



**实模式**：直接通过 **指令地址R + 段R == 真实物理地址**，去直接操作物理地址。
**保护模式**：段R 查表 + 指令地址R **== 真实物理地址。**



**模仿道友问问题：**

- 表有几个？物理内存有几个？1个
- 段的地址会不会越界？段界限检查
- 其他程序能访问对方的段吗？不能，各自都有自己的段界限
- 表谁放的？OS
- 表有多大？GDTR决定，首地址，界限
- 表占多大内存？GDTR表项长度 + 每一项的描述大小（查看手册里面就有）
- 表的首地址在哪？段界限检查



### Intel历史补充2

#### I286

The Intel 286 processor introduced **protected mode（保护模式）** operation into the IA-32 architecture. Protected mode uses the **segment register content as selectors（段寄存器作为一个选择子）** or pointers into **descriptor tables（段描述符表）**. Descriptors provide 24-bit base addresses with a physical memory size of up to 16 MBytes, support for virtual memory management on a segment swapping basis, and a number of protection mechanisms. These mechanisms include: 

• Segment limit checking

 • Read-only and execute-only segment options

 • Four privilege levels

译：

提供了保护模式。保护模式将 段寄存器 的内容作为一个选择子 或者 是一个指向段描述符的指针。

段描述符 提供了 24 bit 的基址，让物理内存寻址可达 16MB，并且支持 可交换的段 来实现 虚拟内存，以及多种保护机制：

1. 段界限检查
2. 只读和只执行 段选项
3. 4个特权级

I286只支持 最大 16 MB 的内存寻址，其中还有 24 位的段基址，16MB = 224  bit，所以该地址总线是 24位的。而段基址就是 24bit？已经可以完全表示了。

8086 和 8088 每次进行内存地址定位的时候，直接使用 指令地址寄存器 + 段寄存器的值 相加来得到内存地址，并直接进行操作，我们称这为 **实模式，实模式直接操作给定内存**，那会不会不小心或者恶意去更改掉其他程序 甚至是操作系统的数据和代码呢？该模式下系统是不安全的，是易碎的

所以为了让程序之间互不干扰，所以我们需要在获取指令时判断是否允许访问，推理下应该怎么处理呢？最简单的方法就是将各个应用程序进行隔离。怎么进行隔离呢？？？

我们可以类比一下 秒杀业务，在秒杀场景中，我们不能直接提供真实地址给用户，如果用户知道真实地址，提前使用程序进行不断的刷单，这样的话，那些没有使用程序的用户是很难抢到的，所以直接给用户真实地址这是不公平的。所以一般在秒杀业务中，都是给定一个虚拟地址给前端，当正式到抢购时间点时，才对真实地址进行调用

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652272646943-ab50d470-5d72-4e94-871d-9ac3c7dde48e.jpeg?tximg)

类比到我们的地址访问中，我们是否可以让应用程序得到一个虚拟地址，而不是真实的地址，然后通过一张表进行映射到真实地址上？这样每个程序都认为自己占有了整个内存，无法感知到其余应用程序的存在。 ------ 这就是 **虚拟内存**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652272608015-4035cd44-8412-4418-a90e-a04e465457f5.jpeg?tximg)

当我们需要访问内存时，CPU会先拿到 指令寄存器 中的值，然后通过查找映射表，得到映射表中存储的基址，然后加上 指令寄存器中的值，才能得到真实对应的内存。为了实现安全性，我们可以在该表中记录一些权限信息，**比如该段是只读or可执行、段的长度（避免越界）**....... 那么由此就实现了段界限检查 和 代码段的权限信息。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652273516952-bc49748c-ce21-4605-8ba5-fdfaf927e958.jpeg?tximg)

那么该表由谁来管理呢？  -----> 肯定是由 OS 和 CPU 来管理；既然要进行查表操作，肯定就需要知道表的存储位置，这个位置怎么知道呢？----> **使用一个寄存器来存放即可（GDTR：global descriptor tables register）**；用什么来查呢？通过手册我们知道此时的指令地址寄存器的位数已经可以对整个内存进行寻址了，那段寄存器还有用吗？当然有用了，我们可以用 段寄存器来记录要查找的表的下标索引。

#### 特权级

我们说，每个应用程序除了能感知到 OS 外，其余都认为自己独享，那么有没有可能程序去修改操作系统的代码呢？对于这个呢我们可以这样解决，应用程序给定 特权级，让特权级低的无法访问 和 修改特权级高的程序，而操作系统是一个特殊的程序，所以给定它最高的特权级，而其余所有的应用程序都给定最低特权级，这样便可以避免该情况的发生，保证 OS 的安全。

既然有特权级，那就必须要给定标记（将特权级存放在一个位置），那**程序的特权级存放在什么地方呢？---> 程序执行时，CPU 执行的是代码，没有代码哪来的特权级，所以 肯定是存放在 CS寄存器中的。		程序有了特权级，那被访问内容肯定也有一个特权集，用于比对，那该特权级又存放在何处呢？ ---->  在映射表中的元素中（段描述符）**

通过以上的推理过后，如果推理是对的的话，程序执行的过程将会是什么样的呢？首先通过段寄存器得到映射表的索引下标，然后通过存储映射表的寄存器获取到表的位置，而后拿到段的相关信息（包括段特权级，权限信息，基址，大小），然后进行校验，如果没问题的话，就将基址与指令寄存器中的值相加便得到真实的内存地址了。 -----> 通过 Intel 开发手册 验证

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652276737873-c03882ac-113a-4620-9133-c596b231a2af.png?tximg)





#### I386

The Intel386 processor was the **first 32-bit processor** in the IA-32 architecture family. It introduced 32-bit registers for use both to hold operands and for addressing. The lower half of each 32-bit Intel386 register retains the properties of the 16-bit registers of earlier generations, permitting backward compatibility（向后兼容）. The processor also provides a virtual-8086 mode that allows for even greater efficiency when executing programs created for 8086/8088 processors.

In addition, the Intel386 processor has support for:

 • A 32-bit address bus that supports up to **4-GBytes of physical memory** 

• A **segmented-memory model** and **a flat memory model** 

• **Paging**, with a fixed 4-KByte page size providing a method for virtual memory management 

• Support for parallel stages     ---------  支持并行执行

译：

I386是IA-32体系中第一个真正意义上的 32 位CPU，采用 32 位寄存器 操作操作数 以及 寻址，支持将 32 位寄存器切割为两个 16 位寄存器使用，从而实现向后兼容。并且还提供了虚拟 8086 模式，允许 之前的代码能够运行，并且运行效率更高一点。

1. 32位地址总线，支持 4GB 的内存寻址
2. 分段的内存模型 和 平坦内存模型
3. 分页机制，提供的 一种方法来管理虚拟内存以固定 4KB 的分页 
4. 支持指令并行





#### I486

The Intel486™ processor added more parallel execution capability by expanding the Intel386 processor’s instruction decode and execution units into **five pipelined stages**. Each stage operates in parallel with the others on up to five instructions in different stages of execution.

In addition, the processor added: • An 8-KByte on-chip first-level cache that increased the percent of instructions that could execute at the scalar rate of one per clock

• An integrated x87 FPU

 • Power saving and system management capabilities





### 最后的话

**小结一下，我们最近两章讲了些什么呢？**

主要就是讲了CPU里面的一些寄存器寄存器，有段寄存器代码段寄存器，数据段寄存器。然后讲了英特尔的一些历史，然后讲了8086~8088这里面的一些事情，8088是对8086的一个升级，8088支持1mb的寻址空间。 I286开始引入了段，有段我们推出了保护模式保护模式就涉及到断界线检查，4个特权级。 I386是一个真正的32位机，它可以兼容以前16位机的所有操作组件，并且他将地址空间可以拓展到4个GB。 I486就更加牛逼了，引入了一些并行阶段，还有指令流水线之类的操作，省电模式。

然后这里面我们对I286里面的段计算器还有GDP啊，这些基础的知识进入了进行了深入的推理。知道了什么是实际模式：指段寄存器里面的直加上指令地址寄存器的值就是真实的物理地址。保护模式是指令地址寄存器的值加上段寄存器查GDP表得到的地址，两个加起来就是我们真实的物理地址。



**推理验证**

我们不是要追求直接PPT给你全部东西粘出来就直接背就好了，很多东西，我们要回头看到原本的东西，然后自己去推理，从最简单的到顶层的到复杂的。如果直接拿上层的东西拿复杂的东西，那些名词全部丢出来，就了解那些名词，这是经不起推敲的。



推理加验证，我们推理完所有的知识，我们接下来就是对我们的知识进行验证！！！！！

不是直接就得了一个结论，直接拿了一个结论就背，这是没有任何作用的。推理推理推理推理完再验证是否正确。

我们必须要了解很多很多的基础的知识，才能继续往下走，才能走得更远。



## 1.14 内存管理

一定要记住自己当前的目标，是去验证之前的推理。

验证上一课 I386 等一系列处理器新增功能的推理，如 **虚拟内存、保护模式** 等 的实现。

### Intel手册——GDTR

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659968155518-05186f08-333a-41fd-9198-5e4dc6ce5354.png?tximg)

系统级架构包含了一些目的在于支持基础的系统及操作的指令及例如寄存器及数据结构和指令，例如内存管理中断和异常处理任务管理和多任务控制。

图2-1提供了一系列的系统计算器和数据结构，他们可以应用在32位模式。系统寄存器和数据结构应用到a32模式，在图2-2里面有写到。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659968499662-d60270cd-b91b-4205-a7ac-fc2d2acafc8b.png?tximg)

通过该图，**EFLAGS Register**是我们的状态位寄存器（intel的具体实现）。我们知道大致的访问流程，确实有 GDTR 找到段描述符表的始址，还有通过 **段选择子** 确定 **段描述符表**中的索引下标。



#### Global and Local Descriptor Tables

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659968800957-ced20ec7-b6fb-488c-90bf-541b0097571e.png?tximg)

当操作保护模式时,所有的访存都需要经过 GDT 或 LDT，这些表中的元素称为段描述符, 段描述符中记录了 段的 **段的基址，访问权限，类型 以及 使用信息**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004137853-6d6b4d86-6640-41a5-9a41-c31cb1aab9c6.png?tximg)

每个段描述符都有一个关联的段选择子。 段选择器为使用它的软件提供 GDT 或 LDT 的索引（**其关联段描述符的偏移量**）

访问段中的一个数据，我们必须**提供 段选择子 以及 偏移量**。段选择子用于提供对段描述符的访问权限，（全局描述表或者是局部描述表的）。从段描述符来看，处理器包含了段在物理地址的基地址。然后偏移地址提供字节相对于基地址的位置（base）。这种机制可以用来访问任何有效的代码，任何有效的数据或者栈段，前提是可以从处理器运行的当前特权级别访问该段。

**从以上可以推出：**

==》访问就需要拿到**段选择子** + 偏移量
==》基地址 + 偏移量
==》也就是从段描述符中，可以获得 **段基址**，offset 提供相对于基址的内存偏移量，所以 **真实物理内存地址 = 段基址 + offset 偏移量**。





#### GDTR-全局描述符表寄存器（※）

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004726002-e16871bb-abf1-4c0b-a171-74912db0560e.png?tximg)

一共48位，高32位表示表的始址，低16位表示表的大小界限



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004745870-a14f0e1d-ca17-4b9c-bbc8-ad0e7c854e5c.png?tximg)

GDTR保存了 GDT 的基址 以及 一个 16位的表界限。基址表示 GDT的首址的线性地址，table limit 表示这张表的大小.LDTR与我们没有关系。。。



**相关的指令操作：**

• LGDT (Load GDTR Register) — Loads the GDT base address and limit from memory into the GDTR register.   将 GDT 的信息 加载到 GDTR 寄存器中

• SGDT (Store GDTR Register) — Stores the GDT base address and limit from the GDTR register into memory  将 GDTR 中的信息存储到内存中

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652326367230-45545176-2173-429e-aced-01400fc3e839.png?tximg)



LGDT

SGDT



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089452472-249d2703-c61e-41af-b85c-3e990877cb62.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089471773-99113da9-62b4-45ba-bc5c-d8b8ced8d03a.png?tximg)



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089462396-57174660-1064-4ab0-a8ab-2076bc8fcb7c.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089483463-bab1b60e-51e2-400b-b72a-113a5e15cc2d.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089498935-4b5b23f2-a49d-4f55-9d0f-6d040a30216b.png?tximg)



#### 多段模式

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089515165-42306090-78fb-4947-adca-0805b81e3609.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089543730-96c67de7-679f-4895-b196-0f414b47a179.png?tximg)

每个段寄存器都需要到GDTR里面找到自己的位置，就是段的 Base Address + Limit ==> 最大地址，超过了就报错，Base Address是基地址，首地址。





### 权限

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004973204-9a0ff849-5e14-4d0b-bde0-b21765b2fbf3.png?tximg)

译： 处理器提供了一些指令，通过检查 段选择子 和 段描述符 来决定访问 与之相关的段是否是被允许的，这些指令其实是复制了一些有处理器自动处理的 访问权限 和 类型 检查



Each segment has a segment descriptor, which specifies the size of the segment, the access rights and privilege level for the segment, the segment type, and the location of the first byte of the segment in the linear address space (called the base address of the segment).

**每一个段都有一个对应的段描述符，该描述符表明了该段的长度，访问权限，该段的特权级，段类型，基址**
The base address plus the offset thus forms a linear address in the processor’s linear address space.

**段基址 + 偏移地址 = 线性地址**



**于此，上一小节的推理已经验证完毕**



**P 2873**







### 段选择器（段选择子）

#### 段描述符

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089590582-3bd7a903-ed9b-4a4b-b800-03d25a0a902a.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089583722-ca885fde-b2a4-46db-a711-474803000555.png?tximg)



#### 段选择子 与 段寄存器

之前我们说到，在进行查表的时候，将段寄存器给应用上，用段寄存器来存储 段描述符表中对应的下标索引值。我们将 存储该下标的部分称之为 段选择子。

### Segment Selectors

A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,but instead points to the segment descriptor that defines the segment. A segment selector contains the following items:

译：

段选择子是一个 段的 16位 标识，它并没有直接指向段，而是指向了 段相关信息的 段描述符，一个段描述符包含以下内容：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652340305274-76464344-1cc4-4eb1-9640-8a4b5e6acd74.png?tximg)

1. index
2. T、I flag
3. RPL





#### Segment Registers

To reduce address translation time and coding complexity, the processor provides registers for holding up to 6 segment selectors (see Figure 3-7). Each of these segment registers support a specific kind of memory reference (code, stack, or data). For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors. The processor also provides three additional data-segment registers (ES, FS, and GS), which can be used to make additional data segments available to the currently executing program (or task).

For a program to access a segment, the segment selector for the segment must have been loaded in one of the segment registers. So, although a system can define thousands of segments, only 6 can be available for immediate use. Other segments can be made available by loading their segment selectors into these registers during program execution.

译：

为了减少地址转换时间以及coding的复杂性，处理器提供了 6个段寄存器 来支持不同的内存引用。对于几乎全部的应用程序想要执行都必须至少需要 CS、DS、SS 加载有效的段选择子。处理器还提供了其他的 三个 段寄存器来使额外的数据段可用。

对于一个程序访问一个段，必须将段选择子加载到一个寄存器，所以尽管可以定义无数个段，但是能够供给使用的段寄存器也就只有 6 个。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660090867041-20a7e554-0bbc-42c9-872d-d3914ba8b308.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660090795171-0f1d1afe-d3fa-4b30-a7da-27e6ec7e196a.png?tximg)

译：

每个段寄存器都有一个“可见”部分和一个“隐藏”部分。 （隐藏部分有时被称为“描述符缓存”或“影子寄存器”，隐藏部分也会作为一个缓存使用。）当段选择器被加载到段寄存器的可见部分时，处理器也会将段寄存器的隐藏部分与段选择器指向的段描述符中的基地址、段限制和访问控制信息。缓存在段寄存器中的信息（可见和隐藏）允许处理器转换地址，而不需要额外的总线周期来读取基地址和段描述符的限制。（也就是段描述符中的信息，作为缓存就能够更快的进行地址转换了。）在多个处理器可以访问一个 描述符表时，当描述符表被修改时，软件有责任重新加载到段寄存器中。否则，旧项可能被使用。

注明：当可见部分被 load 时，处理器也会load 它的隐藏部分（包含- 基址、大小、访问控制信息 ）

有两种方式提供 加载段寄存器

1. 直接加载 的 指令：MOV......，这些指令显示的使用寄存器
2. 隐式调用：……，这些指令通过改变 CS 中的内容（一些情况下是改变其余的寄存器）是他们操作的一部分



## 1.15 特权级CPL RPL DPL

> 主要内容：段描述符、特权级校验
>
> 验证  GDTR 寄存器中的内容
>
> global segment descriptor table register 全局段描述符表寄存器



### 段描述符

A segment descriptor is a data structure in a GDT or LDT that provides the processor with **the size and location of a segment,** as well as **access control and status information**. Segment descriptors are typically **created by compilers, linkers, loaders, or the operating system or executive, but not application programs.** Figure 3-8 illustrates the general descriptor format for all types of segment d

escriptors.

译：

一个段描述符 是一个数据结构，保存了 段的基址、段的大小、访问控制信息、状态信息。

段描述符是由 编译器、链接器、装载器 或者 操作系统 创建的，而应用程序不能创建。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652347997963-6749177b-5887-4ba3-a6a7-039bc5897083.png?tximg)

1. L — 64-bit code segment (IA-32e mode only)
2. **DPL — Descriptor privilege level AVL — Available for use by system software**
3. **BASE — Segment base address**
4. D/B — Default operation size (0 = 16-bit segment; 1 = 32-bit segment)
5. G — Granularity （粒度，多大的大小）
6. LIMIT — Segment Limit 
7. **LIMIT — Segment Limit** 
8. **P — Segment present** （段是否在内存中，分页）
9. S — Descriptor type (0 = system; 1 = code or data) 
10. TYPE — Segment type



我们说这个表是可以由 操作系统填入的，那么我们瞅一瞅 Linux 系统中填入的 段描述符信息： 

```basic
.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */
.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */
```

其实我们将各个位置进行对位分析可以知道，所有的段都是从 0 位置到 最大地址 4GB 的，所以，可知 Linux 并没有使用分段机制

段描述符 + 指令地址寄存器 ==》 0 +  指令地址寄存器 =》 物理地址 =》 线性地址



### 特权级

#### DPL和RPL的解释（Priviliege level）

我们之前说过，需要保护操作系统，有推出特权级，特权级呢又需要进行保存，就像打标记一般，我们之前推测是放入到 **段描述符**中，由上面的图可以，正是这样实现的，通 过 DPL 表明当前段的特权级。因为其是段描述符中的，所以我们称之为 **DPL**

而与当前执行的指令的特权级又是放入到 段寄存器中的低两位的。表示当前请求的特权级（request），所以叫 **RPL**



#### R3-R0

虚拟化才会接触到R1、R2，正常开发使用不到这个级别的。

使用虚拟地址：保护进程之间

使用特权级：保护操作系统内核不受应用程序影响

general protection

用户态到内核态 == R3到R0（网关带你去访问R0）



#### 通过手册来查看 特权级信息

The processor uses privilege levels to prevent a program or task operating at a lesser privilege level from accessing a segment with a greater privilege, except under controlled situations. When the processor detects a privilege level violation, it generates a **general-protection exception** (#GP).

译文：

处理器使用特权级别来防止在较低特权级别上运行的程序或任务访问具有较高特权的段，但受控情况除外。当处理器检测到特权级别冲突时，它会生成一个通用保护异常(# gp)。



#### CPL、RPL、DPL

To carry out privilege-level checks between code segments and data segments, the processor recognizes the following three types of privilege levels:

1. **Current privilege level (CPL)**：The CPL is the privilege level of the **currently executing program or task.** It is **stored in bits 0 and 1 of the CS and SS segment registers.** Normally, the CPL is equal to the privilege level of the code segment from which instructions are being fetched.The processor changes the CPL when program control is transferred to a code segment with a different privilege level. The CPL is treated slightly differently when accessing **conforming code segments.** Conforming code segments can be accessed from any privilege level that is **equal to or numerically greater (less privileged) than the DPL of the conforming code segment.** Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.
2. Descriptor privilege level (DPL)：The DPL is the privilege level of a segment or gate. It is stored in the DPL field of the segment or gate descriptor for the segment or gate.When the currently executing code segment attempts to access a segment or gate, the DPL of the segment or gate is compared to the CPL and RPL of the segment or gate selector (as described later in this section). 		
3. Requested privilege level (RPL)：The RPL is an override privilege level that is assigned to segment selectors. It is stored in bits 0 and 1 of the segment selector.

译文：

要在代码段和数据段之间执行特权级别检查，需要处理或识别以下三种类型的特权级别:



通过翻译，我们可以总结：

1. CPL：当前执行的程序或任务的 特权级，存储在 CS 和 SS 寄存器中，一般情况下， CPL 的值是与从 段描述符表中拉出来的段描述符 中的 特权级相等的 ----> DPL。当程序控制转移到不同的特权级上执行，会改变 CPL 的值，在一致性代码防存过程中，可以接受 ring 值 >= DPL 的访问，但是在这个过程中，CPL不改变。（如果改变了那它的ring 就会变小，访问到一些不该访问的内存）
2. DPL：是段的特权级，存储在段描述符中，当有代码段尝试访问该段时，会将 被访问段的 DPL 与 CPL 和 RPL 进行比对，判断是否可以访问，判断的具体规则根据不同的类型有不同的规则
3. RPL：存放在 段选择子 的 低两位处



一致性代码：必须一样才能访问，只允许一致的代码访问

非一致性代码：兼容性比较好，只要比他的特权级小或者等于都能够访问。



**因为段选择器中存放了 RPL，而在 CS 和 SS 中有是存放的 CPL，所以在 CS 和 SS 寄存器中，这个 RPL 被称为 CPL，所以 CPL 是 RPL 的一个特例，CPU 会将其视为当前执行程序的特权级。**



#### 比对规则：

— **Data segment** — The DPL indicates the numerically highest privilege level that a program or task can have to be allowed to access the segment. For example, if the DPL of a data segment is 1, only programs running at a CPL of 0 or 1 can access the segment.

— **Nonconforming code segment (without using a call gate)** — The DPL indicates the privilege level that a program or task must be at to access the segment. For example, if the DPL of a nonconforming code segment is 0, only programs running at a CPL of 0 can access the segment.

— **Call gate** — The DPL indicates the numerically highest privilege level that the currently executing program or task can be at and still be able to access the call gate. (This is the same access rule as for a data segment.)

— **Conforming code segment and nonconforming code segment accessed through a call gate** — The DPL indicates the numerically lowest privilege level that a program or task can have to be allowed to access the segment. For example, if the DPL of a conforming code segment is 2, programs running at a CPL of 0 or 1 cannot access the segment.

译：

1. 数据段：只有特权级高于或等于 DPL 的才能访问（ring 相对小于等于 就 可以访问 eg：DPL = 1， 那么只有 CPL = 1 或 0 的才能访问）
2. 非一致性代码段（在没有使用 call gate 时）：表示必须达到该级别才能访问
3. call gate：与数据段相同
4. 一致性代码 和非一致性代码通过 call gate：只要特权级低于或等于 DPL 即可访问（注意：是 ring 值 >= DPL）



**如果 RPL 的数值大于CPL，那么 RPL会覆盖 CPL，RPL可用于确保特权代码不会代表应用程序访问某个段，除非该程序本身对该段具有访问权限**



Privilege levels are checked when the segment selector of a segment descriptor is loaded into a segment register. The checks used for data access differ from those used for transfers of program control among code segments; 

**当段描述符的段选择器加载到段寄存器时，会检查特权级别**。用于数据访问的检查与用于在代码段之间传输程序控制的检查不同；



### 数据段的检查

To access operands in a data segment, the segment selector for the data segment must be loaded into the datasegment registers (DS, ES, FS, or GS) or into the stack-segment register (SS). (Segment registers can be loaded with the MOV, POP, LDS, LES, LFS, LGS, and LSS instructions.)

 Before the processor loads a segment selector into a segment register, it performs a privilege check (see Figure 5-4) by comparing the privilege levels of the currently running program or task (the CPL), the RPL of the segment selector, and the DPL of the segment’s segment descriptor. The processor loads the segment selector into the segment register if the DPL is numerically greater than or equal to both the CPL and the RPL. Otherwise, a general-protection fault is generated and the segment register is not loaded.

译： 在数据段访问操作数时，数据段的段选择子必须加载到数据寄存器中（DS，以及其他段寄存器）或者 栈段寄存器中。

在处理器将段选择子加载到段寄存器中之前，它会先比较 CPL（当前执行的程序的特权级）、RPL（段选择子中的值）、DPL（段描述符中的值）来做权限校验。如果 DPL 的ring值高于 max（CPL,RPL）就将段描述符加载到段寄存器中，否则就会加载失败，产生 通用保护故障

总结：return DPL >= MAX(CPL, RPL)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660227323370-052495af-f8e9-4fa3-b144-981fa7fee27b.png?tximg)



### 代码段的检查



#### 非一致性代码

When accessing **nonconforming code segments**, the **CPL of the calling procedure must be equal to the DPL of the destination code segment;** otherwise, the processor generates a **general-protection exception (#GP).** For example in Figure 5-7: 

• Code segment C is a nonconforming code segment. A procedure in code segment A can call a procedure in code segment C (using segment selector C1) because **they are at the same privilege level** (CPL of code segment A is equal to the DPL of code segment C).

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652360888407-b5c6e71c-4a77-4877-a80f-3f446caac81d.png?tximg)

• A procedure in code segment B cannot call a procedure in code segment C (using segment selector C2 or C1) because the two code segments are at different privilege levels.

**总结：必须 三者相同才能访问**



#### 一致性代码

When accessing conforming code segments, **the CPL of the calling procedure may be numerically equal to or greater than (less privileged) the DPL of the destination code segment;** the processor generates a general-protection exception (#GP) only if the CPL is less than the DPL. (**The segment selector RPL for the destination code segment is not checked if the segment is a conforming code segment.**) 

**当访问一致性代码时, CPL 的值应该大于等于 DPL 的值, 否则就会产生 GP 异常,  (当访问的目标代码段是一致性代码时，段选择子中的 RPL 不会使用)**

In the example in Figure 5-7, code segment D is a conforming code segment. Therefore, calling procedures in both code segment A and B can access code segment D (using either segment selector D1 or D2, respectively), because they both have CPLs that are greater than or equal to the DPL of the conforming code segment.

 **For conforming code segments, the DPL represents the numerically lowest privilege level that a calling procedure may be at to successfully make a call to the code segment.**

**对于 一致性代码段，DPL 表示能访问的最低特权级**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652361419309-556f9b4a-999a-4994-89ff-2d68e4fa7f0f.png?tximg)

总结：当前特权级  CPL  ring >= 目标代码段，不检查 RPL

既然我们说应用程序无法访问内核的代码，那么一些需要调用的内核代码时怎么进行调用呢？增加一个 gate，实现系统调用。



## 1.16 CPL、DPL、RPL

### CPL  DPL  RPL 重新整理

在程序运行中，我们如果不对其进行限制，就可能会造成一个程序去访问和修改另一个程序甚至是操作系统。所以我们需要对程序进行限制，限制当前程序是否可以访问内存中的各个位置的信息。

CPU 执行的是一条一条的指令，我们只需要对指令进行控制，就能够控制数据了。而指令是通过代码段寄存器（CS） + 指令地址寄存器 来获得指令的线性地址的，所以我们就将 CS 寄存器 中的低两位用于表示当前CPU执行的指令特权级，即 CPL （current privilege level）。除此之外，堆栈中由于是存放的当前指令流私有的数据，所以也可以代表当前指令流的指令特权级，所以 CS 以及 SS 中的低两位都是代表了 CPL

即使我有了当前的特权级，按理说应该可以访问比当前特权级低的所有（ring值更大的所有值），这样的话就有可能会造成一些错误的访问，比如我在 ring 0，想要去访问一个 ring 3 的数据，结果却错误的访问到了其他ring 0 的值，所以我们需要一个特权级来表明我们需要访问请求的特权级是多少，而请求的内容可以是各个方面的，但是都是需要通过段寄存器来查表，所以将段寄存器的低两位用来标识 请求的特权级 即 RPL（request privilege level）

既然我们有了当前CPU执行的指令所处了特权级，也有了避免误操作的代表请求的特权级，那我们就可以去查找数据了，查出中怎么确定是否有权利进行访问呢，就需要与数据本身的特权级进行对比，那数据本身的特权级我们存放在哪儿呢？因为我们定位内存地址时，都是要在段描述符表中找到段描述符后才能得到准确段基址，所以就将数据的特权级存放在段描述符中，称为DPL（descriptor privilege level）与CPL和RPL共同决定是否允许将段描述符的内容取出。



 第1期第16节。
因为上一节的CP ldpl和rp L讲的逻辑有点混乱，所以这又重新讲一下这三者的关系。

首先当我们的CPU权限不够的时候，我们可以借助门将特权集为3的，变成0，然后就可以访问dpl为0的数据了。

设置特权级是为了隔离操作系统和应用程序
CPU执行的指令，那么操作数据而不是指令，我们要对指令进行控制，我们要控制了指令就可以控制数据，而CS代码段，寄存器它用于查表查GD，T表舅可以得到我们的断机制，然后我们使用段基址加上指令寄存器我们就可以得到线性地址，那么我们使用段寄存器的后两位来表示特权级，也就是我们的cpl current。It's cute pl也就是我们当前CPU正在执行的指令流的特权级。

设置 Gdtr表主要是为了隔离不同的应用程序
数据是不是需要我们的指令来操控啊？那必然是如果没有指令的话，那么我们有很多数据都是没有用的，数据要访问同样是需要去查我们的表的，因为需要隔离不同的应用程序，将它们使用虚拟的内存空间来进行隔离，得到的就是数据段数据段的表的 index存在于DS寄存器中，那么这时候就需要有一个特权机来表示我当前需要请求的数据的权限应该是什么？ Request pl， Rpl.

每个段计算器叉S的后两位都可以称为rpg，换个角度来考虑，对于CS计算器而言，它请求的是CPU去访问某个段的指令，所以他就是ipl，而所有的一切都来源于CPU对指令的执行，所以从这个角度来说，它就代表了当前CPU执行的pl，所以就将 CS的ipl特定为此场景的cpl。（我虽然是请求他的，但是我就是此场景的请求者）

为什么SS后两位也被特别指定为cpl？
SS指向了堆栈段（其实这个堆栈段它就是站段，它里面全都是站，只是分出来一段空间用来将它作为栈）堆栈用于存储指令流之间的私有数据。既然CPI代表了当前执行的指令，而堆栈又是保存了这些指定操作的中间结果。 SS和CS后两位的rpl特例为CPl.

Dplrplcpl之间如何进行比较CPU最大吗？是的，因为CS和SS代表了当前 CPU执行的指令，所以当前执行的特权级必定高于，对于数据的请求DS等等寄存器cpl的权力大于rpl也就是cpl=3的时候，我的rpl就不能够小于3，因为CPU当前执行的指令决定了你当前的特权及cpl，rpl最终是要与dpl做对比。

CPL才是主要的，dpl是次要的。



### 分段 到 分页 优缺点分析

下面讲到分段分页机制。
P标志。
表明了这个段在不在内存中，如果在的话设为1，如果不在的话就清除。如果标志未被清除，这个处理器就会生成一个断不存在异常【NP】当段玄者指向他的时候，内存管理软件也就是我们的os，可以用这个标志为去控制段纯到物理地址。将我们换出去的物理页面换回来。
其实就是我们的操作系统内存不够了，然后需要把操作系统内存里面的东西把它放到物理磁盘里，物理磁盘当我们需要的时候，再从物理磁盘里面把数据拿出来。
这种机制之下就会造成很多内存外碎片，我一换我就要将整个战段给它换回来数据，段整个数据段，换回来代码段整个代码段换回来，一换就要换一坨代码，换一坨数据，非常的浪费io。（大并且不规整）
那么我们就将4GB切成4KB，以4KB的大小进行切分。数据栈代码段全部打散。
页帧，
页表：构建映射关系，线性地址与真实的物理地址之间的映射关系。（小并且规整）





### 流水线

历史

寄存器

书

最后到——》汇编

C语言通吃

