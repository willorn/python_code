

# 第二章 编译原理



## 1.4 步入抽象语言

汇编是啥？为什么需要汇编语言？

编译是什么过程？

编译原理又是啥？

### 汇编语言

虽然相比于机器语言，汇编语言对人类来说更具有易读性，但实际让广大码农编写是很困难的。
所以这时候我们需要将汇编语言抽象化，抽象为更加贴近为人类使用的语言。
其实汇编语言不太难，汇编语言其实只是机器码的一一映射而已，就类似于哈希表的kv。
汇编指令分为操作码和操作数。其中操作码是我要做的动作，比如说加减乘除。操作数就是1+1中的1，我们操作的对象。

接下来我们要探讨的第二个问题是什么是汇编。
汇编语言也有简单的常量定义系统，汇编主要是对内存进行操作的语言。
内存话，我们就要先考虑一下内存的大小，为什么基础的存储单元大小是八？而不是其他呢？因为布尔兹或者恰类型的值都是以八位作为最小的。如果说我们把这个基础单元，基础存储单元的大小定为16的话，那么我们存储一个布尔值或者一个类型的数字就需要传递，一个16位的大小，这样必然会造成浪费。所以我们采用八作为。基础存储单元的大小，这个基础存储单元的大小呢也必须得是小于寄存器的大小的。
内存主要分为sram，dram和rom。SRAM是有四五个晶体管组成一个寄存器，是造价最贵的。DRAM是由电容组成的造价比sram来说更便宜。Rom是最便宜的，它的材料可以是多样的。
所以我们知道汇编语言是一个什么东西了，汇编语言实际上就是一种规则。一种将用户的信息转化为机器语言信息的规则。
但是我们认为这种规则还不够完善，我们应该开发抽象出更高级的规则。让机器帮我们干更多的事，让机器可以更容易理解我们人类能理解的语言。

### 语言特性

所以我们就需要去构造一种高级语言，C语言就是我们所熟知的一种高级很纯粹的高级语言。

我们要定义一种语言，首先我们要去关注类型，数据类型是什么？第二个就是我们要去抽象操作，简化汇编语言中的add，MV等等指定。汇编指令第三点是我们要基于高级语言的特性，开发出更强大的功能。
于是我们将更高级的语言开发出来了，我们要对这种语言进行实现。实现就是用的是编译器，编译器，这最开始当然是由汇编语言写成的编译器。然后编译器加汇编器就是我们所熟知的即时编译器



C语言就是比较纯粹的汇编语言的抽象。

### 编译原理

编译就是将高级语言翻译成汇编语言或者是机器语言的过程。翻译是没有中间过程，而编译有中间过程。
例如java语言就是先把java程序编译为字节码，再将字写码翻译为机器语言。

#### 总结：

编译：翻译，将抽象的东西翻译为具体的汇编代码，最后再经过编译变为机器码。

汇编：将很多的ISA指令汇聚到一起，然后对这堆ISA指令进行统一抽象，汇编语言就是一串ISA指令集。







## 1.5 抽象语法树 graalvm llvm

本节课重点在**数据结构和算法**如何演变，由此二种最简单的元素（阴阳）生出万种程序

以及信息的转换过程，编译语言的前端到后端中**中间产物(IR)**的必要性

> 问一下：
> 编译的流程是什么？编译过程都有哪些状态？

### 编译原理推理

> 语言转换的过程

**人类**

人类翻译的过程：有许多单个的词语和语法加在一起就组成了source，我们把source解析出来的信息称为语义（中间产物），再将中间产物转换为输出信息，即是由多个单词和语法加在一起的句子。

**程序**

 无非是一种形式的信息转换为另外一种形式的信息。他们本质都是信息。但是这里需要注意一种信息能够包含万物，如果信息本质有缺陷的话，就会导致信息的遗漏



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651395599606-2081e86c-9fda-4492-b2d7-2c8065b87002.png?tximg)





#### 汇编结构：



C语言是汇编语言的抽象
阳即为多变即为动，阴即为少变即为静
有时间可以去看看《易经真的很容易》这一本书
六位老阴，九为老阳

算法是语言的底层，任何的上层语言都可以套用相同的算法
共有六个步骤，记忆，理解，应用，分析，评估，创造
学到做人做事的道理

### 抽象语法树AST推理



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651393970844-9b28cd4a-7170-4d61-bd9f-9f42cc5e4454.png?tximg)



从VM也能看出来类似的道理

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1656837563092-7b5834ba-6d0b-418f-ab3d-f95b1dc94d70.png?tximg)

### GraalVM与llvm

后端逻辑不变，让处于上层的按一定规则转换成 中间产物，即可实现对多种语言的支持

GraalVM 提供了能让多种语言在 VM 上运行的功能，从而实现 让其他语言共同享有 JVM 的 GC，跨平台、即时编译 等高级特性

邓俊辉 清华大学《数据结构（C++语言版）》

说了要在LLVM里面讲一下ebpf，直接带入到代码层面了。(看不懂)

最后在emit、code_section这里带过了一下



这节课最重要的难道不是数据结构和算法如何演变的么？而最后那个编译原理推导出前端，如何产生中间语言，后端如何解析中间语言给计算机运算，推导出jvm的编译原理。具体的实现明天的课老师会说……我看大家都讨论明天的课程了



## 1.6 深入到编译器：LLVM

> 为什么需要抽象语法树？
>
> LLVM-GCC前端/GCC前端-插件-》IR -》 LLVM后端 -》 机器语言(ISA)
>
> GCC到LLVM（GraalVM沾点边）
>
> 《LLVM编译器实战》流程



语言的编译器：
语言-【前端-中间产物-后端】-ISA



### LLVM vs GCC

LLVM本来是底层的虚拟机，没想到最后变成了这样的庞然大物。。。

#### LLVM的历史

故事过程：苹果想要搞 GCC 的人帮忙对 GCC 对于 **Object-C/Swift** 的编译做优化，但是被拒绝了。而此时，有一个群人正在 研究 LLVM 编译器，苹果抓住了这根稻草，聘请过来开发自己的编译器。最初只是做了编译器后端部分，前端部分还是使用的GCC的，编译器前端则是对GCC做了拓展，叫做LLVM-GCC。随着发展，LLVM的编译器前端也做好了，也就是最初的C-Lang。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1656840430061-09dad508-5032-4cdf-95c8-051734b98d89.png?tximg)





#### 比较

**GCC：**	1987年5月23日

- 并未根据模块儿化开发，所有的层级调用都在一起。
- 单一庞大的结构
- 所有的代码都是放入同一个包内，所以代码的及其难以阅读，以及维护。所以 很多程序员会对此开源的好奇心都难以维持。



**LLVM**：   2000年

- C++写的

- 模块化开发，解耦设计，前端后端以及中间产物都是分开的。
- 前后端所有的接口都支持热插拔。
- 一切组件均可单独使用，全部流程均可使用插件机制进行配置选择，全部模块化。



#### 启示

如果我们想要踏足的领域已经存在了一些产品，此时我们想要让我们的产品能够有竞争力，有优势，那就需要即能包含已经存在的产品的功能，并且还要在此基础上**有新的特性**（不然别人凭啥用你的？）

**所以我们在学习新的技术时，可以基于对现有技术的了解程度 + 新特性 来进行学习（技术工具是一条曲线）**

**由图：****一切语言的特性均以编译器来设计。**



所以，新推出的产品，包含功能是必定的，毕竟大家都是编译器，在此之上，完善上个产品的缺陷，所以将整个开发都坚持模块化开发。这样不论是可读性 还是维护性上都是完全优于 GCC 的，**由于模块化开发，一切模块均可热插拔,可以通过插件方式进行配置 -----> 可以高度定制化 -----> 开源后, 其余语言均可按照模块化的机制进行接入**



### EBPF 推理

**过滤器** ~ 贝克利包过滤器filter ~ Extend-BPF



#### OS与APP模型~类比

操作系统其实是一个程序，应用程序 和 操作系统 是分层级调用的，中间需要通过协议进行调用，完全可以类比到 客户端和服务端的程序。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651208045825-d7a53ba0-34cf-4aa9-b5b9-2e7aacbaa29a.jpeg?tximg)



我们先想这样一个需求，在网络请求过程中，客户端（浏览器）需要服务端的结果信息，但是需要过滤掉其中的一些部分（过滤的部分每个客户端有自己的需求）。

**分析：**

1. **如果我们在客户端进行过滤的话，也就是说所有的信息一并发出，由客户端选择丢弃还是接收，那么这就会导致浪费大量的网络IO，并且性能下降**
2. **那我们就得在服务端进行数据的过滤操作了。但是还是存在问题，浏览器客户端千千万，每个的规则都有可能不一样，这压根就没法做.....**
3. **所以我们需要客户端将自己的需求给发送到服务端，由服务端处理。**

**精简传过来的东西，只拿有用的。所以能不能使用一个通用的IR，中间语言来传递信息。**

**处理过程：**

**由于逻辑不是服务端所确定的，需要客户端来决定，所以判断逻辑的代码服务端是无法编写的，所以就需要客户端编写自己对于数据是否接收的逻辑**

**客户端则是灵活的，可以是浏览器，可以是 android 可以是 IOS，所选择的开发语言可能不同，所以我们需要一个东西来执行多种语言开发的判断逻辑语句，****一个东西对多个开发语言进行兼容****，这不就是我们说的 LLVM 嘛**

**也就是说，客户端传送自身开发语言 通过 LLVM 的前端编译器 生成的** **IR** **到服务端，服务端通过集成 LLVM 的后端编译器，就可以实现对不同语言进行解析执行了。**

也就成了这样：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651210785678-7c7bdfd2-5982-4605-a608-5d54ae974949.jpeg?tximg)

由此我们类比到操作系统中，上层应用程序需要操作系统帮忙处理IO（包括网卡 和 磁盘），读取数据，搬运到用户空间，假设应用程序也对要对所获取的数据进行过滤，那该如何做呢？

**分析：**

1. **首先我们想到的肯定是  OS：关我屁事，我直接全部发给你，爱要不要，前面也说过，这会因为锅多的IO导致性能的下降**
2. **应用程序肯定也不能直接控制 OS让他发什么不发什么，而OS自然也不知道上层应用程序需要什么不需要什么**
3. **所以需要 应用程序 和 操作系统 之间存在沟通**



#### EBPF是怎么做的

**处理过程：**

1. **应用程序根据自己的逻辑规则编写语句，通过 相应的 LLVM前端编译器****生成 IR 发送给操作系统**
2. **操作系统通过** **EBPF集成的 LLVM后端编译器 对IR 进行编译**
3. **数据到来时便会先 执行 EBPF 中对应的 判断语句，决定是否发出**



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651210590846-69a94730-0d9e-42eb-b6d5-00142e5f93a1.jpeg?tximg)



我们知道，想要在 Linux 中添加新的功能，Linus 是极小极小极小概率会让你进行添加的，更别说你想往内核代码中添加 一个虚拟机了。

假设你真的完成了这伟大的创举，那么我们不妨对该 VM 做更多的扩展空间，所以 EBPF  （扩展 BPF）就出现了，Extend BPF=》 EBPF=》 BPF。



最后，百度词条

BPF全称是「Berkeley Packet Filter」，翻译过来是「伯克利包过滤器」，顾名思义，它是在伯克利大学诞生的，1992年Steven McCanne和Van Jacobson写了一篇论文：《The BSD Packet Filter: A New Architecture for User-level Packet Capture》，第一次提出了BPF技术，在文中，**作者描述了他们如何在Unix内核实现网络数据包过滤，**这种新的技术比当时最先进的数据包过滤技术快20倍。



#### LLVM与EPB的关系

LLVM的中间语言

BPF VM 是基于 LLVM 来做的



### 语言特性

众所周知，每一个语言其实都有自己规定的一套标准，不然大家使用的都不一样，就乱套了。如果我们想要在现有的标准下进行扩展一些新特性是否可以呢？

编译器后端只需要得到一个IR即可，所以只要编译器的前端能够生成符合的IR即可。就好比我们使用的语法糖的存在，就是编译器前端部分负责转化成符合编译器后端的IR。所以只要编译器能够识别，代码就可以按照这个标准来写。

所以对于 C而言有` C标准：ANSI C `

而后又有 ` GCC：全名叫 GNU C Compiler`，是GNU计划诞生的C语言编译器

`ANSI C` 就是标准，而 `GNU C` 是对其的一个向下扩展

**所以，一个语言的特性，都是基于编译器来设计。**





### 《LLVM编译器实战》前言



LLVM是始于学校项目，开源的魅力。



【待补LLVM书籍内容】





**混沌视角：**

计算机理论中一个简洁明了的概念可能涉及多层级的实现细节，这些细节使得现实中的软件项目辩的复杂而无法让人们掌握，特别是其所有微妙之处。巧妙的抽象涉及能帮人类大脑掌握项目所有层面的关键：从高级的视图（抽象意义下程序实现和工作方式）到最底层级的细节。



GCC链接器：GCC太强大了

LLVM糅合了GCC

他们俩的关系就像是wps和office……



pipline、chanel

链接、重定位、ebpf





## 1.7 解释器与JIT

> **深入编译原理**
>
> 名词推理、知道（推理）
>
> 先有道，然后再去追求术
>
> 编译、即时编译器JIT、解释器的区别是什么？



### 抽象语法树AST详解



#### 雨露均沾学习法

强干弱枝

学术会很痛苦，苦一个月就好了

避免痛苦：每一个主干往下学习 3，4 个节点，别往深的学习，不然很痛苦，而且人脑记忆是有限的

枝繁叶茂之后，多个主干都学习了3~4个节点的时候，就会发现很多可以**共享的模块**



#### 编译~给机器人翻译

编译的过程：

- 首先我们是拿到**A语言的句子**，对他进行词法分析，得到词语和词性；
- 再对这些**词语和词性**进行语法分析，就可以得到这个句子的抽象语法树（AST）；
- 对**抽象语法树**进行语义分析就得到**中间产物**（IR：就是我们每个人对这个句子自己的理解）；
- 我们对自己的理解进行翻译(重新编码)就得到了**B语言的句子**



#### 编译器

编译器就是把语言编译为语言，编译器实现编译原理的前后端成一套
T即时编译器也实现了编译员里的前端和后端，不过他是在内存里面进行编译的，大概内容就是它可以将一些重复解释的代码进行编译。提前编译为机器码，保存在内存中。加快解释的速度
解释器就是用一门语言对其他语言进行解释执行逻辑

 

### 插曲：

最后就是讲了一下术：hotspot里面找Java调用方法

触发事件，开始编译

追求道就是大致知道里面有个什么东西，是谁触发这个替换的操作？这里面大概有几部流程？ 不要问这是什么？这是什么？


一上源码，全部懵逼！

没法看，还需要补充一些C++的东西

分支断层。资本、money



## 1.8 LLVM与BPF

汇编和编译的整体工具链

> 解释器？JIT
>
> GCC是什么
>
> BPF = LLVM + JIT内核网络包过滤器
>
> 编译器有哪些？
>
> LLVM和GraalVM想干啥？



### GCC历史



### 开始



https://zhuanlan.zhihu.com/p/70949843

#### 汇编器

*读汇编语言，转换为机器语言*

最开始计算机只能执行01代码，所以只能人工写01代码，为了节省时间，发明了汇编语言。

（能够把人们可以读懂的“菜谱”一样的输入转换成计算机可以读懂的版本）

人类写汇编代码，经过汇编器转换为机器语言（ISA）给CPU去控制计算机硬件，得到结果返回给用户。



#### 编译器

*读高级语言，转机器指令中间可以优化，处理好了的机器语言打包放那里。*

～编译就是翻译的意思，这是计算机世界的翻译官

把用高级语言写的程序转换成汇编语言，再使用汇编器把汇编语言转换成机器可读的程序。这种程序组合常常被称为“工具链”，因为一个程序的输出就直接成为另一个程序的输入。



#### 解释器

*读取脚本语言，立即执行。*

直接读取一个程序将其转换成计算机指令以立即执行。和编译器差不多，解释器读取程序并将它转换成一个中间形态。但和编译器不同的是，解释器直接执行程序的这个中间形态。解释型语言在每一次执行的时候都要经历这个过程；而编译程序只需要编译一次，之后计算机每次只需要执行编译好的机器指令就可以了。



#### 虚拟机VM：

*先将程序编译成一个中间形态，然后虚拟机再执行这个中间形态。*



### 升级了

JIT：

将字节码编译成可以由处理器运行的机器码（ISA），并且比javac更复杂，因为提供了代码优化



GCC

***what\****：*[*GNU*](https://baike.baidu.com/item/GNU/671972) *Compiler Collection，*[*GNU编译器*](https://baike.baidu.com/item/GNU编译器/10444865)*套件，是由GNU开发的编程语言译器。*

**why**：GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。（然而最后合并到Linux里面去了）

原始版本使用Pastel语言开发，第一个成熟的版本是用C开发，后来因为[LLVM](https://zh.m.wikipedia.org/wiki/LLVM)、[Clang](https://zh.m.wikipedia.org/wiki/Clang)的崛起，它更快地将开发语言转换为C++。

最开始支持C语言，后来逐渐支持更多的语言。GNU编译器套件包括C、[C++](https://baike.baidu.com/item/C%2B%2B/99272)、 [Objective-C](https://baike.baidu.com/item/Objective-C/8374012)、 [Fortran](https://baike.baidu.com/item/Fortran/674319)、[Java](https://baike.baidu.com/item/Java/85979)、[Ada](https://baike.baidu.com/item/Ada/5606819)和[Go](https://baike.baidu.com/item/Go/953521)语言前端，也包括了这些语言的库（如libstdc++，libgcj等。）





#### LLVM



#### Graalvm

- 高性能
- 云原生cloud native（简单理解：代码直接4
- 面向云端）
- 支持多语言，同一程序混合多门语言



k8s就是云原生？

Java只需要考虑代码逻辑CRUD，其他的都不需要考虑。（熔断限流都在一个地方考虑



为什么不给所有语言都先弄个前端，生成中间产物，只需要做个后端就可以处理中间产物（字节码）？

因为保留了原有语言的特性，eg：C语言保留了快速的特性；Java语言直接编译为机器码；



Java on Truffle





![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1651633909818-2c7b392f-4b10-42b9-8fd1-f0ace9e78730.jpeg?tximg)





GCC：GNU compiler collection

设计最初就是为了C语言



BPF：

即时编译器 + LLVM





搜索：

GCC



#### LLVM和GraalVM想干啥？

hotspot虚拟机：包含模板解释器，还有JIT：C1、C2、Graal



LLVM：**一统编译器**

1. 源语言--LLVM-->目标平台代码。可插拔



GraalVM：**一统虚拟机，**虚拟机霸主

1. JS、python、ruby



官网https://www.graalvm.org/22.2/docs/introduction/



### 《LLVM实战》前言





**混沌视角：**

**计算机理论中一个简洁明了的概念可能涉及多层级的实现细节，这些细节使得现实中的软件项目辩的复杂而无法让人们掌握，特别是其所有微妙之处。巧妙的抽象涉及能帮人类大脑掌握项目所有层面的关键：从高级的视图（抽象意义下程序实现和工作方式）到最底层级的细节**

**从最纯粹的的意义上说，软件项目反应的是其创建者的观点，这些观点通过跨过多个组件对模块和数据表示及进行抽象来实现……**

