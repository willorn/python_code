

## 1.9 寄存器推理

> **内存架构：堆栈、代码段、数据段**
>
> 代码内的**栈内存**维护与实现：维护栈顶栈底的方式
>
> 内存地址的**编码方式**（类似编写地图的方式，按照哪个比例来画地图，这里就是程序世界的地图索引方式），
>
> **内存架构**：内存里面是如何存放数据的？



### LLVM与Graalvm的作用

**内存架构怎么来的？**

首先我们讲到的是内存架构，说到内存肯定有分为公有内存和私有内存。指令操作的数据最终都会落地到内存，放在内存的哪里呢？我们就需要有内存的架构，那么我们就需要把内存按照功能分割为几个部分。

指令段里面的指令必定会有自己的数据，而这些数据是当前指令段执行完毕之后就要销毁的。又有一些数据是指令段之间所共享的数据。那么我们只需要按照功能将【内存存放数据的区域】切割开来就可以了。

**指令段**：一段代码指令

数据段私有的数据，再加上指令段所共享的数据就是一个指令段所拥有的数据。

然后我们就可以继续推理：指令段可能有多个，那么就代表着我可以同时call多个指令（call指令是计算机转移到调用的子程序）。那我们不能直接就call吧，要找到call谁是吧！

于是我们就需要一种数据结构来表示这种存储方式。
**堆内存**：私有内存就类似于栈，是多个指令流所私有的数据。
**栈内存**：共享内存就类似于堆，是多个指令流所共享的数据。

【状态寄存器】
状态寄存器的灵感来自于图灵机图灵机里面就有一个状态器用来表示我们这个程序下一步需要走到哪个位置。
告诉程序说我们这个程序到底要不要跳，跳到哪个地方？

### 栈内存开辟

#### 他们是怎么来的？

还有一个要说的就是我们这个汇编语言组成的程序肯定不能是一整块的，所以我们需要把这个汇编语言分成一段一段的，而这一段一段的呢我们就将它称之为代码段，也叫做指令段。

在这里我们可以将c语言分支出来，一条叫做程序，程序是有一组代码组成程序，也可以叫做由指令流组成的功能组件。
堆内存和栈内存：怎么来的？

由于数据结构中占的特性是后进先出，也是先进后出，这就意味着站顶的内存就是当前正在执行的代码段，而当站点弹栈后，当前暂定依旧是执行的当前代码段。

但此时我们又需要去考虑一个问题。当调用子函数的时候，需要开辟新的栈帧。（帧：一片空间里存放了一组数据。而在站的一片空间里存放了一组数据就叫做栈帧。）
如何开辟空间呢？这就需要引入数据结构里面占的定义和占的基本操作。不管是什么数据结构，我们都需要引入一片内存，但是我们的内存是分为连续和不连续的。
对于连续的内存，我们只需要直接移动栈顶指针就可以了。对于不连续的内存，也就是说我们的内存之间的连续性是依靠指针来实现的（类似链表～反向链表），这种情况我们同样是移动暂停指针来表示当前执行的指令就行。
到这里我们就可以推出我们的寄存器组，里面有状态寄存器，是用于跳转指令使用的。下一个就是我们的指令地址寄存器，用于保存当前执行的指令地址。现在我们推出了栈顶指令寄存器和我们的栈底指令寄存器。
在外面我们可以看到占地指针寄存器，它一直指向的都是当前占的最底下的位置，而站顶指针寄存器指向的一直都是当前所在的指令行。
根据大可大小可小的原则，我们可以猜测一下，在占内存的里面，它是这么做的，当我们需要辟一个新的战争时，我们先将上一个栈帧的栈底存放起来，然后再去开辟新的代码段的战争。
【栈帧】
每个指令流都有自己的栈帧，战争里存放当前指令流的操作的数据，当使用call指令转移指令流后，那么只需要保存上一个指令流的栈底地址即可。
栈顶指针可以随意的向上走向下走，当他向上走的时候，它是一直开辟着空间的，当他向下走的时候，一直是战的过程，战过程的他就会将上一个指令段的占地地址给弹出来。其实就是个大链表思想。

#### 栈顶和栈底指针结构

我们说，一个代码段通过调用call进入另一个代码段后，为了实现多个代码段有自己的私有数据区域，于是引入了栈内存，那栈内存在代码段调用时是如何开辟的呢？？

想想我们的数据结构中的栈，就是通过一个栈顶一个栈底记录栈的情况，通过栈顶++实现放入元素，栈顶--实现弹出元素，当 栈顶 == 栈底 代表栈空，所以，我们需要维护一个 栈顶 和 一个 栈底 的数据表示。

![image-20221018095238857](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/image-20221018095238857.png?tximg)



表示栈顶和栈底的数据存放在哪里呢？ ----> 频繁修改查询，存放在寄存器中，并且必须要有，所以要通过寄存器来保存，所以就有了 栈顶寄存器 和 栈底寄存器。

从栈底到栈顶这段区域中，保存了目前为止该代码段执行过程中需要的数据，我们称之为**栈帧。（单位：帧，该区域可以包含所需的元数据信息）**

此时，如果我们需要 call 代码段B时，此时怎么分配呢？只是移动栈顶指针？？？那就会造成两个代码段的内容 融合在了一起，所以这是不可以滴。我们就要想办法把两个代码段的栈帧隔开，并且不共用同一个栈底变量，那是不是我们每个栈帧都使用自己的栈底变量呢？？？ 这样做其实是多余的，我们可以复用该寄存器中的值，每次call时，重新赋值 栈底寄存器，让其指向栈顶寄存器中的值。如下图所示

![image-20221018095215009](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/image-20221018095215009.png?tximg)





#### 实现

这样的话，我原来的栈底值保存在哪里呢？既然寄存器中存不了，那只有放内存中了，放内存中的什么位置呢？一个巧妙的设计就有了，直接放在两个栈帧中间。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652161149460-f35601c2-00d0-420f-bc2c-a3979642f5ab.jpeg?tximg)

这样做就完美了，每次调用 call 跳转到另一个指令时，我们就将当前的栈底寄存器保存在栈内存中，同时移动此时的栈底和栈顶就得到了一个新的栈帧。当代码段B执行完毕后，为了能得到原来的栈底值，只需要将其弹出保存在 栈底寄存器中即可实现。



### 内存地址编码方式

需要总共32位地址才能表示每个地址，最基本的地址就是1个byte。
我们要对四 g 进行寻址，我们用阴阳来算，那么我们至少是需要32位阴阳来表示所有的地址位，以二进制编码的话，我们是需要32位表示所有的地址。，但是如果我们采用16进制编码呢？
一个16进制能表示4位二进制，一节更比4节强，所以呢，我们现在就只需要8位16进制数就可以表示原本32位二进制所能表示的信息。
这里再简单讲述一下，为什么要推出来是16进制的编码，首先我们需要表示4GB的容量，对4GB进行选址，我们就需要拿到。如果我们需要对4GB进行啊，选址对4GB，用我们的二进制来选址的话，我们就需要32位，总共需要32位地址才能够表示每个地址的排列组合啊，那么这个时候呢，如果说我们只是用32位的来表示，那么我们写每个地址都需要32位的字符，非常长很浪费空间，所以呢，我们在这里我们就推出了一个16进制的编码，16进制编码就包括0~9abcdef，哦我们用几位二进制可以表示16个数呢，我们只需要4位二进制就可以表示16个数，那么我们一个16进制就可以表示4位二进制数，也就是说我们16进制一节更比4节二进制更强。所以这里我们采用了16进制作为我们的编码。
那为什么我们不用八进制呢？因为八进制只能表示三位二进制数这个凑不到一个整也挺浪费空间的，那为什么不是30二位32进制编码呢？32进制编码它是用5位二进制来表示，同样会浪费很多空间，不够凑整。

0xffffffff比0x0000要大。
所以上面的叫高地址，下面的叫做低地址。（大端存储小端存储）
我们聊到了高地址和地地址，也就是H和L





**内存中的值我们通过什么方式进行定位呢？**

很容易想到我们为每个位置进行标明地址，这样通过一个特定的地址值就能找到所需的数据。

计算机是只认 2进制的，而最小寻址单位是 byte，所以对于 4GB 的内存而言，我们通过计算可以得知需要 32位二进制数 才能表示完。如果在编程过程中，每次我们定位一个地址时都写 32个 01 或者 查看 32个01，那肯定是个噩梦，于是我们需要对其进行编码，采用 16进制数来进行表示，这样 一个十六进制位就可以表示 4个二进制位，32位也只需要写 8 个字符，方便了很多。**所以 内存地址 采用 十六进制编码方式表示。**

**好处：**

- 为了对齐
- 采用16进制编码地址信息，为了避免表示二进制位数过多
- 便于找到程序，大家都知道自己的位置了。A联系B也会方便非常多，计算机世界就活起来了。

**为何不使用 10 进制，8 进制，32 进制呢？**

- 8 进制能表示的数太少了，同样的数减少的位数并不是很理想；
- 10 进制数，并不是 2 的幂，这就会导致一些位数无法化为定长的十进制数，一个十进制位 能表示几个二进制位？3个半吗？所以显然是不理想的；
- 32 进制，就太大了，编码也比较复杂。



既然有了地址表示，就有相对而言的大小问题，我们把地址值大的称为 **高地址（H）**，地址值小的称为 **低地址（L）**。高地址位和低地址位。



操作系统是软件吗？

然后画风一转我们就到了操作系统，操作系统它是基于C语言的程序，用来管理硬件的软件。操作系统呢它是分为两大阵营的，有 Windows，还有Unix。
【操作系统是一个软件吗？】
我们可以推理一下是C语言先出现呢还是操作系统先出现呢啊，首先我们可以看到汇编语言一定是先出现的汇编语言呢，而C语言呢，又需要编译器去编译成汇编语言啊，编译器呢，又是建立在操作系统之上的，所以说我们一定是有了操作系统才有了编译器，然后才有了C语言，可以由C语言转化为汇编语言。所以我们可以看到第1个操作系统必然是机器语言0101写出来的，第1个操作系统全都是010011全是机器代码。
然后在这里我们可以看到C语言是没有办法直接去操作硬件的，因为C语言它必须得经过编译器这一关，它编译器不让他去操作硬件，他就操作不了硬件，而汇编是可以操作硬件的，因为汇编可以看作是机器语言的一种抽象。
那到这里我们可以大胆的猜想一下，第1个操作系统它必然全都是由Isa指令来写的，而到之后的版本的都是，如果我们需要去操作硬件的话，我们这些代码是用汇编语言来写，如果不需要去操作硬件，我们就采用C语言来编写。

【其他APP能操作操作系统吗？】
所以得出操作系统也在内存，但与此同时其他的应用程序是必然不能去影响我们的操作系统的，因为我们操作系统在计算机里面是有高于一切的权限，他管理了一切，如果任由应用系统应用程序随便去搞。操作系统的内存那么整个计算机将会变得非常的不安全。
然后现在我们可以看到程序的内存里面究竟存放了哪些数据，主要有4种数据，第1个是堆内存，第2个是占内存，还有代码段内存，数据内存。
栈内存主要存放的是指令流私有的数据，这是动态分配的，堆内存主要存放的是指令流之间所共享的数据。这也是动态分配的。代码段内存顾名思义就是存放代码的内存。数据内存用于存放在编译时期就生成的静态数据，例如Java里面的public static final。
他们在操作系统里面是这样排列的，首先操作系统的最顶处是用来存放操作系统所专享的一片内存，接着往下就是一片空白的区域再往下，就是占内存占内存，是用来存放指令流所私有的数据，这是动态分配的，它和堆内存一样都是动态分配的，只不过都内存用来存放的是指令流所共享的数据，接着我们可以再往下看，看到数据内存数据内存里面存放的数据是在编译时期就生成的静态数据，再往下看就是代码，段内存代码段内存里面存放的就是一些代码。再往下是一个空白的地方，这里可以看作是一个内存中的无人区，通常初始化为一个无效值的时候，例如说我们指向null啊，都是用的这个区域的地址。纸箱钠那里最高应该是零差400000然后我们的占内存占定站定应该是7C00000，这都是历史原因。决定的当然，这个内存的结构大致分成这样，也是写死了的，具体什么原因有兴趣可以查一下。


### 内存架构

既然内存 分为了 堆内存和栈内存，那么他们在内存中是如何分布的呢？？

在这里我们要引入 操作系统，操作系统是控制硬件的一套程序，其特权是最大的，为了避免被其他应用程序访问和破坏，所以它有着特殊的地位。操作系统在内存中独占了 顶部 或者 底部。然后维护一个边界，其他应用程序不得访问以及更改。

除此之外，代码也是需要加载到内存中才能运行的，所以内存中还应该有一处是用来保存代码的  -----> **代码内存**；另外，一些在程序加载时，就会创建的变量（例如Java程序中的 static final）也是需要放入到内存中的，所以对应着也有一个单独的分区 -------> **数据内存** 

**数据内存 和 代码内存 都是程序加载时就确定的，所以称之为 静态内存**

**堆内存 和 栈内存 都是在程序运行过程中动态开辟的，所以称之为 动态内存**



约定一片内存作为OS专用的区域

**栈内存**：多个指令流私有的数据。动态数据
**堆内存**：多个指令流共享的数据。动态数据
**代码段内存**：存放执行的代码（程序指令流）
**数据内存**：存放数据（static final、）

规定上下界，堆栈内存统一一大块

初始化为无效值



最后他们的分配如下图所示：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652164980893-a99148e5-716b-4f1e-933b-9e367180727d.jpeg?tximg)

最下面放的是null值





## 1.10 指令集 总线

使用汇编推理C语言：汇编语言基础

> 将上一节课关于内存架构的内容串联起来，东西多了，需要串联起来，才能形成知识的基本脉络。
>
> 地址是什么？
>
> 通用寄存器，专用寄存器



寄存器的大小

一个寄存器可以表示多少个 byte 的数据呢？寄存器的位数与 CPU 的结构相关，也就是 CPU 的位数。



### 内存架构



#### CPU里面的寄存器

我们说，一个代码段通过调用`call`进入另一个代码段后，为了实现多个代码段有自己的私有数据区域，于是引入了栈内存，那栈内存在代码段调用时是如何开辟的呢？？
想想我们的数据结构中的栈，就是通过一个栈顶一个栈底记录栈的情况，通过栈顶++实现放入元素，栈顶--实现弹出元素，当 栈顶 == 栈底 代表栈空，所以，我们需要维护一个 `栈顶` 和 一个 `栈底` 的数据表示。
表示栈顶和栈底的数据存放在哪里呢？ ----> 频繁修改查询，存放在`寄存器`中，并且必须要有，所以要通过寄存器来保存，所以就有了 栈顶寄存器 和 栈底寄存器。

【当我们开辟空间的时候是怎么做的呢？】

![栈内存开辟单一.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1652160213198-50c748eb-f0e7-455a-b8b8-dddb2aef9b30.jpeg)

> `call过程`：首先代码段a的栈帧去开辟空间的时候，我们先把栈顶寄存器的位置向上移一位，然后给它指向的位置保存上栈底地址，然后栈顶寄存器再往上移。等到栈顶寄存器，执行完B的栈帧（也就是将代码段B的栈帧全部弹栈完毕）弹完了之后呢，就会到代码段B栈帧的下面一行，就正好是栈底寄存器的值（代码段A的栈底地址），我们栈顶寄存器就返回到他刚刚执行的地方。

从栈底到栈顶这段区域中，保存了目前为止该代码段执行过程中需要的数据，我们称之为**栈帧。（单位：帧，该区域可以包含所需的元数据信息）**

此时，如果我们需要 call 代码段B时，此时怎么分配呢？只是移动栈顶指针？？？那就会造成两个代码段的内容 融合在了一起，所以这是步可以滴。我们就要想办法把两个代码段的栈帧隔开，并且不共用同一个栈底变量，那是不是我们每个栈帧都使用自己的栈底变量呢？？？ 这样做其实是多余的，我们可以复用该寄存器中的值，每次call时，重新赋值 栈底寄存器，让其指向栈顶寄存器中的值。如下图所示

![栈帧分配--callb.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1652160803924-cbb748dd-8f7e-4355-89c8-6cdc7a1eac6f.jpeg)

这样的话，我原来的栈底值保存在哪里呢？既然寄存器中存不了，那只有放内存中了，放内存中的什么位置呢？一个巧妙的设计就有了，直接放在两个栈帧中间

![栈帧分配final.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2641989/1652161149460-f35601c2-00d0-420f-bc2c-a3979642f5ab.jpeg)

这样做就完美了，每次调用 call 跳转到另一个指令时，我们就将当前的栈底寄存器保存在栈内存中，同时移动此时的栈底和栈顶就得到了一个新的栈帧。当代码段B执行完毕后，为了能得到原来的栈底值，只需要将其弹出保存在 栈底寄存器中即可实现。





编码规则就是将16进制编码进行应用，然后将32位2进制转变为8位16进制。



【动态分配内存与静态分配内存】

内存空间里面

动态分配的，有栈内存和堆内存。

静态分配的，有数据内存和代码段内存。



动态分配的原因是栈内存，它是从高到低这样不断的开辟栈空间。而堆内存开辟空间与之相似，也是一个动态分配的过程，他们都是动态分配的。

下面说一下静态分配，静态分配里面包含了两个内存，一个是数据内存，另外一个是代码段内存。



代码段数据例子——**静态变量**：

代码段内存里面的一些静态变量是非常巧妙的，比如说我们有一个指令叫做`mov 1 a寄存器;`就是将我们的1这个数据放到我们的寄存器里面，那么我们可以看到1这个数据它本身就是存在于我们的指令流当中的，那么我们的指令流呢又是存在于代码段的内存里面的，所以我们就可以说1这个数据它是存在于这个代码段里面的，所以我们就可以说1这个数据是静态变量。



`？？？`静态分配的内存是编译时期开辟的空间吗？



#### 堆内存数据存放

堆内存～指令流之间共享的数据



【堆内存～指令流之间共享的数据】

堆内存中怎么实现共享数据？-> 汇编规则

我们说，堆内存是用来存放多个代码段共享的数据，那么怎么进行存储呢？肯定是由一个代码段来进行存储，另一个代码段进行读取或者更改。这些代码段都是通过内存地址进行操作的，所以存储时，会得到一个内存地址， 获取时，是拿到这个地址，然后进行读取，更改操作则是对该地址上的内容进行更改。所以说，重点是怎么让这些个代码段知道这个地址的存在。因为代码段共享的数据，可以通过传递 或者 定义成 实例变量就可以直接使用了，所以我们可以将这个地址呢存放在一个地方，让各个需要该数据的代码段直接操作即可。于是，我们将共数据的地址放在数据内存中。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652174421464-785ed80e-6168-4a3d-a7cf-773a6ac4c372.jpeg?tximg)



数据内存是在汇编代码中定义的，汇编语言面对的是 汇编器，所以汇编器规定了指令的规则：

1. 代码定义：`.text` 定义代码段
2. 数据定义：`.data` 定义数据段
3. 指令流：`英文名+:` 定义指令流名字



因为数据段是静态共享的，所以，我们通过在数据段定义一个数据，这样各个代码段就可以对该数据进行读取、修改了。



【能够寻址多少？】

2的16次方个byte，就是64KB嘛（2的6次方KB）

堆内存我们可以举例说是0x0000到0xffff，他所能够表示的地址总大小就是2的16次方个byte，而1位16进制等于4位二进制，内存地址就是给内存中的每一个字节编了一个号，这个号就叫做内存地址。*重点中的重点。*



为什么16位0101能指示出来这么多的信息？

例如我们有10位2进制，最多能够表示1024个数据，那么其实我们可用它来表示中国的所有市（截至2020年12月，中华人民共和国实际直接管辖全境共有684个市。）跟以上的道理相通，最小的基本单位是8bit，而这里所说的最小单位是一个城市。



在图的存储器中的地址里面@

地址是采用16进制编码，地址信息为了避免表示的二进制位数过多，所以我们引入了16进制编码对我们的地址进行编码，所以内存地址存在的高低之分，高地址和低地址。

使用16进制给内存中的每一个字节编了个号，那么这个编号就叫做内存地址。



所以共享内存大多数都是写在汇编代码里面的（静态），由一段指令流给他去分配内存，然后在数据内存里面给某个变量附上词，然后另外一段指令流执行的时候，它就到对应的共享区域的数据内存里面去取就行了。

当我们要面向汇编奇去写我们的代码的时候。首先规则就是代码，在汇编语言里面写成点text，也就是代码段文本定义了代码段数据用点，data表示它定义了数据段，也就是我们各个指令流之间所共享的数据，对于我们的方法调用指令流的相互调用，是使用英文加一个冒号，就是我们给不同的指令流片段之间定义的名字call。



a：或是 b：

在汇编语言里面会将这种看作是每个指令流的首地址。汇编器会将这些英文冒号变为指令流的起始内存地址。

然后我们回到寄存器组，

首先是状态寄存器：表示了里面的进位是否为0啊，还是其他，还有指令是否需要跳转呢？

指令地址寄存器：用于指向当前我要执行的汇编指令的地址，栈顶寄存器用来指向当前执行代码流的栈内存的顶部，栈底寄存器与之相反。



【专用寄存器和通用寄存器】

状态寄存器：专用寄存器只能用于它所表明的用途。（例如：指令地址，寄存器，栈顶寄存器，栈底寄存器……）

通用寄存器：可以用于它所表明的用途，并且它还可以随便用。



【图示CPU】

CPU里面其实就是一堆寄存器（有专用寄存器和通用寄存器），高速缓存，控制器，运算器。

我们操作CPU其实就是汇编语言里面操作CPU就是对里面的寄存器进行各种操作。

（超哥提了一嘴，这里面的高速缓存可以和sram连在一起）



我们可以画一个图，就是关于编译原理的图。首先通过汇编器将编译语言转化为ISA指令集（这其中就有一定的规则，这个规则就是.text定义代码段啊，.data定义数据段等待），我们可以看到汇编语言与ISA是强相关的。

根据汇编语言指令集架构，主要分为x86汇编以及arm的汇编，所以一旦我们需要研究这个汇编代码，我们是不是就得找到特定平台的ISA呢？



然后我们看到内存， 里面有分为操作系统，所专属的内存，还有栈内存堆内存等等。



其中栈内存里面存放的数据就是指令流动态分配的私有数据，那么我这里面的这个栈内存它是怎么分的？首先我们就有站底计算器，还有栈顶计算器，由于内存是连续的且有高低之分，我们的指令流里面又定义了加减操作，所以我们可以按照栈内存的增长方向来计算占顶寄存器的移动位置，就能够表示我们所分配的内存。

如果左边是高地址，右边是低地址，那么我们为栈内存开辟4个单位的空间就是栈顶寄存器，向右移4位，如果说执行完了那我们需要团战团战的话，那我们就是向左边移动4个单位。（主要看内存的增长方向是从低到高还是从高到低）

堆内存，是用来存放指令流动态分配的共享数据。

数据内存，是在汇编代码段的.data段定义的数据。

指定内存，存放指令而又由于指令中可以写入数据（比如说move 1，寄存器），所以这里也存在了数据，只不过这个数据它是嵌入在指令中。



指令内存里面存放了不同的指令片段，有指令片段一和指令片段2，如果说我们指定片段一里面的数据想要调用我们指定片段2的话，那我们就需要用call指令指定片段一里面的程序，它的栈帧是存放在栈内存里面的指定片段2也是在栈内存里面存放的。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659691182786-0ade7453-9f61-49f3-8021-6780ecac99a0.jpeg?tximg)





#### 什么是汇编小结

将上述以及以前讲的一部分内容放在一起来看，什么是汇编代码？它完成了一个什么事儿？



汇编语言，是通过汇编器转换为 ISA 指令集 从而来操作CPU的，从外看，我们知道 操作 控制器，来操作寄存器，所以可以理解为操作寄存器 

整个流程，汇编语言到 ISA 再到控制CPU硬件，CPU再直接控制计算机硬件......

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652175919531-019824cf-4d81-4dba-9faa-514feb29af36.jpeg?tximg)



根据编译原理，我们知道 汇编语言 与 汇编器强相关，而汇编器又与 ISA 指令集强相关，所以根据不同的 ISA 指令集，会有不同的汇编语言（如：基于 X86的，基于RAM 的）

- windows x64和x86最主要的区别：windows x64是指64位的操作系统，windows x86是指32位的操作系统。 32位系统最多只能发挥4G内存的效用，如果电脑安装了大于4G的内存，32位的操作系统是不能更好的利用大于4G的那部分内存的效用的，所以会造成资源浪费。
- 精简指令集（ARM）是复杂指令集（X86）的封装。

- - arm优势在于存放微码和解码器可以很小很简单，CPU架构精简，成本低效率高，缺点是功能少，对于开发者很苦逼；
  - X86一个指令的事你要自己想半天去实现。X86就相反，因为要有地方存放大量微码而且必须要庞大的解码器解码指令，所以核心大成本高效率低。

复杂指令集和精简指令集属于计算机考古学。如今界限很模糊了。
x86指令集1978年出来的时候，精简指令集论文都没有。
979年以帕特逊教授为首的一批科学家也开始在美国加州大学伯克莱分校开展RISC这一研究．80年代才真正开始发展。
但是，由于cisc用了那么久，操作系统，软件全是继续X86为代表的cisc，总不能重新编吧。
后来到了64位时代，intel准备放弃x86开发了一个ia64，和x86不兼容。结果amd把X86扩展到64位。而且比尔盖兹也懒得给intel重写操作系统。结果就黄了。
**现在**x86处理器会把x86指令转换为更像RISC的微指令再予执行，从而获得可与RISC比拟的超标量性能，而仍然保持向前兼容。所以INTEL的X86其实本质已经变成准RISC了。

**大小**

2的16次方个byte，就是64KB嘛（2的6次方KB）

堆内存我们可以举例说是0x0000到0xffff，他所能够表示的地址总大小就是2的16次方个byte，而1位16进制等于4位二进制，内存地址就是给内存中的每一个字节编了一个号，这个号就叫做内存地址。*重点中的重点。*



为什么16位0101能指示出来这么多的信息？

例如我们有10位2进制，最多能够表示1024个数据，那么其实我们可用它来表示中国的所有市（截至2020年12月，中华人民共和国实际直接管辖全境共有684个市。）跟以上的道理相通，最小的基本单位是8bit，而这里所说的最小单位是一个城市。



在图的存储器中的地址里面@

地址是采用16进制编码，地址信息为了避免表示的二进制位数过多，所以我们引入了16进制编码对我们的地址进行编码，所以内存地址存在的高低之分，高地址和低地址。

使用16进制给内存中的每一个字节编了个号，那么这个编号就叫做内存地址。



所以共享内存大多数都是写在汇编代码里面的（静态），由一段指令流给他去分配内存，然后在数据内存里面给某个变量附上词，然后另外一段指令流执行的时候，它就到对应的共享区域的数据内存里面去取就行了。

当我们要面向汇编奇去写我们的代码的时候。首先规则就是代码，在汇编语言里面写成点text，也就是代码段文本定义了代码段数据用点，data表示它定义了数据段，也就是我们各个指令流之间所共享的数据，对于我们的方法调用指令流的相互调用，是使用英文加一个冒号，就是我们给不同的指令流片段之间定义的名字call。



#### 简单的汇编指令

a：或是 b：

在汇编语言里面会将这种看作是每个指令流的首地址。汇编器会将这些英文冒号变为指令流的起始内存地址。

然后我们回到寄存器组，

首先是状态寄存器：表示了里面的进位是否为0啊，还是其他，还有指令是否需要跳转呢？

指令地址寄存器：用于指向当前我要执行的汇编指令的地址，栈顶寄存器用来指向当前执行代码流的栈内存的顶部，栈底寄存器与之相反。



【专用寄存器和通用寄存器】

状态寄存器：专用寄存器只能用于它所表明的用途。（例如：指令地址，寄存器，栈顶寄存器，栈底寄存器……）

通用寄存器：可以用于它所表明的用途，并且它还可以随便用。



【图示CPU】

CPU里面其实就是一堆寄存器（有专用寄存器和通用寄存器），高速缓存，控制器，运算器。

我们操作CPU其实就是汇编语言里面操作CPU就是对里面的寄存器进行各种操作。

（超哥提了一嘴，这里面的高速缓存可以和sram连在一起）



我们可以画一个图，就是关于编译原理的图。首先通过汇编器将编译语言转化为ISA指令集（这其中就有一定的规则，这个规则就是.text定义代码段啊，.data定义数据段等待），我们可以看到汇编语言与ISA是强相关的。

根据汇编语言指令集架构，主要分为x86汇编以及arm的汇编，所以一旦我们需要研究这个汇编代码，我们是不是就得找到特定平台的ISA呢？



然后我们看到内存， 里面有分为操作系统，所专属的内存，还有栈内存堆内存等等。



其中栈内存里面存放的数据就是指令流动态分配的私有数据，那么我这里面的这个栈内存它是怎么分的？首先我们就有站底计算器，还有栈顶计算器，由于内存是连续的且有高低之分，我们的指令流里面又定义了加减操作，所以我们可以按照栈内存的增长方向来计算占顶寄存器的移动位置，就能够表示我们所分配的内存。

如果左边是高地址，右边是低地址，那么我们为栈内存开辟4个单位的空间就是栈顶寄存器，向右移4位，如果说执行完了那我们需要团战团战的话，那我们就是向左边移动4个单位。（主要看内存的增长方向是从低到高还是从高到低）

堆内存，是用来存放指令流动态分配的共享数据。

数据内存，是在汇编代码段的.data段定义的数据。

指定内存，存放指令而又由于指令中可以写入数据（比如说move 1，寄存器），所以这里也存在了数据，只不过这个数据它是嵌入在指令中。

指令内存里面存放了不同的指令片段，有指令片段一和指令片段2，如果说我们指定片段一里面的数据想要调用我们指定片段2的话，那我们就需要用call指令指定片段一里面的程序，它的栈帧是存放在战略群里面的指定片段2也是在战略层里面存放的。



#### 指令架构的选择

我们要研究编译原理，就得选择一个指令架构，指令架构又是由 CPU 设定的，所以我们需要选择一个 CPU 开发厂商的进行学习

我们可以选择 **Intel的x86架构**，因为该平台为PC端的统治者而且为CISC统治者，所以我们选择该平台来研究。

确定了这一点，我们应该选择什么资料呢？没有疑问肯定是《intel 开发手册》



【补充一些关于看书的】

按照自己的需求去看懂章节，**第3章《汇编原理》**

我们翻开第3章，我们现在只是需要去验证一下我们所学到的理论到底正不正确。

我们可以看到一开始有一个main 和妹and positive。在微软msam里面就是move eax，5。eax=5   Invoke调用函数，输入参数。



【为什么要看英特尔的手册？】

有一句话叫做，物有本末，事有终始。知其先后，则近道矣。

每一个事情都有他原本的样子，每个事物都由他开始到发展到现在的历史流程，我们了解到整个事物发展的流程掌握了脉络，我们就离道更近了。

所以我们要研究英特尔，那么我们就要研究英特尔的历史。没有谁比英特尔的开发者更了解他们的平台，所以呢，我们应该直接去问开发者吗？不可能，所以我们应该看他们写的手册。



英特尔的手册分为4卷。第1卷讲的是基础架构（总），第2卷讲的是所有的指令及引用，包括a到Z（分）。第3卷讲了系统编程指南，我们应该怎么利用这些指令集去编程？第4卷是平台强相关的挂钩的东西。



引会图示。

英特尔平台的英特尔手册分为四卷，采用总分结构进行编写。



13用于详细观看

24是用来查阅



先看到英特尔的历史，然后看里面的东西是怎么用的。直白点说就是找到基础的寄存器， Basic program execution registers.



### 总线

#### 看intel手册的前提

讲完了上面关于寄存器英特尔CPU相关的东西，我们下面就来讲到总线，这是计算机组成原理的部分知识，正式学习 Intel 开发手册之前我们需要补充一下总线的知识。



计算机的各个部件之间需要进行消息传递，所以肯定需要有连线来实现。需要哪些线呢？想想各个部件之间需要传递些什么？

1. CPU 控制各个设备，控制什么？ 读 or 写？
2. 确定了操作之后，我们需要确定操作的具体内存位置
3. 确定了需要操作的位置后，还需要确定操作的数据，比如写操作，那写什么数据呢？





![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1656896760334-2c1312b7-fdc9-4f54-badd-aef0e314f1d1.png?tximg)



cpu和内存的通信

https://itigic.com/zh-CN/communication-between-cpu-and-ram-how-does-it-occur/





于是就有了：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652177135536-227bacf6-0aea-4d26-a38c-bec23bf3ebae.jpeg?tximg)

- 控制总线 CB
- 地址总线 AB：读写操作指明他的地址
- 数据总线 DB：传输数据



【那么这些总线的位数是多少呢？】

这三类总线的位数通常都是与我们CPU的位数是强相关的，以下我们就可以看到这些标准的排列组合有什么影响？

- CB的位数：控制总线的位数决定了控制的种类，可以控制一个东西。比如说它是有什么权限，没有什么权限，2的N次方种控制的种类。
- AB的位数：也就是地址总线的位数。它决定了可以控制多少个地址。比如说2的16次方个byte字节也就是64KB，说明他可以管理这么多这么大的地址。
- DB的位数：是一次传输信息（数据）的位数。





#### 看书验证

《计算机组成原理》

总线将计算机的两个或多个功能单元连接在一起，并允许他们相互交换数据，例如CPU与显卡之间的总线。总线还将计算机与外设连接在一起，例如打印机接入计算机的USB总线总线是计算机系统非常重要的组成部分。

书里面介绍了没有总线的情况，他们之间的连接是非常凌乱不堪的，而有了总线就可以一次连接所有单元。 

PCI设备就是没有总线加上有公共总线，南桥北桥。我们可以在北桥上面搭一个PCI设备，然后把这个PCI设备挂在总线上，那么其他的总线和他交互就可以了。（ PCI控制器）

 ESB，

总线根本没怎么介绍嘛。

《计算机组成与体系结构》

用于数据传输的总线称为数据总线，data bus数据总线传递是必须在计算机的不同位置之间移动的实际信息（0101二进制）。

计算机通过控制总线control bus只是哪个设备允许使用总线以及使用总线的目的，（例如是读还是写内存或者io设备）。控制总线也传递关于总线的请求，中断和时钟信号同步的响应信号。

地址总线用于指出数据读写的位置（比如内存）。

【图示计算机硬件～内存～计算机组成原理～总线】





### 补充一些修心的

我们研究一个新的东西，始终记住一句话

物有本末，事有终始，知其先后，则近道矣

所以我们应该先了解 intel 的历史，然后去 查看 寄存器相关知识

老黄要给我们修心了，讲论语了

论语里面有很多篇，唯一一篇就是要学的学而篇



学而时习之，不亦乐乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？

学了东西就要成为自己的习惯，而不是说我学了东西要去温习。别人不知自己也不要去怪罪别人。

君子务本，本立而道生。

到千乘之国，敬事而信节，用而爱人，使民以时。

不患人之不己知，患不知人也。



下期计划

我们开始第1轮会将一些浅尝即止的东西，把这个树给构造完毕。

开始第2轮的时候，从数字逻辑和冯诺依曼体系把树上面的东西全部都补全了。把树叶之间的关联都关联起来。

最后这个数会有AI人工智能，大数据web开发等等各样的东西。数据库中间件的开发，





## 1.11 存储

将上一节课的内容串联起来，东西多了，需要串联起来，才能形成脉络。



寄存器的大小

一个寄存器可以表示多少个 byte 的数据呢？寄存器的位数与 CPU 的结构相关，也就是 CPU 的位数。

### 堆内存数据存放



堆内存中怎么实现共享数据？-> 汇编规则

我们说，堆内存是用来存放多个代码段共享的数据，那么怎么进行存储呢？肯定是由一个代码段来进行存储，另一个代码段进行读取或者更改。这些代码段都是通过内存地址进行操作的，所以存储时，会得到一个内存地址， 获取时，是拿到这个地址，然后进行读取，更改操作则是对该地址上的内容进行更改。所以说，重点是怎么让这些个代码段知道这个地址的存在。因为代码段共享的数据，可以通过传递 或者 定义成 实例变量就可以直接使用了，所以我们可以将这个地址呢存放在一个地方，让各个需要该数据的代码段直接操作即可。于是，我们将共数据的地址放在数据内存中。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652174421464-785ed80e-6168-4a3d-a7cf-773a6ac4c372.jpeg?tximg)



数据内存是在汇编代码中定义的，汇编语言面对的是 汇编器，所以汇编器规定了指令的规则：

1. 代码定义：`.text` 定义代码段
2. 数据定义：`.data` 定义数据段
3. 指令流：`英文名+:` 定义指令流名字



因为数据段是静态共享的，所以，我们通过在数据段定义一个数据，这样各个代码段就可以对该数据进行读取、修改了。



### 小结



将上述以及以前讲的一部分内容放在一起来看，什么是汇编代码？它完成了一个什么事儿？



汇编语言，是通过汇编器转换为 ISA 指令集 从而来操作CPU的，从外看，我们知道 操作 控制器，来操作寄存器，所以可以理解为操作寄存器 

整个流程，汇编语言到 ISA 再到控制CPU......

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652175919531-019824cf-4d81-4dba-9faa-514feb29af36.jpeg?tximg)



根据编译原理，我们知道 汇编语言 与 汇编器强相关，而汇编器又与 ISA 指令集强相关，所以根据不同的 ISA 指令集，会有不同的汇编语言（如：基于 X86的，基于RAM 的）



我们要研究编译原理，就得选择一个指令架构，指令架构又是由 CPU 设定的，所以我们需要选择一个 CPU 开发厂商的进行学习，于是我们可以选择 Intel的，确定了这一点，我们应该选择什么资料呢？没有疑问肯定是《intel 开发手册》



我们研究一个新的东西，始终记住一句话

物有本末，事有终始，知其先后，则近道矣

所以我们应该先了解 intel 的历史，然后去 查看 寄存器相关知识





### 总线

在正式学习 Intel 开发手册之前我们需要补充一下总线的知识



计算机的各个部件之间需要进行消息传递，所以肯定需要有连线来实现。需要哪些线呢？想想各个部件之间需要传递些什么？

1. CPU 控制各个设备，控制什么？ 读 or 写？
2. 确定了操作之后，我们需要确定操作的具体内存位置
3. 确定了需要操作的位置后，还需要确定操作的数据，比如写操作，那写什么数据呢？



于是就有了：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652177135536-227bacf6-0aea-4d26-a38c-bec23bf3ebae.jpeg?tximg)



1. 控制总线 CB
2. 地址总线 AB
3. 数据总线 DB









# 第三章 intel CPU与汇编

## 1.12 从intel手册开始



简单讲了一下超前学习的同学学习应该多注重推理，不要太将注意力放在术上了

编码规则，步入intel

### 推理学习：

这个东西为什么存在，过程是什么？

这里的后半部分还需要复习一下

什么是指令片段指令片段就是一堆Isa指令以汇编的形式表示出来，但是我们不能把所有的ISO指令都放在一个地方，所以我们就有了不同的指令片段。而不同指令片段组合的过程就叫链接。



**学习之道**

1. 用自己已经知道的知识去推出你要学习的这个知识，以及它存在的意义（费曼学习原则）
2. 如果是你，你怎么设计
3. 它解决了什么问题？
4. 我们可以用来做什么？
5. ......



### Intel编码与AT&T编码

**两位大佬的出现**

定律：新东西的出现，各**大公司之间就要掐架，定标准**。都希望自己名垂青史

linus 喷 intel 感兴趣搜索：加入AVX-512只提升了特定场景下的性能，而带来的影响是其他基础功能更加受限，但是优势是在基准测试中得分更高，并且大部分用户会为得分买单。

国外贼他妈讨厌英特尔，对英特尔是又爱又恨，牙膏厂那就是又爱又恨。

google 搜索 intel 风格

汇编是对ISA的编码（抽象），编译是对汇编进行编译生成ISA指令（具象化）。

重要重要的一句话，**汇编代码就是对ISA指令的编码**。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659871760965-cfc78100-a891-4668-9ea4-1e0f6067ff1a.png?tximg)

**众望所归**

于是出现了两种编码风格：**intel**（最多人用，所以研究它） 和 **AT&T风格（业界常用，业界标准）**

- Intel是x86架构处理器的缔造者，老大哥Intel设计了一套汇编语言，作为x86指令的助记符；
- AT&T公司的前身是贝尔实验室，C语言和Unix系统的出生地。注重**汇编语言的语法跨平台性。**
- 研究英特尔的时候，我们就要看英特尔的编码；当我们研究行业标准的时候，我们就要看AT&T编码。

| **AT&T风格**                                    | **Intel风格**                                         |
| ----------------------------------------------- | ----------------------------------------------------- |
| 寄存器前加%                                     | 寄存器无需另加符号                                    |
| 立即数前加$                                     | 立即数无需另加符号                                    |
| 16进制立即数使用0x前缀                          | 16进制的立即数使用h后缀                               |
| 源操作数在前，目的操作数在后（从前往后读）      | 目的操作数在前，源操作数在后（从后往前读）            |
| 间接寻址使用小括号()                            | 间接寻址使用中括号[]                                  |
| 间接寻址完整格式：%sreg:disp(%base,index,scale) | 间接寻址完整格式：sreg:[basereg + index*scale + disp] |
| 操作位数：指令+l、w、b                          | 指令+ dword ptr、word ptr、byte ptr                   |

面向汇编器编程，具体哪个编码集



编码规则：知其先后则近道矣



### intel 手册 cpu历史

#### 8086与8088

IA-32存在两个 16 bit 的CPU --> 8086 和 8088

The IA-32 architecture（体系结构） family was preceded by 16-bit processors, the 8086 and 8088. **The 8086 has 16-bit registers and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to the 8086 except it has an 8-bit external data bus.**

The 8086/8088 introduced segmentation to the IA-32 architecture. With segmentation, a 16-bit segment register contains a pointer to a memory segment of up to 64 KBytes. Using four segment registers at a time, 8086/8088 processors are able to address up to 256 KBytes without switching between segments. The 20-bit addresses that can be formed **using a segment register and an additional 16-bit pointer** provide a **total address range of 1 MByte.**

**译：**

在 8086 和 8088 中都存在 16位寄存器，20位地址总线，只不过 8086 有 16位数据总线，而8088只有**8位数据总线**

在 8086 和 8088 中 引入了内存分段模型，当内存不进行分段时，我们使用一次使用 4 个段寄存器可以寻址 256KB，因为 16位的寄存器可以表示64kb，同时使用4个段寄存器-> 4 * 64kb = 256KB。

但是我们引入了分段概念后，就能够通过一个段寄存器指定目标地址所在段（间接获得基址），用基址 + 指令地址寄存器的值  从而得到 20 bit 地址，就可以寻址 1 MB 的内存空间了。



#### 段寄存器的出现

段寄存器 + 指令地址寄存器

= 段+偏移量进行寻址
= 基地址 + 偏移地址
= base + bis



段寄存器包含：

- 栈段寄存器（SS）
- 数据段寄存器（DS）
- 代码段寄存器（CS）
- 其他寄存器（other S）



#### 需求变更——16bit要改20bit

虽然总线数是越大越好，但是会有电磁干扰，限制了最大的总线数。

**为何地址总线不是 16 位而是 20 位呢？？？**

这其实是当时的生产原因，由于当时已经生产出了 1 mb 的存储器，寻址也就至少需要 20 bit 才能寻址完，所以采用了 20 位地址总线。

一个工程师灵机一动，出现了段寄存器。（参考intel 一个大佬写过的一个博客……）

但是存在一个问题呀，我指令地址寄存器只有 16位，怎么使用 20 位的地址总线呢？此时就有一个工程师想到了，将内存分段，分成每一段都能通过 16位表示，也就是 64KB，1 mb 的内存就被分为了 16段，然后再通过一个**段寄存器**来实现段的确定。

段寄存器，为了确定不同的内容，针对于 栈内存，数据内存，代码内存 有 栈段寄存器，数据段寄存器，代码段寄存器，其他段寄存器。



### 

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |

## 1.13 Intel历史、保护模式

我们可以往后面看，看到英特尔的历史各种内存分段啊保护模式，4个特权级，还有段界限检查，这些CPU的特性，再加上我们的汇编语言，还有我们的C语言我们就可以推出操作系统。操作系统，so easy。

**汇编都不学好，怎么推后面？**



**为何要讲 CPU**，我们知道 控制了CPU就相当于控制了整个计算机，而操作系统正是用于该功能。所以操作系统肯定是要面向于 CPU 提供的指令操作 进行编程，即 学习CPU 为学习 操作系统增加了很多便利。即操作系统面向 CPU 进行编程，CPU 厂商指导操作系统开发。CPU 为了满足各类操作系统的开发，同一个事情肯定提供了好多种不同的实现方案，具体实现由OS开发者来决定



### Intel历史补充

【寄存器组】

状态寄存器就是用来指向跳转的指令的，跟图灵机里面的状态机有一定的相似之处。

指令地址寄存器就是指向当前正在执行的指令地址。

栈顶寄存器和栈底寄存器共同开辟了栈空间。

再复习一下总线总线有控制总线地址总线，还有数据总线。

控制总线就是用来表示控制谁，控制读还是写。地质总线指明我要控制的设备的哪一个地址，数据总线就是传输数据用的。



**真男人就该直接开始干Intel手册！！！**

简单的英特尔64和IA32架构的历史

以下这些节将会给我们一个主要的结论，从IA32到英特尔的64架构，我们从英特尔的8086处理器开始，直到我们的最新英特尔核心2duo，核心2和英特尔，X1on处理器5300和7300系列。早在1978年，处理程序的代码就已经写好了，他们在最新的英特尔64和 IA 32架构家族程序里面依然被使用。



#### 发展历程

【16位处理器和段，1978年】

 IA32架构家族里面有两个16位的寄存器，分别是8086和8088。

8086有16位寄存器，16位数据总线，有20位地址总线可以提供给一兆的地址寻址空间。8088与8086很类似，除了他有8位数据总线。（ External  Eight bit data bus， External是外部的）

数据总线的升级，可以带来更快的并行效率，可以同一时间传输更多的数据。

内存分段：8086和8088引入了“段”到IA32架构。有了这个段，一个16位的段寄存器，甚至可以指向内存地址有64位之大。在同一时间使用4个段寄存器8086和8088的程序，可以去寻址256KB，而不需要在段之间切换。

使用段寄存器和另外的16位的point，可以形成一个20位的地址总线，可以应用到1MB的地址寻址。（指令地址寄存器提供16位段，寄存器提供4位，一共是20位作为地址总线的寻址范围，可以寻址到1mb的大小）

【是怎么做到的？】

将断寄存器的位，也就是16进制左一位它就等于二进制左移4位可以提供4位的 bit, 而左16进制左移移位之后呢，那剩下的地方就是给，剩下为0的地方就是给指令地址寄存器用来存放它的偏移地址。

绝对地址就是鸡地址加上偏移地址，我们放到这里的指令地址寄存器和段寄存器就可以看到。

基地址（段寄存器的高4位也就是哪一段的首地址）加偏移地址（指令地址寄存器中的16位数据）

就好像我们的 int数组一样，我们首先是冲通过unsex的累，拿到每个单元他的这个单元的大小也就是4个字节。我们再去拿到数组下标的index索引，再去乘以我们的数组大小就可以得到值（偏移地址）再加上intel的首地址（数组变量的首地址）。



为什么8086~8088有这些变化呢？有一个原因是内存商家说我这里已经生产出来1MB的内存了，而现在16位地址总线也就是2的16次方和bat，只能寻址到64KB的空间，对于一兆币来说太小了，所以我们需要让现在的CPU支持一MB也就是2的20次方个byte，那么我们就需要20位的指令地址寄存器以及20位的地址总线。

那么我们寻址并不能改变原来的指令地址寄存器，所以我们保证原来的指令，寄地址寄存器大小为16 bit而另外加一个段寄存器也是16位，但是这两个加起来段寄存器提供4位，也就是16，16×64KB=1mb。

然后我们需要去维护段寄存器，那么段寄存器下面有站段寄存器数据段寄存器代码，段寄存器还有一些共享段呢？共享段不存在就叫做通用段计算器。

SS

DS

CS

其他S



16位的指令地址寄存器加上16位的段寄存器，我们就可以共同寻找到1MB的空间。





**【英特尔286处理器，1982年】**

在英特尔286处理器中引入了保护模式到IA32架构。



保护模式。使用断继存器。

保护模式使用段选择子和 gdd表来表示。

描述符提供了24位的基础地质，并且可以寻址物理地址达到16兆B，他

提供了虚拟内存管理，在 Segment swapping 并且有很多保护的机器，这些都包括在里面，断线制检查，断接线检查，指读和指运行段选择4个特权级。



段界限检查

只读和只运行段选项

4个特权级

（虽然有24位的地址总线，但是他是假的32位）



**【英特尔386处理器，1985年】**

英特尔386处理器是第1个32位处理器，在a32架构家族里。引入了32位寄存器，用来持有操作数和寻址。英特尔386寄存器低32位还保留着上一代16位寄存器的一些特性，允许向后兼容。（直接拿32位的低16位操作指令）。

处理器也提供一个虚拟的8086模式，当执行8086和8088处理器的程序时，提供更好的性能。（虽然我现在是32位机，但是只要我切换到虚拟的8086模式，我的所有组件对8086模式都是完全兼容的）



此外英特尔386处理器也支持以下的特性：

一个可以支持4GB物理内存的32位地址总线

一个分段内存模式和平坦内存模式

以4KB作为基准页数的分页，他为虚拟内存管理提供了一个方法。

支持并行阶段



**【英特尔486处理器，1989年】**

英特尔486处理器增加了更多的并行处理能力，通过拓展英特尔386的处理器的指令解码和执行单元到5个流水线阶段。每个并行处理的阶段操作都提升了，5个指令在不同的执行阶段。



此外处理器增加了以下特性：

增加了一个8KB的片上一级缓存，它可以增加每个时钟周期可执行的指令。

引入了x87 FPU，浮点运算单元

省电和系统管理工具





我们通过了解英特尔8086，8088，i286，i386，i486的历史我们可以知道。

提供了保护模式：

断界线检查，可读和可执行的选项，4个特权级

真32位机：寄存器地址总线均为真正的32位，4GB的空间。

并行执行流水线（指令流水线）

 CPU一级缓存，浮点运算单元

提供了分段机制

电源保护机制和系统管理工具

虚拟的8086和8088模式

内存模型（栈段计算器，代码段寄存器，数据段寄存器，通用段寄存器）



#### 芯片发展总结

| **年份** | **芯片**  | **特性**                                             |
| -------- | --------- | ---------------------------------------------------- |
| 1987     | 8086\8088 | 16bit分段寄存器                                      |
| 1982     | I286      | 24bitIA-32架构保护模式（段界限、只读段、特权级）     |
| 1985     | I386      | 真·32bit（16+16）4KB分页并行操作                     |
| 1989     | I486      | 8KB一级缓存X87 FPU（浮点运算单元）指令流水线省电模式 |







### 保护模式：

我们应该怎么对运行在内存中的程序提供保护功能呢？

不能让CPU拥有太大的权限

操作系统要完成他的操作，那么他就必须得控制CPU，那我们控制CPU就等于控制了计算机。操作系统就是帮你去操作硬件的系统。【很重要很重要。】

因为CPU可以控制所有，而操作系统控制CPU，如果我们不对它进行保护，那么就等同于我们的应用程序可以去控制操作系统，进而控制CPU，控制了整台计算机。



同样的在我们秒杀里面做的这个虚拟地址也是一样的，我们一开始给用户一个虚拟地址，用户就通过这个虚拟地址去访问我们的后台，拿到我们真实的抢购地址，这个socket，然后再把这个socket返回给用户，也就是把我们真实的地址发给用户。这个虚拟地址转化为真实地址是由服务器来做的。（ IP过滤）



#### 进程隔离是怎么做的呢？

首先给操作系统分一块区域，这块区域是操作系统，独享其他的进程不可访问的。而分配给每个进程的都是虚拟内存，真实的内存是每个进程所不能够访问到的，我们将虚拟内存分配到真实内存里面。

采用哈希表（类似）将不同进程之间的地址进行隔离，每个进程虽然都拿到了0~3G的所有的内存，并且将自己的站段数据段代码段都分配好了，但是我们映射到真实内存的时候，它只占用了一小部分，其中是利用了哈希表将不同的进程之间的地址进行隔离。

那我们对于每一个进程里面的操作系统是怎么让他不去侵入的呢？我们是通过划分特权及划分了0123特权级逐步降低来完成权限的分割的。首先操作系统有着最高的特权级应用，能访问到的地方是最低特权级。（ Linux只用了0和3，所以别的不用考虑，只用两位二进制就能进行区分）



下面看到我们是如何设计32位的CPU。

首先在设计32位的CPU的时候，我们已经知道了内存的大小为4GB，而4GB等于32次方个 Byte，所以32位CPU需要32位指令地址寄存器，必须要32位地址总线，所以I386就是这么设计的。



我们根据以上的知识可以推理到程序，

它的特权及保存在哪里？

当然是保存在我们的代码段计算器。程序执行的时候，CPU执行的是代码，没有代码，那么我们怎么去修改数据呢？所以这个程序的特权级一定是放在代码段寄存器里面的。

第2个问题在访问的时候需要有一个特权级的校验，这个校验位放在哪里？

段的描述符里面，（我们可以将段描述符看作是一个表，这个表保存了段的元数据信息）段描述符表， Global described table register. Gdtr表，全局段寄存器描述表。

#### 【什么是实模式、保护模式？】

实在模式也就是实际模式，就是直接操作物理地址的模式，就是通过直接指令地址寄存器加上段寄存器等于真实物理地址。

保护模式protective model，段寄存器查表加指令地址寄存器等于真实物理地址。



我们可以看到英特尔开发手册里面就有了，在2.4.2的最后图2-6（找不到那个版本了）内存管理寄存器可以看到这个段描述计算器是怎么分配的。

分段分页还有很多东西，现在都还没讲。断选择者再加上一个偏移量，偏移量就是IP，这些东西都没讲。别着急哟，大哥们。

flat memory model（扁平化内存模型）：就是段选择子（Segment selector）加上一个数据段描述符的偏移量，就直接等于线性地址空间。（所有的访问信息）



#### 虚拟内存

真实地址，虚拟地址

真实内存， 虚拟内存

OS管理映射、过滤请求、地址隔离

#### 特权级

奴隶咋翻身

特权级 + 段寄存器

设计32位的CPU时候，已经知道了内存的大小为4GB



1、程序的 **特权级** 保存在哪里？程序执行时候，CPU执行的是代码，没有代码怎么可能修改数据————》代码段R

2、在访问的时候，需要有一个特权级的校验，这个校验位放在哪里？**段的描述符**里面。



**实模式**：直接通过 **指令地址R + 段R == 真实物理地址**，去直接操作物理地址。
**保护模式**：段R 查表 + 指令地址R **== 真实物理地址。**



**模仿道友问问题：**

- 表有几个？物理内存有几个？1个
- 段的地址会不会越界？段界限检查
- 其他程序能访问对方的段吗？不能，各自都有自己的段界限
- 表谁放的？OS
- 表有多大？GDTR决定，首地址，界限
- 表占多大内存？GDTR表项长度 + 每一项的描述大小（查看手册里面就有）
- 表的首地址在哪？段界限检查



### Intel历史补充2

#### I286

The Intel 286 processor introduced **protected mode（保护模式）** operation into the IA-32 architecture. Protected mode uses the **segment register content as selectors（段寄存器作为一个选择子）** or pointers into **descriptor tables（段描述符表）**. Descriptors provide 24-bit base addresses with a physical memory size of up to 16 MBytes, support for virtual memory management on a segment swapping basis, and a number of protection mechanisms. These mechanisms include: 

• Segment limit checking

 • Read-only and execute-only segment options

 • Four privilege levels

译：

提供了保护模式。保护模式将 段寄存器 的内容作为一个选择子 或者 是一个指向段描述符的指针。

段描述符 提供了 24 bit 的基址，让物理内存寻址可达 16MB，并且支持 可交换的段 来实现 虚拟内存，以及多种保护机制：

1. 段界限检查
2. 只读和只执行 段选项
3. 4个特权级

I286只支持 最大 16 MB 的内存寻址，其中还有 24 位的段基址，16MB = 224  bit，所以该地址总线是 24位的。而段基址就是 24bit？已经可以完全表示了。

8086 和 8088 每次进行内存地址定位的时候，直接使用 指令地址寄存器 + 段寄存器的值 相加来得到内存地址，并直接进行操作，我们称这为 **实模式，实模式直接操作给定内存**，那会不会不小心或者恶意去更改掉其他程序 甚至是操作系统的数据和代码呢？该模式下系统是不安全的，是易碎的

所以为了让程序之间互不干扰，所以我们需要在获取指令时判断是否允许访问，推理下应该怎么处理呢？最简单的方法就是将各个应用程序进行隔离。怎么进行隔离呢？？？

我们可以类比一下 秒杀业务，在秒杀场景中，我们不能直接提供真实地址给用户，如果用户知道真实地址，提前使用程序进行不断的刷单，这样的话，那些没有使用程序的用户是很难抢到的，所以直接给用户真实地址这是不公平的。所以一般在秒杀业务中，都是给定一个虚拟地址给前端，当正式到抢购时间点时，才对真实地址进行调用

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652272646943-ab50d470-5d72-4e94-871d-9ac3c7dde48e.jpeg?tximg)

类比到我们的地址访问中，我们是否可以让应用程序得到一个虚拟地址，而不是真实的地址，然后通过一张表进行映射到真实地址上？这样每个程序都认为自己占有了整个内存，无法感知到其余应用程序的存在。 ------ 这就是 **虚拟内存**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652272608015-4035cd44-8412-4418-a90e-a04e465457f5.jpeg?tximg)

当我们需要访问内存时，CPU会先拿到 指令寄存器 中的值，然后通过查找映射表，得到映射表中存储的基址，然后加上 指令寄存器中的值，才能得到真实对应的内存。为了实现安全性，我们可以在该表中记录一些权限信息，**比如该段是只读or可执行、段的长度（避免越界）**....... 那么由此就实现了段界限检查 和 代码段的权限信息。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652273516952-bc49748c-ce21-4605-8ba5-fdfaf927e958.jpeg?tximg)

那么该表由谁来管理呢？  -----> 肯定是由 OS 和 CPU 来管理；既然要进行查表操作，肯定就需要知道表的存储位置，这个位置怎么知道呢？----> **使用一个寄存器来存放即可（GDTR：global descriptor tables register）**；用什么来查呢？通过手册我们知道此时的指令地址寄存器的位数已经可以对整个内存进行寻址了，那段寄存器还有用吗？当然有用了，我们可以用 段寄存器来记录要查找的表的下标索引。

#### 特权级

我们说，每个应用程序除了能感知到 OS 外，其余都认为自己独享，那么有没有可能程序去修改操作系统的代码呢？对于这个呢我们可以这样解决，应用程序给定 特权级，让特权级低的无法访问 和 修改特权级高的程序，而操作系统是一个特殊的程序，所以给定它最高的特权级，而其余所有的应用程序都给定最低特权级，这样便可以避免该情况的发生，保证 OS 的安全。

既然有特权级，那就必须要给定标记（将特权级存放在一个位置），那**程序的特权级存放在什么地方呢？---> 程序执行时，CPU 执行的是代码，没有代码哪来的特权级，所以 肯定是存放在 CS寄存器中的。		程序有了特权级，那被访问内容肯定也有一个特权集，用于比对，那该特权级又存放在何处呢？ ---->  在映射表中的元素中（段描述符）**

通过以上的推理过后，如果推理是对的的话，程序执行的过程将会是什么样的呢？首先通过段寄存器得到映射表的索引下标，然后通过存储映射表的寄存器获取到表的位置，而后拿到段的相关信息（包括段特权级，权限信息，基址，大小），然后进行校验，如果没问题的话，就将基址与指令寄存器中的值相加便得到真实的内存地址了。 -----> 通过 Intel 开发手册 验证

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652276737873-c03882ac-113a-4620-9133-c596b231a2af.png?tximg)





#### I386

The Intel386 processor was the **first 32-bit processor** in the IA-32 architecture family. It introduced 32-bit registers for use both to hold operands and for addressing. The lower half of each 32-bit Intel386 register retains the properties of the 16-bit registers of earlier generations, permitting backward compatibility（向后兼容）. The processor also provides a virtual-8086 mode that allows for even greater efficiency when executing programs created for 8086/8088 processors.

In addition, the Intel386 processor has support for:

 • A 32-bit address bus that supports up to **4-GBytes of physical memory** 

• A **segmented-memory model** and **a flat memory model** 

• **Paging**, with a fixed 4-KByte page size providing a method for virtual memory management 

• Support for parallel stages     ---------  支持并行执行

译：

I386是IA-32体系中第一个真正意义上的 32 位CPU，采用 32 位寄存器 操作操作数 以及 寻址，支持将 32 位寄存器切割为两个 16 位寄存器使用，从而实现向后兼容。并且还提供了虚拟 8086 模式，允许 之前的代码能够运行，并且运行效率更高一点。

1. 32位地址总线，支持 4GB 的内存寻址
2. 分段的内存模型 和 平坦内存模型
3. 分页机制，提供的 一种方法来管理虚拟内存以固定 4KB 的分页 
4. 支持指令并行





#### I486

The Intel486™ processor added more parallel execution capability by expanding the Intel386 processor’s instruction decode and execution units into **five pipelined stages**. Each stage operates in parallel with the others on up to five instructions in different stages of execution.

In addition, the processor added: • An 8-KByte on-chip first-level cache that increased the percent of instructions that could execute at the scalar rate of one per clock

• An integrated x87 FPU

 • Power saving and system management capabilities





### 最后的话

**小结一下，我们最近两章讲了些什么呢？**

主要就是讲了CPU里面的一些寄存器寄存器，有段寄存器代码段寄存器，数据段寄存器。然后讲了英特尔的一些历史，然后讲了8086~8088这里面的一些事情，8088是对8086的一个升级，8088支持1mb的寻址空间。 I286开始引入了段，有段我们推出了保护模式保护模式就涉及到断界线检查，4个特权级。 I386是一个真正的32位机，它可以兼容以前16位机的所有操作组件，并且他将地址空间可以拓展到4个GB。 I486就更加牛逼了，引入了一些并行阶段，还有指令流水线之类的操作，省电模式。

然后这里面我们对I286里面的段计算器还有GDP啊，这些基础的知识进入了进行了深入的推理。知道了什么是实际模式：指段寄存器里面的直加上指令地址寄存器的值就是真实的物理地址。保护模式是指令地址寄存器的值加上段寄存器查GDP表得到的地址，两个加起来就是我们真实的物理地址。



**推理验证**

我们不是要追求直接PPT给你全部东西粘出来就直接背就好了，很多东西，我们要回头看到原本的东西，然后自己去推理，从最简单的到顶层的到复杂的。如果直接拿上层的东西拿复杂的东西，那些名词全部丢出来，就了解那些名词，这是经不起推敲的。



推理加验证，我们推理完所有的知识，我们接下来就是对我们的知识进行验证！！！！！

不是直接就得了一个结论，直接拿了一个结论就背，这是没有任何作用的。推理推理推理推理完再验证是否正确。

我们必须要了解很多很多的基础的知识，才能继续往下走，才能走得更远。



## 1.14 内存管理

一定要记住自己当前的目标，是去验证之前的推理。

验证上一课 I386 等一系列处理器新增功能的推理，如 **虚拟内存、保护模式** 等 的实现。

### Intel手册——GDTR

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659968155518-05186f08-333a-41fd-9198-5e4dc6ce5354.png?tximg)

系统级架构包含了一些目的在于支持基础的系统及操作的指令及例如寄存器及数据结构和指令，例如内存管理中断和异常处理任务管理和多任务控制。

图2-1提供了一系列的系统计算器和数据结构，他们可以应用在32位模式。系统寄存器和数据结构应用到a32模式，在图2-2里面有写到。



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659968499662-d60270cd-b91b-4205-a7ac-fc2d2acafc8b.png?tximg)

通过该图，**EFLAGS Register**是我们的状态位寄存器（intel的具体实现）。我们知道大致的访问流程，确实有 GDTR 找到段描述符表的始址，还有通过 **段选择子** 确定 **段描述符表**中的索引下标。



#### Global and Local Descriptor Tables

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1659968800957-ced20ec7-b6fb-488c-90bf-541b0097571e.png?tximg)

当操作保护模式时,所有的访存都需要经过 GDT 或 LDT，这些表中的元素称为段描述符, 段描述符中记录了 段的 **段的基址，访问权限，类型 以及 使用信息**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004137853-6d6b4d86-6640-41a5-9a41-c31cb1aab9c6.png?tximg)

每个段描述符都有一个关联的段选择子。 段选择器为使用它的软件提供 GDT 或 LDT 的索引（**其关联段描述符的偏移量**）

访问段中的一个数据，我们必须**提供 段选择子 以及 偏移量**。段选择子用于提供对段描述符的访问权限，（全局描述表或者是局部描述表的）。从段描述符来看，处理器包含了段在物理地址的基地址。然后偏移地址提供字节相对于基地址的位置（base）。这种机制可以用来访问任何有效的代码，任何有效的数据或者栈段，前提是可以从处理器运行的当前特权级别访问该段。

**从以上可以推出：**

==》访问就需要拿到**段选择子** + 偏移量
==》基地址 + 偏移量
==》也就是从段描述符中，可以获得 **段基址**，offset 提供相对于基址的内存偏移量，所以 **真实物理内存地址 = 段基址 + offset 偏移量**。





#### GDTR-全局描述符表寄存器（※）

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004726002-e16871bb-abf1-4c0b-a171-74912db0560e.png?tximg)

一共48位，高32位表示表的始址，低16位表示表的大小界限



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004745870-a14f0e1d-ca17-4b9c-bbc8-ad0e7c854e5c.png?tximg)

GDTR保存了 GDT 的基址 以及 一个 16位的表界限。基址表示 GDT的首址的线性地址，table limit 表示这张表的大小.LDTR与我们没有关系。。。



**相关的指令操作：**

• LGDT (Load GDTR Register) — Loads the GDT base address and limit from memory into the GDTR register.   将 GDT 的信息 加载到 GDTR 寄存器中

• SGDT (Store GDTR Register) — Stores the GDT base address and limit from the GDTR register into memory  将 GDTR 中的信息存储到内存中

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652326367230-45545176-2173-429e-aced-01400fc3e839.png?tximg)



LGDT

SGDT



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089452472-249d2703-c61e-41af-b85c-3e990877cb62.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089471773-99113da9-62b4-45ba-bc5c-d8b8ced8d03a.png?tximg)



![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089462396-57174660-1064-4ab0-a8ab-2076bc8fcb7c.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089483463-bab1b60e-51e2-400b-b72a-113a5e15cc2d.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089498935-4b5b23f2-a49d-4f55-9d0f-6d040a30216b.png?tximg)



#### 多段模式

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089515165-42306090-78fb-4947-adca-0805b81e3609.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089543730-96c67de7-679f-4895-b196-0f414b47a179.png?tximg)

每个段寄存器都需要到GDTR里面找到自己的位置，就是段的 Base Address + Limit ==> 最大地址，超过了就报错，Base Address是基地址，首地址。





### 权限

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660004973204-9a0ff849-5e14-4d0b-bde0-b21765b2fbf3.png?tximg)

译： 处理器提供了一些指令，通过检查 段选择子 和 段描述符 来决定访问 与之相关的段是否是被允许的，这些指令其实是复制了一些有处理器自动处理的 访问权限 和 类型 检查



Each segment has a segment descriptor, which specifies the size of the segment, the access rights and privilege level for the segment, the segment type, and the location of the first byte of the segment in the linear address space (called the base address of the segment).

**每一个段都有一个对应的段描述符，该描述符表明了该段的长度，访问权限，该段的特权级，段类型，基址**
The base address plus the offset thus forms a linear address in the processor’s linear address space.

**段基址 + 偏移地址 = 线性地址**



**于此，上一小节的推理已经验证完毕**



**P 2873**







### 段选择器（段选择子）

#### 段描述符

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089590582-3bd7a903-ed9b-4a4b-b800-03d25a0a902a.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660089583722-ca885fde-b2a4-46db-a711-474803000555.png?tximg)



#### 段选择子 与 段寄存器

之前我们说到，在进行查表的时候，将段寄存器给应用上，用段寄存器来存储 段描述符表中对应的下标索引值。我们将 存储该下标的部分称之为 段选择子。

### Segment Selectors

A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,but instead points to the segment descriptor that defines the segment. A segment selector contains the following items:

译：

段选择子是一个 段的 16位 标识，它并没有直接指向段，而是指向了 段相关信息的 段描述符，一个段描述符包含以下内容：

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652340305274-76464344-1cc4-4eb1-9640-8a4b5e6acd74.png?tximg)

1. index
2. T、I flag
3. RPL





#### Segment Registers

To reduce address translation time and coding complexity, the processor provides registers for holding up to 6 segment selectors (see Figure 3-7). Each of these segment registers support a specific kind of memory reference (code, stack, or data). For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors. The processor also provides three additional data-segment registers (ES, FS, and GS), which can be used to make additional data segments available to the currently executing program (or task).

For a program to access a segment, the segment selector for the segment must have been loaded in one of the segment registers. So, although a system can define thousands of segments, only 6 can be available for immediate use. Other segments can be made available by loading their segment selectors into these registers during program execution.

译：

为了减少地址转换时间以及coding的复杂性，处理器提供了 6个段寄存器 来支持不同的内存引用。对于几乎全部的应用程序想要执行都必须至少需要 CS、DS、SS 加载有效的段选择子。处理器还提供了其他的 三个 段寄存器来使额外的数据段可用。

对于一个程序访问一个段，必须将段选择子加载到一个寄存器，所以尽管可以定义无数个段，但是能够供给使用的段寄存器也就只有 6 个。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660090867041-20a7e554-0bbc-42c9-872d-d3914ba8b308.png?tximg)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660090795171-0f1d1afe-d3fa-4b30-a7da-27e6ec7e196a.png?tximg)

译：

每个段寄存器都有一个“可见”部分和一个“隐藏”部分。 （隐藏部分有时被称为“描述符缓存”或“影子寄存器”，隐藏部分也会作为一个缓存使用。）当段选择器被加载到段寄存器的可见部分时，处理器也会将段寄存器的隐藏部分与段选择器指向的段描述符中的基地址、段限制和访问控制信息。缓存在段寄存器中的信息（可见和隐藏）允许处理器转换地址，而不需要额外的总线周期来读取基地址和段描述符的限制。（也就是段描述符中的信息，作为缓存就能够更快的进行地址转换了。）在多个处理器可以访问一个 描述符表时，当描述符表被修改时，软件有责任重新加载到段寄存器中。否则，旧项可能被使用。

注明：当可见部分被 load 时，处理器也会load 它的隐藏部分（包含- 基址、大小、访问控制信息 ）

有两种方式提供 加载段寄存器

1. 直接加载 的 指令：MOV......，这些指令显示的使用寄存器
2. 隐式调用：……，这些指令通过改变 CS 中的内容（一些情况下是改变其余的寄存器）是他们操作的一部分



## 1.15 特权级CPL RPL DPL

> 主要内容：段描述符、特权级校验
>
> 验证  GDTR 寄存器中的内容
>
> global segment descriptor table register 全局段描述符表寄存器



### 段描述符

A segment descriptor is a data structure in a GDT or LDT that provides the processor with **the size and location of a segment,** as well as **access control and status information**. Segment descriptors are typically **created by compilers, linkers, loaders, or the operating system or executive, but not application programs.** Figure 3-8 illustrates the general descriptor format for all types of segment d

escriptors.

译：

一个段描述符 是一个数据结构，保存了 段的基址、段的大小、访问控制信息、状态信息。

段描述符是由 编译器、链接器、装载器 或者 操作系统 创建的，而应用程序不能创建。

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652347997963-6749177b-5887-4ba3-a6a7-039bc5897083.png?tximg)

1. L — 64-bit code segment (IA-32e mode only)
2. **DPL — Descriptor privilege level AVL — Available for use by system software**
3. **BASE — Segment base address**
4. D/B — Default operation size (0 = 16-bit segment; 1 = 32-bit segment)
5. G — Granularity （粒度，多大的大小）
6. LIMIT — Segment Limit 
7. **LIMIT — Segment Limit** 
8. **P — Segment present** （段是否在内存中，分页）
9. S — Descriptor type (0 = system; 1 = code or data) 
10. TYPE — Segment type



我们说这个表是可以由 操作系统填入的，那么我们瞅一瞅 Linux 系统中填入的 段描述符信息： 

```basic
.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */
.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */
```

其实我们将各个位置进行对位分析可以知道，所有的段都是从 0 位置到 最大地址 4GB 的，所以，可知 Linux 并没有使用分段机制

段描述符 + 指令地址寄存器 ==》 0 +  指令地址寄存器 =》 物理地址 =》 线性地址



### 特权级

#### DPL和RPL的解释（Priviliege level）

我们之前说过，需要保护操作系统，有推出特权级，特权级呢又需要进行保存，就像打标记一般，我们之前推测是放入到 **段描述符**中，由上面的图可以，正是这样实现的，通 过 DPL 表明当前段的特权级。因为其是段描述符中的，所以我们称之为 **DPL**

而与当前执行的指令的特权级又是放入到 段寄存器中的低两位的。表示当前请求的特权级（request），所以叫 **RPL**



#### R3-R0

虚拟化才会接触到R1、R2，正常开发使用不到这个级别的。

使用虚拟地址：保护进程之间

使用特权级：保护操作系统内核不受应用程序影响

general protection

用户态到内核态 == R3到R0（网关带你去访问R0）



#### 通过手册来查看 特权级信息

The processor uses privilege levels to prevent a program or task operating at a lesser privilege level from accessing a segment with a greater privilege, except under controlled situations. When the processor detects a privilege level violation, it generates a **general-protection exception** (#GP).

译文：

处理器使用特权级别来防止在较低特权级别上运行的程序或任务访问具有较高特权的段，但受控情况除外。当处理器检测到特权级别冲突时，它会生成一个通用保护异常(# gp)。



#### CPL、RPL、DPL

To carry out privilege-level checks between code segments and data segments, the processor recognizes the following three types of privilege levels:

1. **Current privilege level (CPL)**：The CPL is the privilege level of the **currently executing program or task.** It is **stored in bits 0 and 1 of the CS and SS segment registers.** Normally, the CPL is equal to the privilege level of the code segment from which instructions are being fetched.The processor changes the CPL when program control is transferred to a code segment with a different privilege level. The CPL is treated slightly differently when accessing **conforming code segments.** Conforming code segments can be accessed from any privilege level that is **equal to or numerically greater (less privileged) than the DPL of the conforming code segment.** Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.
2. Descriptor privilege level (DPL)：The DPL is the privilege level of a segment or gate. It is stored in the DPL field of the segment or gate descriptor for the segment or gate.When the currently executing code segment attempts to access a segment or gate, the DPL of the segment or gate is compared to the CPL and RPL of the segment or gate selector (as described later in this section). 		
3. Requested privilege level (RPL)：The RPL is an override privilege level that is assigned to segment selectors. It is stored in bits 0 and 1 of the segment selector.

译文：

要在代码段和数据段之间执行特权级别检查，需要处理或识别以下三种类型的特权级别:



通过翻译，我们可以总结：

1. CPL：当前执行的程序或任务的 特权级，存储在 CS 和 SS 寄存器中，一般情况下， CPL 的值是与从 段描述符表中拉出来的段描述符 中的 特权级相等的 ----> DPL。当程序控制转移到不同的特权级上执行，会改变 CPL 的值，在一致性代码防存过程中，可以接受 ring 值 >= DPL 的访问，但是在这个过程中，CPL不改变。（如果改变了那它的ring 就会变小，访问到一些不该访问的内存）
2. DPL：是段的特权级，存储在段描述符中，当有代码段尝试访问该段时，会将 被访问段的 DPL 与 CPL 和 RPL 进行比对，判断是否可以访问，判断的具体规则根据不同的类型有不同的规则
3. RPL：存放在 段选择子 的 低两位处



一致性代码：必须一样才能访问，只允许一致的代码访问

非一致性代码：兼容性比较好，只要比他的特权级小或者等于都能够访问。



**因为段选择器中存放了 RPL，而在 CS 和 SS 中有是存放的 CPL，所以在 CS 和 SS 寄存器中，这个 RPL 被称为 CPL，所以 CPL 是 RPL 的一个特例，CPU 会将其视为当前执行程序的特权级。**



#### 比对规则：

— **Data segment** — The DPL indicates the numerically highest privilege level that a program or task can have to be allowed to access the segment. For example, if the DPL of a data segment is 1, only programs running at a CPL of 0 or 1 can access the segment.

— **Nonconforming code segment (without using a call gate)** — The DPL indicates the privilege level that a program or task must be at to access the segment. For example, if the DPL of a nonconforming code segment is 0, only programs running at a CPL of 0 can access the segment.

— **Call gate** — The DPL indicates the numerically highest privilege level that the currently executing program or task can be at and still be able to access the call gate. (This is the same access rule as for a data segment.)

— **Conforming code segment and nonconforming code segment accessed through a call gate** — The DPL indicates the numerically lowest privilege level that a program or task can have to be allowed to access the segment. For example, if the DPL of a conforming code segment is 2, programs running at a CPL of 0 or 1 cannot access the segment.

译：

1. 数据段：只有特权级高于或等于 DPL 的才能访问（ring 相对小于等于 就 可以访问 eg：DPL = 1， 那么只有 CPL = 1 或 0 的才能访问）
2. 非一致性代码段（在没有使用 call gate 时）：表示必须达到该级别才能访问
3. call gate：与数据段相同
4. 一致性代码 和非一致性代码通过 call gate：只要特权级低于或等于 DPL 即可访问（注意：是 ring 值 >= DPL）



**如果 RPL 的数值大于CPL，那么 RPL会覆盖 CPL，RPL可用于确保特权代码不会代表应用程序访问某个段，除非该程序本身对该段具有访问权限**



Privilege levels are checked when the segment selector of a segment descriptor is loaded into a segment register. The checks used for data access differ from those used for transfers of program control among code segments; 

**当段描述符的段选择器加载到段寄存器时，会检查特权级别**。用于数据访问的检查与用于在代码段之间传输程序控制的检查不同；



### 数据段的检查

To access operands in a data segment, the segment selector for the data segment must be loaded into the datasegment registers (DS, ES, FS, or GS) or into the stack-segment register (SS). (Segment registers can be loaded with the MOV, POP, LDS, LES, LFS, LGS, and LSS instructions.)

 Before the processor loads a segment selector into a segment register, it performs a privilege check (see Figure 5-4) by comparing the privilege levels of the currently running program or task (the CPL), the RPL of the segment selector, and the DPL of the segment’s segment descriptor. The processor loads the segment selector into the segment register if the DPL is numerically greater than or equal to both the CPL and the RPL. Otherwise, a general-protection fault is generated and the segment register is not loaded.

译： 在数据段访问操作数时，数据段的段选择子必须加载到数据寄存器中（DS，以及其他段寄存器）或者 栈段寄存器中。

在处理器将段选择子加载到段寄存器中之前，它会先比较 CPL（当前执行的程序的特权级）、RPL（段选择子中的值）、DPL（段描述符中的值）来做权限校验。如果 DPL 的ring值高于 max（CPL,RPL）就将段描述符加载到段寄存器中，否则就会加载失败，产生 通用保护故障

总结：return DPL >= MAX(CPL, RPL)

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1660227323370-052495af-f8e9-4fa3-b144-981fa7fee27b.png?tximg)



### 代码段的检查



#### 非一致性代码

When accessing **nonconforming code segments**, the **CPL of the calling procedure must be equal to the DPL of the destination code segment;** otherwise, the processor generates a **general-protection exception (#GP).** For example in Figure 5-7: 

• Code segment C is a nonconforming code segment. A procedure in code segment A can call a procedure in code segment C (using segment selector C1) because **they are at the same privilege level** (CPL of code segment A is equal to the DPL of code segment C).

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652360888407-b5c6e71c-4a77-4877-a80f-3f446caac81d.png?tximg)

• A procedure in code segment B cannot call a procedure in code segment C (using segment selector C2 or C1) because the two code segments are at different privilege levels.

**总结：必须 三者相同才能访问**



#### 一致性代码

When accessing conforming code segments, **the CPL of the calling procedure may be numerically equal to or greater than (less privileged) the DPL of the destination code segment;** the processor generates a general-protection exception (#GP) only if the CPL is less than the DPL. (**The segment selector RPL for the destination code segment is not checked if the segment is a conforming code segment.**) 

**当访问一致性代码时, CPL 的值应该大于等于 DPL 的值, 否则就会产生 GP 异常,  (当访问的目标代码段是一致性代码时，段选择子中的 RPL 不会使用)**

In the example in Figure 5-7, code segment D is a conforming code segment. Therefore, calling procedures in both code segment A and B can access code segment D (using either segment selector D1 or D2, respectively), because they both have CPLs that are greater than or equal to the DPL of the conforming code segment.

 **For conforming code segments, the DPL represents the numerically lowest privilege level that a calling procedure may be at to successfully make a call to the code segment.**

**对于 一致性代码段，DPL 表示能访问的最低特权级**

![img](https://q-1306233034.cos.ap-guangzhou.myqcloud.com/company/1652361419309-556f9b4a-999a-4994-89ff-2d68e4fa7f0f.png?tximg)

总结：当前特权级  CPL  ring >= 目标代码段，不检查 RPL

既然我们说应用程序无法访问内核的代码，那么一些需要调用的内核代码时怎么进行调用呢？增加一个 gate，实现系统调用。



## 1.16 CPL、DPL、RPL

### CPL  DPL  RPL 重新整理

在程序运行中，我们如果不对其进行限制，就可能会造成一个程序去访问和修改另一个程序甚至是操作系统。所以我们需要对程序进行限制，限制当前程序是否可以访问内存中的各个位置的信息。

CPU 执行的是一条一条的指令，我们只需要对指令进行控制，就能够控制数据了。而指令是通过代码段寄存器（CS） + 指令地址寄存器 来获得指令的线性地址的，所以我们就将 CS 寄存器 中的低两位用于表示当前CPU执行的指令特权级，即 CPL （current privilege level）。除此之外，堆栈中由于是存放的当前指令流私有的数据，所以也可以代表当前指令流的指令特权级，所以 CS 以及 SS 中的低两位都是代表了 CPL

即使我有了当前的特权级，按理说应该可以访问比当前特权级低的所有（ring值更大的所有值），这样的话就有可能会造成一些错误的访问，比如我在 ring 0，想要去访问一个 ring 3 的数据，结果却错误的访问到了其他ring 0 的值，所以我们需要一个特权级来表明我们需要访问请求的特权级是多少，而请求的内容可以是各个方面的，但是都是需要通过段寄存器来查表，所以将段寄存器的低两位用来标识 请求的特权级 即 RPL（request privilege level）

既然我们有了当前CPU执行的指令所处了特权级，也有了避免误操作的代表请求的特权级，那我们就可以去查找数据了，查出中怎么确定是否有权利进行访问呢，就需要与数据本身的特权级进行对比，那数据本身的特权级我们存放在哪儿呢？因为我们定位内存地址时，都是要在段描述符表中找到段描述符后才能得到准确段基址，所以就将数据的特权级存放在段描述符中，称为DPL（descriptor privilege level）与CPL和RPL共同决定是否允许将段描述符的内容取出。



 第1期第16节。
因为上一节的CP ldpl和rp L讲的逻辑有点混乱，所以这又重新讲一下这三者的关系。

首先当我们的CPU权限不够的时候，我们可以借助门将特权集为3的，变成0，然后就可以访问dpl为0的数据了。

设置特权级是为了隔离操作系统和应用程序
CPU执行的指令，那么操作数据而不是指令，我们要对指令进行控制，我们要控制了指令就可以控制数据，而CS代码段，寄存器它用于查表查GD，T表舅可以得到我们的断机制，然后我们使用段基址加上指令寄存器我们就可以得到线性地址，那么我们使用段寄存器的后两位来表示特权级，也就是我们的cpl current。It's cute pl也就是我们当前CPU正在执行的指令流的特权级。

设置 Gdtr表主要是为了隔离不同的应用程序
数据是不是需要我们的指令来操控啊？那必然是如果没有指令的话，那么我们有很多数据都是没有用的，数据要访问同样是需要去查我们的表的，因为需要隔离不同的应用程序，将它们使用虚拟的内存空间来进行隔离，得到的就是数据段数据段的表的 index存在于DS寄存器中，那么这时候就需要有一个特权机来表示我当前需要请求的数据的权限应该是什么？ Request pl， Rpl.

每个段计算器叉S的后两位都可以称为rpg，换个角度来考虑，对于CS计算器而言，它请求的是CPU去访问某个段的指令，所以他就是ipl，而所有的一切都来源于CPU对指令的执行，所以从这个角度来说，它就代表了当前CPU执行的pl，所以就将 CS的ipl特定为此场景的cpl。（我虽然是请求他的，但是我就是此场景的请求者）

为什么SS后两位也被特别指定为cpl？
SS指向了堆栈段（其实这个堆栈段它就是站段，它里面全都是站，只是分出来一段空间用来将它作为栈）堆栈用于存储指令流之间的私有数据。既然CPI代表了当前执行的指令，而堆栈又是保存了这些指定操作的中间结果。 SS和CS后两位的rpl特例为CPl.

Dplrplcpl之间如何进行比较CPU最大吗？是的，因为CS和SS代表了当前 CPU执行的指令，所以当前执行的特权级必定高于，对于数据的请求DS等等寄存器cpl的权力大于rpl也就是cpl=3的时候，我的rpl就不能够小于3，因为CPU当前执行的指令决定了你当前的特权及cpl，rpl最终是要与dpl做对比。

CPL才是主要的，dpl是次要的。



### 分段 到 分页 优缺点分析

下面讲到分段分页机制。
P标志。
表明了这个段在不在内存中，如果在的话设为1，如果不在的话就清除。如果标志未被清除，这个处理器就会生成一个断不存在异常【NP】当段玄者指向他的时候，内存管理软件也就是我们的os，可以用这个标志为去控制段纯到物理地址。将我们换出去的物理页面换回来。
其实就是我们的操作系统内存不够了，然后需要把操作系统内存里面的东西把它放到物理磁盘里，物理磁盘当我们需要的时候，再从物理磁盘里面把数据拿出来。
这种机制之下就会造成很多内存外碎片，我一换我就要将整个战段给它换回来数据，段整个数据段，换回来代码段整个代码段换回来，一换就要换一坨代码，换一坨数据，非常的浪费io。（大并且不规整）
那么我们就将4GB切成4KB，以4KB的大小进行切分。数据栈代码段全部打散。
页帧，
页表：构建映射关系，线性地址与真实的物理地址之间的映射关系。（小并且规整）





### 流水线

历史

寄存器

书

最后到——》汇编

C语言通吃

