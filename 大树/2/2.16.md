## 堆内存分配

为何要有堆内存呢?

假设有这样一个需求，函数 A 调用函数 B 来创建一个结构体，并将结构体返回，如果没有堆内存的话，按照之前我们做的实验，就是使用栈 或者 寄存器来传递返回值（[如果结构体中的内容可以通过两个寄存器组合来表示就使用寄存器返回，否则会在函数A中先开辟足够的栈空间，并将栈空间中对应的地址放入到 rdi 传递过去，然后在函数B 结尾的时候将 结果值复制到 传递到 rdi 中的地址处](https://www.yuque.com/yishendushiyue/dpq9ps/dzwv6l#In57n)）。这样的话就会导致频繁的内存移动复制，效率比较低。出现这个状况的原因是什么呢？也就是栈帧会在方法返回时销毁，所以开辟数据地址无法返回使用（如果返回使用该指针就是 **野指针——指向一个已经销毁的地址**），所以我们需要一个区域不会随着方法的返回而销毁，那是不是可以使用 data 段呢？其实是不行的，因为 data段 是静态分配的，也就是在 编译时就确定了。

所以我们需要一个 动态分配的，且可以自由控制存活的区域来保存我们想要的数据。

于是就有了堆内存，这样一来，我们可以在 函数 B 中，在 堆内存中开辟一个区域，分配数据，然后将地址返回给函数 A，A就获得了该数据的引用，从而可以对该数据进行操作。



### 堆内存开辟

那堆内存要怎么进行开辟呢？

#### edata

![img](D:/javaDoc/pic/1654615389486-547b23a8-fde4-4e1d-a303-b7c56bf9ba08.png)

我们可以维护一个指针，就像 ESP 一样，通过对该指针就行加减操作来开辟内存，这就是 edata 方式来开辟内存

edata：边缘指针，也就是用于指定开辟哪个位置的指针。edata 从低地址往高地址推，达到开辟堆内存的目的。

这样的方式是存在一定缺陷的，比如我 edata 向上开辟了总共 20字节的空间，此时我将 最下面的 10 字节释放掉，那 edata 肯定是不能直接退回到最下面的，如果退回就会导致上面的10字节的数据可能会被覆盖。这样就导致了内存泄漏的问题。

**使用场景：适合较小的内存分配，这样即使是下边有内存回收掉泄漏的内存也没什么影响。、**



#### 随机开辟

![img](D:/javaDoc/pic/1654615405616-f5d93450-84f7-4f32-9ef3-aad1435210c0.png)

随机寻找一个空间，切割分配

这样就可以达到任意分配，且任意回收了。

但是这样就会导致由于不规整的内存占用，使得存在一些内存碎片无法被分配使用，从而降低内存的使用率。

**适合场景：较大的内存分配**



#### 优化

由于我们在内存分配时，需要通过操作系统提供的系统调用函数来实现，这就会涉及到内核态和用户态之间的切换，如果是多次频繁分配，那必定会造成性能上的损耗。所以我们可以预分配一段内存给程序，这样在用完该段空间之前都不会重新开辟。

想要完成该内容，就需要使用一些内存管理算法的来进行优化对内存的管理：

![img](D:/javaDoc/pic/1654648709914-4ce931ef-ffad-421c-afaa-f192ad49ba4b.png)

由于算法的多样性，所以在运行是确定使用哪个算法要怎么弄呢？使用之前说的库打桩技术，可以指定优先选用的算法。



## ABI协议

abi：应用程序二进制接口，是编译器和链接器遵守的一组规则，以让编译器生成的程序能够正常工作。

规范中指定了 数据类型宽度、寄存器的使用、函数调用……







------



注意：我们看 Redis 源码只是为了帮助我们熟练 C语言的语法

# Redis

知道是干嘛的，有什么用。才能分析是怎么实现的，应该从什么方面查看，剥离出无关紧要的东西

Redis：**多数据结构的内存缓存服务器**

为何出现呢？对比下计算机系统实现就能明白了

![img](D:/javaDoc/pic/1654652877368-1df75067-4c2d-4c1d-86a4-ef869a0b0c81.png)

所以说 redis 只是为了能够做一层缓存，来加速访问。而**缓存的根本思想就是：时间的局部性以及空间的局部性**。并且缓存并非是全量数据，所以是会存在缓存不命中的情况，该情况下只是会访问速度降低，并不应该导致系统崩溃。

所以缓存设计是要围绕着时间局部性和空间局部性来设计，具体哪些数据需要放缓存呢？常用数据，拿用户数据来举例，我们可以将活跃用户放入缓存中，而对不活跃用户使用完直接丢弃 —— 关于是否活跃就得通过数据分析来实现了（可以结合人工智能 和 数据挖掘来做）



通过以上分析，我们知道我们的核心诉求就是弄一个内存缓存设计，在分析下整体流程：

![img](D:/javaDoc/pic/1654653822395-f10e9c7e-d1b2-4229-8717-90f2c009732d.jpeg)

我们发现整体上数据的访问便快了，但是在网络环境中，响应和接收则是一个瓶颈，所以瓶颈还是在 IO 上，除此之外，虽然内存访问较快，但是如果对数据的访问在时间复杂度上较高，那依旧会导致访问很慢。

**所以瓶颈存在：网络IO处理、数据结构表示与算法设计**

**所以我们的设计核心在：IO处理以及数据的表示与处理**



## redis源码

首先找入口函数再分析





# 随机数

真随机数：外部环境相关，熵增，越随机

伪随机数：通过一些算法，比如线性同余 等实现的一种随机策略